---
slug: creating-driver-areas-for-parcel-delivery
title: "Creating driver areas for parcel delivery"
authors: [antonius]
tags: [introduction]
unlisted: true
image: https://fused-magic.s3.us-west-2.amazonaws.com/blog-assets/social_jennings.png
hide_table_of_contents: false
keywords: [introduction]
---

In the parcel delivery business, geographical evaluations are crucial. Do delivery drivers visit the same regions each day, letting them know their areas intimately? Or is there a high volatility of the areas? And of course, do multiple drivers go to the same region, leaving potential for improvement?
Those are the questions Antonius is working on at GLS Studio, an innovation lab by GLS (General Logistics Systems), an international parcel delivery service provider.
While the planned areas of driver tours can be rather well-defined, an evaluation of the areas actually served by drivers is equally important and might not be as easy. It can be used for guiding delivery drivers to become more efficient while also enabling managers to identify planned areas which are suboptimal due to limiting factors like rivers or big highways which have not been considered in the planning.
In this blog post, Antonius highlights the use of Fused to display the areas of a single day as well as aggregate multiple days with the purpose of creating stable driver areas.


{/* truncate */}


## The challenge

Creating areas out of single geospatial data points is challenging. A naïve approach would be to use convex polygons. This causes multiple issues: a single data point can have a high influence on the shape and area of the polygon, a tour consisting of multiple not connected sub-areas is hard to detect and correctly display, and just as important this limits the area to what is covered by historic data, so when intending to use areas for the future, there remain gaps which have not been covered historically. Lastly, a calculation using polygons is computationally expensive, hindering ad-hoc changes to the selected time span or the calculation parameters.

A further challenge is that building new and sometimes experimental features means that the database is often not optimized for the use case. Data needs to be joined between multiple tables and even between multiple data sources. Therefore, fetching all data can take a considerable amount of time, highly limiting the usefulness of having an experimental feature to play around with.


## The solution
The solution to the first problem came by using H3 cells instead of polygons. By assigning cells to the drivers based on their historic deliveries to the cell, driver areas are an automatic result. Using H3 cells across different resolutions also allows to represent the differences between urban and rural areas. While there exists one ‘base resolution’ to ensure non-overlapping and complete areas, the logical hierarchy among H3 cells can be used to calculate on lower resolutions for rural areas, speeding up the computation as well as ensuring a broader coverage of those areas beyond the historical data points. On the other hand, disputed H3 cells can be broken down to a higher resolution and assigned to different drivers or, when the ‘base resolution’ has been reached, assigned to the driver delivering most parcels to the cell. As H3 cells have clearly defined neighborhoods, areas can easily be extended beyond their historical limits when desired, covering the empty space around to also catch tomorrow's parcel which is just beyond the historical area boundaries.

Regarding the latency of querying and calculations, Fused UDFs came in handy. When a user looks at an area for a day, they are probably interested in the same area on some of the previous and following days as well, right? So why not pre-calculate that already. Using Fused, it is simply a matter of fire-and-forget to trigger the UDF with parameters for some previous and following days which are then already running to cache. So when the user is now checking out the day before, the data will already be there. And more in general, when it is possible to limit the number of parameter combinations in an experimental feature to a manageable amount, this fire-and-have-it-cached approach is not limited to caching data from previous and following days, but can also be used for a range of other cases.


## Conclusion
When developing new features which are not yet supported by the current data infrastructure, Fused UDFs enabled us to easily test things without having to change the underlying infrastructure in advance. The UDFs are easily shareable and adjustable, allowing testing by multiple people without having to run code locally while automatically making sure everyone is using the same code which is hosted in the UDF. And now, when we have verified the feasibility, the first feature created using Fused is about to be integrated into our product.
