---
id: call
title: Call UDFs
tags: [write, endpoints, api, http, file, tile]
sidebar_position: 2
toc_min_heading_level: 2
toc_max_heading_level: 4
---


Fused automatically creates an endpoint for all saved Fused UDFs. When a client application calls a UDF endpoint, Fused runs a lightweight serverless Python operation and returns the function output. A call to a Fused UDF endpoint can return data as if it were a single remote `File`. The same endpoint can be called dynamically as `Tile` and natively integrate with [Tiled web map](https://en.wikipedia.org/wiki/Tiled_web_map) systems.

## File & Tile

To understand how a Fused UDF can be configured to execute, it's important to first understand the difference between `File` and `Tile` endpoints. 

Consider this diagram. When loaded as a remote File, every coordinate of the complex polygon would be included in one single file. In a Tiled format, there are predefined tile sets (grids) and the geometry is split into one or more Files, where each File represents one cell of the grid.

import ImageFileTile from '/img/filetile6.png';

<div style={{textAlign: 'center'}}>
<img src={ImageFileTile} alt="File" style={{width: 400}} />
</div>

Loading or rendering an entire dataset can be an expensive operation because of the data volume that must transfer across the network. Fused UDFs can be designed to automatically split and output a dataset across several `Tiles` - and speed up computation by operating on each part of the dataset in parallel. 

#### File

When an endpoint is called as a `File`, the UDF runs only once and returns all output data in a single batch. This behaves like the standard access pattern for a remote file URL (such as with an S3 endpoint).

import ImageFile from '/img/image-file2.png';

<div style={{textAlign: 'center'}}>
<img src={ImageFile} alt="File" style={{width: 600,}} />
</div>


#### Tile

When and endpoint is called as a `Tile`, the endpoint becomes interoperable with Tiled web map clients. The endpoint is called as a `File` for every `Tile` requested, and Fused dynamically passes a `bbox` object to each UDF call, with `z`, `x`, and `y` values corresponding to the index of each tile on the map.

import ImageTile from '/img/image-tile2.png';


<div style={{textAlign: 'center'}}>
<img src={ImageTile} alt="File" style={{width: 600}} />
</div>

## The `bbox` object

One of Fused's most powerful features is its first-class support for [cloud-optimized data formats](https://guide.cloudnativegeo.org/): it can effeciently load only a fraction of a dataset. 

A UDF becomes spatially aware when it leverages the `bbox` parameter to spatially filter the datasets it operates on. This way, Fused distributes the execution across multiple workers that scale up and wind down as needed. Tile-level spatial filtering supercharges UDFs to process only specific parts of a dataset - based on specified geographic or logical partitions.

:::tip
The growing popularity of cloud optimized data formats is revolutionizing data processing by eliminating the need for specialized hardware to handle large datasets. For further reading on data formats, refer to resources on: [Cloud Optimized GeoTiff](https://www.cogeo.org/), [Geoparquet](https://geoparquet.org/), and [GeoArrow](https://geoarrow.org/format.html).
:::

Consequently, Tiled web map clients can call Fused endpoints and dynamically pass a ZXY index for each Tile to render. When a UDF endpoint is called this way - in Tile mode - Fused passes the UDF a `bbox` object as the first parameter. This object is a data structure with information that corresponds to the Tile's bounds and/or XYZ coordinates. The object is named `bbox` by convention, but it's possible to use a different name __as long as it's in the first parameter__.

:::tip

If the UDF is called as a File, Fused does not pass a `bbox` parameter. To write UDFs so they can be called in either execution mode, Fused recommends setting the `bbox` as the first parameter, and typing it as a `fused.types.Bbox` with a default value of `None`. This will enable the UDF to run in both as `File` (when `bbox` isn’t necessarily passed) and as a `Tile`. For example:

```python
@fused.udf
def udf(bbox: fused.types.Bbox=None):
    ...
    return ...
```

When using the Fused Workbench, a UDF can be configured to render as "Auto" so Workbench automatically handles the output as `Tile` if it statically checks that the above types are used in the UDF. Otherwise, it assumes File.

UDFs called via the Fused Python SDK or HTTP requests run as Tile only if a parameter specifies the `Tile` geometry. 
:::

### `bbox` object types
:::tip
Read more about [supported types for UDF parameters](/python-sdk/#typing). 
:::
For convenience, users can configure the Python type of the `bbox` object. The 3 available types for the `bbox` object are:

#### `fused.types.TileGDF` 
This is a [geopandas.geodataframe.GeoDataFrame](https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.html) with `x`, `y`, `z`, and `geometry` columns.

```python
@fused.udf
def udf(bbox: fused.types.TileGDF=None):
    print(bbox)
    return bbox

>>>      x    y   z                                           geometry
>>> 0  327  790  11  POLYGON ((-122.0 37.0, -122.0 37.1, -122.1 37.1, -122.1 37.0, -122.0 37.0))
```

#### `fused.types.Bbox` 
This is a [shapely.geometry.polygon.Polygon](https://shapely.readthedocs.io/en/stable/reference/shapely.Polygon.html) corresponding to the Tile's bounds.

```python
@fused.udf
def udf(bbox: fused.types.Bbox=None):
    print(bbox)
    return bbox

>>> POLYGON ((-122.0 37.0, -122.0 37.1, -122.1 37.1, -122.1 37.0, -122.0 37.0))
```


#### `fused.types.TileXYZ` 
This is a [mercantile.Tile](https://mercantile.readthedocs.io/en/stable/api/mercantile.html) object with values for the `x`, `y`, and `z` Tile indices.

```python
@fused.udf
def udf(bbox: fused.types.TileXYZ=None):
    print(bbox)
    return bbox

>>> Tile(x=328, y=790, z=11)
```




### Spatially filtering

##### Spatially filter raster files

The Fused utility function `utils.mosaic_tiff` and `pystac-client`'s `catalog.search` illustrate how to use `bbox` to spatially filter a dataset.

For example, function `utils.mosaic_tiff` generates a mosaic image from a list of TIFF files. `bbox` defines the area of interest within the list of TIFF files set by `tiff_list`.

```python
@fused.udf
def udf(bbox: fused.types.TileGDF=None):

    utils = fused.load("https://github.com/fusedio/udfs/tree/f928ee1/public/common/").utils
    data = utils.mosaic_tiff(
        bbox=bbox,
        tiff_list=tiff_list,
        output_shape=(256, 256),
    )
```

As an example, the [LULC_Tile UDF](https://github.com/fusedio/udfs/blob/b89a3aab05cb75dab25abb73e4c17490844ab764/public/LULC_Tile_Example/LULC_Tile_Example.py#L21-L27) uses `mosaic_tiff` to create a mosaic from a set of Land Cover tiffs.


##### Spatially filter STAC datasets

STAC ([SpatioTemporal Asset Catalog](https://github.com/radiantearth/stac-spec)) datasets can be queried by passing the bounding box’s bounds (`bbox.bounds`) to the pystac client of the Python [pystac-client](https://pypi.org/project/pystac-client/) library.

```python
@fused.udf
def udf(bbox: fused.types.TileGDF=None):

    import pystac_client
    from pystac.extensions.eo import EOExtension as eo

    catalog = pystac_client.Client.open(
        "https://planetarycomputer.microsoft.com/api/stac/v1",
        modifier=planetary_computer.sign_inplace,
    )
    items = catalog.search(
        collections=[collection],
        bbox=bbox.total_bounds,
    ).item_collection()
```


## Create a UDF endpoint

Every UDF saved to your Fused cloud will be assigned an API endpoint. When an app calls the endpoint, Fused runs the UDF and returns the function output. As your call these endpoints, Fused automatically provision serverless compute resources for the execution, so you don't have to manage endpoints or infrastructure. Any tool in your stack can call a Fused UDF with a simple HTTP request to process and fetch data, which enables you to easily create reactive applications that integrate across your stack.

Endpoints created with Fused Hosted API seamlessly integrate with tools such as:

- Tile web map clients: Simply pass the templated endpoint to mapping clients such as open source JavaScript frameworks (e.g. leaflet, Deck.gl, and Kepler.gl), proprietary web-based apps (such as Felt and Foursquare Studio), or desktop based tools (such as ArcGIS, ESRI, and QGIS).
- Apps that make HTTP requests: Load data into low-code app builders such as Streamlit & Retool.
- Apps that render embeddable maps and apps: Embed responsive maps to significantly enhance the utility and interactivity of documentation sites and apps, such as Notion.

:::note
Shared endpoints cache UDF outputs by default for each combination of code and input parameters, which can be useful for performance and cost savings. A client application calling an endpoint will compute the UDF only once for each unique input, and subsequent calls will return the cached result. This might be experienced in the form of a slight latency in the first call, with subsequent calls running faster.
:::

The following sections describes how to create a UDF endpoint from Workbench or with the Fused Python SDK. They also describe how to make authenticated calls to these endpoints. See the ["Get data out"](/basics/out/) section for examples of how to use the endpoints streamline integrations with the different tools in the modern data stack.

## Generate endpoints with Workbench

Once a UDF is saved in Workbench, the "Settings" tab of the editor shows code snippets that can be used to call the UDF from different environments. 

:::note
    Endpoints can be called with "private" or "shared" authentication tokens. Shared tokens are easy to create and revoke. Use shared tokens to call UDFs from 3rd party applications or to share them with others.
:::


### Shareable public endpoints

The "Share" subsection contains snippets with shared tokens and signed URLs. 
- `HTTP` is the URL to call the UDF endpoint.
- `cURL` is the command to call the UDF endpoint from the terminal.
- `Python` is the code to call the UDF endpoint from a Python environment using the token.
- `Token` is the shared token, which you'll notice appears in the above snippets. 


import ImageShare from '/img/share.png';

<div style={{textAlign: 'center'}}>
<img src={ImageShare} alt="File" style={{width: '80%'}} />
</div>


### Private endpoints

The "Snippets" subsection below it contains snippets that can only be called with the authoring account's authentication.
- `cURL` is the command to call the UDF endpoint from the terminal, which requires the authoring account's private token.
- `Python` is the code to call the UDF endpoint from a Python environment using the token.
- `Load this UDF` is loads the UDF into a Python environment where it can be modified, chained with other UDFs, or called. 


import ImageSnippets from '/img/snippets.png';

<div style={{textAlign: 'center'}}>
<img src={ImageSnippets} alt="File" style={{width: '80%'}} />
</div>


## Generate endpoints with `fused-py`


### Get an account's private token

Python environments where the authentication flow completed successfully store a credentials key in the default location ` ~/.fused/credentials`. Calls to UDFs from those environments will use that key, unless a token for a different account is explicitly set in the call. Making calls to endpoints from a non-authenticated environment will need the authenticated account's access token, which can be retrieved with the following commands.

```python
from fused._auth import CREDENTIALS

CREDENTIALS.credentials.access_token
```


:::danger

Note that the "private" token can access all UDFs and should be kept private. The recommended approach is instead to use "shared" tokens with tightly scoped permissions, as detailed below.

Remember that tokens are tied to the account that created them and requests to their corresponding endpoints will accrue charges on that account.
:::


This is how to call UDF endpoints via HTTP requests with the token.

```bash
curl -XGET https://app.fused.io/server/v1/realtime-shared/$SHARED_TOKEN/run/file
```

### Create and manage shared tokens (recommended)

Shared tokens are tightly scoped to a single UDF, and can easily be revoked. Creating a shared token for a UDF returns a token object that, among other attributes, contains the token as a string and sample endpoint URLs.

This is how to to call UDF endpoints in Python with signed token URLs.
```python
from fused.api import FusedAPI
api = FusedAPI()

token_object = api.create_udf_access_token(udf_email="user@fused.io", udf_name="caltrain_live_location")
output = fused.core.run_shared_file(token=token_object.token, my_param="...")
```

### Manage shared tokens

Fetch a specific UDF token object using its unique token string:
```python
token_object = api.get_udf_access_token(token=token.token)
```

Fetch all UDF tokens:
```python
token_objects = api.get_udf_access_tokens()
```

Update a specific UDF token using its unique token string:
```python
token_object = api.update_udf_access_token(token=token.token, enabled=True)
```

Delete a specific UDF token using its unique token string:
```python
api.delete_udf_access_token(token=token.token, enabled=True)
```


Similarly, signed URLs endpoints can be created that can be called from another application via HTTP requests.

### Single File HTTP endpoints

Single file HTTP endpoints are suitable for handling individual requests, ideal for scenarios where a single resource is required, such as loading data into [Google Sheets](/basics/out/googlesheets/).


```python
from fused.api import FusedAPI
api = FusedAPI()

# URL for single call
api.create_udf_access_token(udf_email="user@fused.io", udf_name="caltrain_live_location").get_file_url()
```

### Tile HTTP endpoints

Tile HTTP endpoints are designed for serving map applications that consume Tiles, such as [Lonboard](/basics/out/lonboard/) or [geemap](/basics/out/geemap/).

```python
from fused.api import FusedAPI
api = FusedAPI()

# URL for XYZ tiles
api.create_udf_access_token(udf_email="user@fused.io", udf_name="caltrain_live_location").get_tile_url()
```

## Call UDFs

UDFs can be triggered via the Python SDK or HTTP requests, and they can return data in different formats depending on how they're called. The following sections describe how to call UDFs and how to configure calls to return data in different formats.

### Call UDFs with Python


The Fused Python SDK exposes methods to call UDFs. In Python environments authenticated to Fused, the UDF be called or imported in these 3 ways:


#### Call UDF and return its output

```python
fused.run("user@fused.io", "Overture_Maps", x=2808, y=6542, z=14, my_udf_parameter=5)
```

#### Call UDF asynchronously and return its output

:::note
    [nest_asyncio](https://pypi.org/project/nest-asyncio/) might be required to run UDFs async from Jupyter Notebooks.
    ```python
    !pip install nest-asyncio -q
    import nest_asyncio
    nest_asyncio.apply()
    ```
:::

```python
import asyncio
import fused

# Run the UDF in an async function
async def main():
    return await fused.run("user@fused.io", "Overture_Maps", x=2808, y=6542, z=14, sync=False)

# Run the coroutine and capture the result
gdf = asyncio.run(main())

# Use the returned value outside the event loop
gdf.head()

```

#### Load as a UDF object

To load UDFs saved in Fused user accounts specify the user email and UDF name separated by a forward slash `/`.

```python
my_udf = fused.load("user@fused.io/caltrain_live_location")
```

### Call UDFs with HTTP requests

Beyond Python, other frameworks can call the UDF endpoint via HTTP requests and receive output data in the response. This makes it easy to load data from UDFs into Tile-based mapping tools such as [DeckGL](https://deck.gl/docs/api-reference/geo-layers/tile-layer), [Mapbox](https://docs.mapbox.com/mapbox-gl-js/example/vector-source/), and [Felt](https://felt.com/), or no-code data analytics environments like [Google Sheets](https://support.google.com/docs/answer/3093335?hl=en) and [Retool](https://docs.retool.com/apps/web/guides/components/custom). Read the ["Get data out"](/basics/out/) section of the documentation for example integrations with your favorite tools. 


#### Shared token

To run a UDF via HTTP request, generate a [signed UDF endpoint](/basics/core-concepts/#generate-endpoints-with-workbench) then modify the provided URL. 

Structure the URL with the `file` path parameter to run as a single batch operation.

```
https://www.fused.io/server/v1/realtime-shared/******/run/file?dtype_out_raster=png
```

To integrate with a tiling service, structure the URL with the `tiles` path paramater, followed by templated `/{z}/{x}/{y}` path parameters. See [Lonboard](/basics/out/lonboard/) for an example.

```
https://www.fused.io/server/v1/realtime-shared/******/run/tiles/{z}/{x}/{y}?dtype_out_raster=png
```

#### Private token

Calling UDFs with [Bearer authentication](https://swagger.io/docs/specification/authentication/bearer-authentication/) requires an account's [private token](/basics/utilities/#get-an-accounts-private-token). The URL structure to run UDFs with the private token varies slightly, as the URL specifies the UDF's name and the owner's user account. 

```bash
curl -XGET "https://app.fused.io/server/v1/realtime/fused/api/v1/run/udf/saved/user@fused.io/caltrain_live_location?dtype_out_raster=png" -H "Authorization: Bearer $ACCESS_TOKEN"
```

### Response formats

The response data format is configured with the `dtype_out_vector` and `dtype_out_raster` parameters. Because the UDF's returned object determines whether response is a vector or raster, both parameters can be specified simultaneously, which the sample snippets show in query parameters like: `?dtype_out_raster=png&dtype_out_vector=csv`.

Vector:
- `parquet` 
- `geojson`
- `json` 
- `feather` 
- `csv` 
- `mvt` 
- `html` 
- `excel` 
- `xml`

Raster:
- `png` 
- `gif` 
- `jpg` 
- `jpeg`
- `webp` 
- `tif` 
- `tiff`


### File endpoint

By default, a UDF runs as `File` - it executes once and returns a single output that corresponds to the input parameters. The UDF endpoint behaves like a remote file in that calling it returns a single batch of data - but the endpoint also accepts parameters that dynamically influence the UDF's execution. 

```bash
https://www.fused.io/server/.../run/file?dtype_out_vector=csv
```

This enables client applications to make an HTTP request and load the UDF's output data into the tool that makes the call.

:::tip
Note that files are downloaded entirely - even if the data is requested as a Parquet.
:::

### Tile endpoint

The same UDF's API endpoint can be called to run like a `Tile`. This makes it possible for Fused to serve vector or raster tiles into industry standard tools that work with [tiled web maps](https://en.wikipedia.org/wiki/Tiled_web_map) - think Leaflet, Mapbox, Foursquare Studio, Lonboard, and beyond. 

```bash
https://www.fused.io/server/.../run/tiles/{z}/{x}/{y}?&dtype_out_vector=csv
```


Tiled web map clients can make dozens of simultaneous calls to the Fused API endpoint - one for each tile - and seamlessly stitch the outputs to render a map. Instead of operating on an entire dataset, Fused only acts on the data that corresponds to the area visible in the current viewport.



:::tip
You can read more about the XYZ indexing system in the [Deck.gl](http://Deck.gl) [documentation](https://deck.gl/docs/api-reference/geo-layers/tile-layer#indexing-system). In fact, Fused Workbench runs UDFs on a serverless backend and renders their output on a Deck.gl map.
:::




#################

For example the following UDF accepts a `gpd.GeoDataFrame` type for the `target_gdf` parameter. 

```python
import geopandas as gpd

@fused.udf
def my_udf(target_gdf: gpd.GeoDataFrame=None):
    return target_gdf
```

When calling the UDF with a GeoJSON string for the `target_gdf` parameter, Fused will automatically convert the string to a `GeoDataFrame` object.

```python
import fused
import geopandas as gpd
import json

target_geom = json.dumps({"type":"FeatureCollection","features":[{"type":"Feature","properties":{},"geometry":{"type":"Polygon","coordinates":[[[-122.51121183018593,37.77096317381872],[-122.47612122306056,37.77228925202057],[-122.44351531587931,37.77597823096521],[-122.44362991745042,37.7664402812457],[-122.50998289649768,37.76279226591039],[-122.51121183018593,37.77096317381872]]]}}]})

gdf = fused.run(my_udf, target_gdf=target_geom)

```




:::warning
Note that the parameter must not be named `bbox` because `fused.run` will handle that reserved parameter name in a special way.
:::


For example this function accepts a `bbox` object of `fused.types.Bbox` type, a `table_path` string, and an `n` integer.

```python
@fused.udf

def udf(
    # highlight-start
    bbox: fused.types.Bbox = None, # UDF parameters
    table_path: str = "", 
    n: int = 10
    # highlight-end
):
    from utils import table_to_tile

    gdf=table_to_tile(bbox, table=table_path)
    return gdf
```
:::info
When UDF endpoints are called via HTTP requests argument values are specified with [query parameters](https://www.branch.io/glossary/query-parameters/), which require input parameters to be serializable. As such, Fused needs to know the types to cast them to. Read more about [supported types for UDF parameters](/python-sdk/#typing). 
:::

The `bbox` argument gives the UDF spatial awareness and users can decide its structure, for convenience - which you can read more about [here](/basics/core-concepts/#the-bbox-object).

When its endpoint is called like so, Fused injects a `bbox` parameter corresponding to a Tile with the `1,1,1` index, resolve `table_path` value as a string and the `n` value as an integer.

```bash
curl -XGET "https://app.fused.io/server/v1/realtime-shared/$SHARED_TOKEN/run/tiles/1/1/1?table_path=table.shp&n=4"
```

:::info

The following are reserved parameter names: `x`, `y`, `z`, `bounds`, `lat`, and `lng`. `fused.run` will handle them in a special way.

:::






In addition to its utils module, a UDF can alse import from other UDFs' utils modules or from a [GitHub repo using `fused.load`](/workbench/map-builder/udf-editor/#from-github).

The UDF can load these functions with an import statement such as: `from utils import your_function`. 


#### From GitHub

```python
@fused.udf
def udf( 
    bbox: fused.types.Bbox = None,
    table_path: str = "s3://fused-asset/infra/building_msft_us/", 
):
    # highlight-start
    utils = fused.load( # <- Utility functions
        "https://github.com/fusedio/udfs/tree/eda5aec/public/common/"
        ).utils 

    # highlight-end
    gdf=utils.table_to_tile(bbox, table=table_path)
    return gdf
```

#### From `fused.common`

The `fused.utils.common` module contains public utility functions curated by the Fused team. They can be found in the [utils.py](https://github.com/fusedio/udfs/blob/main/public/common/utils.py) file of the public UDFs repository. All of the utility functions from public UDFs are available under the `fused.utils.` module. 