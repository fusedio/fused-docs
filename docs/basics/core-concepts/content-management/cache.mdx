---
id: cache
title:  Cache
tags: [cache]
sidebar_position: 5
---

import Tag from '@site/src/components/Tag'

## <Tag color="#D1E550" fontColor="#141414" >ðŸš§ Under Construction</Tag>

## The `@fused.cache` decorator

Fused executes UDFs sequentially, so caching the results of slow computations can save time. Use the `@fused.cache` decorator to persist a function's output across runs, enabling faster iteration and avoiding repeated execution of slow code. For more details, refer to the [caching documentation](/basics/core-concepts/advanced/content-management/cache/).


```python
@fused.udf
def udf(bbox):

    @fused.cache
    def sample_function(n):
        return ...

    return sample_function(n=1)

```


Because Fused executes UDFs sequentially from top to bottom, it can be beneficial to cache the results of computationally expensive sections. This approach allows you to run these sections once and reuse their output, speeding up iteration and development. For more information on caching, see our caching documentation.

To implement caching, simply decorate a function with @fused.cache. This ensures that the function's output persists across runs, allowing you to quickly iterate on the rest of your code without repeatedly executing slow computations.



:::tip

On the [Workbench UDF Editor](/workbench/map-builder/udf-editor/), every time you modify a UDF's code, Fused automatically runs the code from top to bottom. This reactive execution model keeps code and outputs consistent, and gives you immediate feedback. However, you likely don't want to wait for slow sections of code to run each time, which is where caching comes in handy.

:::


##### Basic caching

To illustrate, this function accepts an argument and a keywork argument. When the function is called to set `output_1` and `output_2`, Fused caches the output of each call as separate objects. That way, the UDF only runs the function once for each argument combination.

```python
@fused.udf
def udf(bbox):
    import pandas as pd

    @fused.cache
    def sample_function(name, company="Fused"):
        return f"{name}, at {company}, cached this function's output."

    output_1 = sample_function("Sina")
    output_2 = sample_function("Plinio", company="Fused.io")
    return pd.DataFrame([output_1, output_2], columns=["output"])

```

##### Advanced caching

At this point, ony might ask: if UDFs run for each tile in the viewport, how does Fused distinguish the cache for each tile? When working with [Tile-based execution](/basics/core-concepts/call/#tile) you should pass the [`bbox` object](/basics/core-concepts/call/#the-bbox-object) as a parameter to the cached function so each Tile's output is unique.

:::tip

Fused caches the function's output using a unique hash identifier generated based on a combination of the function's code, the value of its parameters, and the reserved `_cache_id` argument (which you may set). 

:::

This example shows how:
- Passing the `bbox` object to the cached function makes the output unique to each tile.
- A custom caching directory can be set with the optional `path` parameter.
- The cache for the function can be reset by running the UDF once with the optional `reset` parameter set to `True`.
- A unique `_cache_id` string identifier can optionally be passed to the function.

```python
@fused.udf
def udf(bbox):
    import pandas as pd
    import numpy as np

    @fused.cache(path='optional_cache_dir', reset=True)
    def sample_function(bbox, name, company="Fused"):
        x,y,z = bbox.iloc[0][['x', 'y', 'z']]
        return f"{name}, at {company}, cached this function's output for the tile {z} {x} {y}."

    seed = np.random.randn()
    output_1 = sample_function(bbox, "Plinio", company="Fused.io", _cache_id=str(seed))
    return pd.DataFrame([output_1], columns=["output"])
```