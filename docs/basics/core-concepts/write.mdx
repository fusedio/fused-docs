---
id: write
title:  Write UDFs
tags: [write, "@fused.udf", "@fused.cache", typed parameters, utility functions, return object]
sidebar_position: 1
toc_min_heading_level: 2
toc_max_heading_level: 2
---



import ImageAnatomy from '/img/udfanatomy.png';

<div style={{textAlign: 'center'}}>
<img src={ImageAnatomy} alt="File" style={{}} />
</div>


 Follow these steps to write a UDF.
- Decorate a function with [`@fused.udf`](/basics/core-concepts/write/#fusedudf-decorator)
- [Declare the function](/basics/core-concepts/write/#function-declaration) logic
- Set [typed parameters](/basics/core-concepts/write/#typed-parameters) to dynamically run based on inputs
- Import [utility modules](/basics/core-concepts/write/#utils-module) and modularize
- [Return](/basics/core-concepts/write/#return-object) a vector table or raster
- [Save](/basics/core-concepts/write/#save-udfs) the UDF

## `@fused.udf` decorator

First decorate a Python function with `@fused.udf`. This makes the function run on the Fused cloud, which provisions and scales compute. 


## Function declaration

Now structure the function's code. Import Python libraries, interact with upstream data sources, and return an object. Import statements go in the function so they come wherever the function runs.

This UDF is called `udf` and returns a `pd.DataFrame` object. 


```python
# highlight-next-line
@fused.udf # <- Fused decorator
# highlight-start
def udf(bbox: fused.types.Bbox = None, name: str = "Fused"): # <- Function declaration
    import pandas as pd

    @fused.cache # <- Cache decorator
    def structure_output(name):
        return pd.DataFrame({'message': [f'Hello {name}!']})
    
    df = structure_output(name)
    return df
# highlight-end
```

The [@fused.cache](/basics/core-concepts/content-management/cache/) decorator persists a function's output across runs so you move faster. 


## Typed parameters

UDFs support [Python function annotations](https://peps.python.org/pep-3107/) to specify argument types. Parameters serialized in HTTP calls resolve to intended types. These ensure arguments resolve to specified types at run time.

### Supported types

Fused supports the Python types `int`, `float`, `bool`, `list`, `dict`, and `list`. Parameters without a specified type are handled as strings by default.

The geospatial types `fused.types.Bbox`, `fused.types.TileXYZ`, and `fused.types.TileGDF` on the [first parameter](/basics/core-concepts/filetile/#the-bbox-object) tell Workbench to run the UDF as a [Map Tile or File](/basics/core-concepts/filetile/).

### `pd.DataFrame` as JSON

Pass tables and geometries as seriarized UDF parameters in HTTPS calls. DataFrames passed as JSON strings show up as a `pd.DataFrame` when typed. GeoJSON strings as a `gpd.GeoDataFrame`. 

### Reserved parameters

Fused handles reserved parameters in special ways: `x`, `y`, `z`, `bounds`, `lat`, and `lng`. `fused.run`.

## `utils` Module

Modularize code to make it readable, maintainable, and reusable. 

Define a UDF's `utils` Module file in the Workbench ["Module" tab](/workbench/map-builder/udf-editor/#module-tab) and import it in the UDF.

```python
from utils import function
```

### Import utils from other UDFs

UDFs import the `utils` Module from other UDFs with `fused.load` in the [UDFs GitHub repo](https://github.com/fusedio/udfs/tree/main) or [private GitHub repos](/basics/core-concepts/content-management/git/). Here the commit SHA `05ba2ab` pins `utils` to specific commit for version control.


```python
utils = fused.load(
    "https://github.com/fusedio/udfs/tree/05ba2ab/public/common/"
)
```


Modules in the public UDFs repo are imported from `fused.utils`.

```python
utils = fused.utils.common
```

`utils` Module are imported from other UDFs in a user's account.

```python
utils = fused.load("your@email.com/my_udf").utils
```

## `return` object

UDFs return either a table or an array. Tables can be: `pd.DataFrame`, `pd.Series`, `gpd.GeoDataFrame`,  `gpd.GeoSeries`, and `shapely geometry`. Arrays: `numpy.ndarray`, `xarray.DataArray`, and `io.BytesIO`. To return geospatial data see ["Tile" & "File"](/basics/core-concepts/filetile/).

## Save UDFs

UDFs downloaded from Workbench or saved locally are formatted as a `.zip` file containing associated files with the UDFs code, `utils` Module, metadata, and `README.md`. 

```
└── Sample_UDF
    ├── README.MD       # Description and metadata
    ├── Sample_UDF.py   # UDF code
    ├── meta.json       # Fused metadata
    └── utils.py        # `utils` Module
```

When outside of Workbench save UDF to your local filesystem with `my_udf.to_directory('Sample_UDF')` and to the Fused cloud with `my_udf.to_fused()`.

