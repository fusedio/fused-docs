---
id: write
title:  Write UDFs
tags: [write, "@fused.udf", "@fused.cache", typed parameters, utility functions, return object]
sidebar_position: 1
toc_min_heading_level: 2
toc_max_heading_level: 4
---



import ImageAnatomy from '/img/udfanatomy.png';

<div style={{textAlign: 'center'}}>
<img src={ImageAnatomy} alt="File" style={{}} />
</div>


 Keep these key components in mind as you write a UDF.
- Decorate the function with the [`@fused.udf`](/basics/core-concepts/write/#fusedudf-decorator) decorator
- [Declare the function](/basics/core-concepts/write/#function-declaration) and, optionally, cache intermediate outputs with [`@fused.cache`](/basics/core-concepts/write/#fusedcache-decorator)
- Set [typed parameters](/basics/core-concepts/write/#typed-parameters) to dynamically execute code based on arguments
- Import [utility modules](/basics/core-concepts/write/#utils-module) to modularize code
- Set a vector table or raster as a [Return object](/basics/core-concepts/#d-return-object)


### `@fused.udf` decorator

First decorate a Python function with `@fused.udf`. This makes the function run on the Fused cloud, which can provision and scale compute. 


### Function declaration

The next step is to structure the function's code. It can import Python libraries, run code to interact with upstream data sources, and return an object. Place import statements inside the function declaration to ensure they are included wherever the function is executed.

To illustrate, this UDF is a function called `udf` that returns a `gpd.GeoDataFrame` object. 


```python
# highlight-next-line
@fused.udf # <- Fused decorator
# highlight-start
def udf(bbox: fused.types.Bbox = None, name: str = "Fused"): # <- Function declaration
    import pandas as pd
    df = pd.DataFrame({'message': [f'Hello {name}!']})
    print(df)
    return df
# highlight-end
```

:::note
To make UDFs run successfully as both ["Tile" & "File"](/basics/core-concepts/call/#file--tile). It's good practice to reserve the first parameter of the function and set it to `None`, as Fused will handle it a special way when the UDF is called as a "Tile". 
:::

### Typed parameters

Fused UDFs support [Python function annotations](https://peps.python.org/pep-3107/), which allow you to specify argument types in the function signature. This is crucial for parameters serialized in HTTP calls to resolve to the intended types. These annotations ensure that each argument is resolved to the specified type to prevent type-related errors. 

#### Supported types

Supported native Python types are `int`, `float`, `bool`, `list`, `dict`, and `list`. Any parameters that are not annotated with a specific type are handled as strings by default.

Fused also supports the geospatial types `fused.types.Bbox`, `fused.types.TileXYZ`, and `fused.types.TileGDF`. When one of these types is assigned to the first parameter of the function ([read more](/basics/core-concepts/call/#bbox-object-types)) Fused Workbench will handle the UDF as a "Tile" otherwise as a "File". 






#### `pd.DataFrame` as JSON

DataFrames can be passed as JSON strings and have the UDF interpret them as a `pd.DataFrame`. The same applies for GeoJSON strings, which can be passed as a `gpd.GeoDataFrame` type parameter. This is helpful to pass tables and geometries as seriarized UDF parameters in HTTPS calls, so they can directly be used as a typed parameter. 


#### Reserved parameters

The following are reserved parameter names: `x`, `y`, `z`, `bounds`, `lat`, and `lng`. `fused.run` will handle them in a special way.

### `utils` Module

When writing UDFs it's important to modularize code to make it readable, maintainable, and reusable. 

Every UDF has a `utils` module file which can be edited in the ["Module" tab](/workbench/map-builder/udf-editor/#module-tab) of the Workbench UDF editor. The UDF can load these functions with an import statement such as: `from utils import your_function`. 

UDFs can also use `fused.load` to import utility modules from other UDFs saved in GitHub or in a user's account.

### `return` object

The return object can be a table or a raster. Fused constrains the output of UDF to a _single_ object. 

Outputs with a spatial component can be rendered on maps. In this case Fused expects the CRS of spatial outputs to be `EPSG:4326` - `WGS84` and will otherwise attempt to convert it.

#### Table

Fused accepts the following table return types: `pd.DataFrame`, `pd.Series`, `gpd.GeoDataFrame`,  `gpd.GeoSeries`, and `shapely geometry`. If the table contains a column with a geometry data, it can be rendered on a map.

#### Raster

Fused accepts the following Raster return types: `numpy.ndarray`, `xarray.DataArray`, and `io.BytesIO`.

Rasters with a spatial component can be rendered on a map. Some raster object like `xarray.DataArray` already have spatial metadata. Objects without spatial metadata, like `numpy.ndarray`, can be returned alongside spatial *bounds* specified with a geometry object or an array with the structure `[xmin, ymin, xmax, ymax]`. For example: 

```python
return np.array([[…], […]]), [xmin, ymin, xmax, ymax]
```
If the bounds are not present, they default to `(-180, -90, 180, 90)`. 

## Saving UDFs

### UDF anatomy

UDFs downloaded from Workbench or saved locally are formatted as a directory of associated files containing the UDF's code, utility modules, and metadata, and `README.md`. 

```
└── Sample_UDF
    ├── README.MD       # Description and metadata
    ├── Sample_UDF.py   # UDF code
    ├── meta.json       # Fused metadata
    └── utils.py        # Utility module
```

### Methods

When writing a UDF in a Python environment outside of Workbench, you can use the following methods to save UDFs. You can save UDF to a local filesystem with the `my_udf.to_directory('Sample_UDF')`. Similarly, you can save UDFs to the Fused cloud with `my_new_udf.to_fused()`.

