---
id: write
title:  Write UDFs
tags: [write, "@fused.udf", "@fused.cache", typed parameters, utility functions, return object]
sidebar_position: 1
toc_min_heading_level: 2
toc_max_heading_level: 2
---



import ImageAnatomy from '@site/static/img/udfanatomy.png';

<div style={{textAlign: 'center'}}>
<img src={ImageAnatomy} alt="File" style={{}} />
</div>


 Follow these steps to write a UDF.
- Decorate a function with [`@fused.udf`](/basics/core-concepts/write/#fusedudf-decorator)
- [Declare the function](/basics/core-concepts/write/#function-declaration) logic
- Set [typed parameters](/basics/core-concepts/write/#typed-parameters) to dynamically run based on inputs
- Import [utility modules](/basics/core-concepts/write/#utils-module) and modularize
- [Return](/basics/core-concepts/write/#return-object) a vector table or raster
- [Save](/basics/core-concepts/write/#save-udfs) the UDF

## `@fused.udf` decorator

First decorate a Python function with `@fused.udf` so it runs on the Fused cloud, which provisions and scales compute. 


## Function declaration

Now structure the function's code. Import Python libraries, interact with upstream data sources, and return an object. Import statements go in the function so they come wherever the function runs.

This UDF is called `udf` and returns a `pd.DataFrame` object. 


```python
# highlight-next-line
@fused.udf # <- Fused decorator
# highlight-start
def udf(bbox: fused.types.Bbox = None, name: str = "Fused"): # <- Function declaration
    import pandas as pd

    @fused.cache # <- Cache decorator
    def structure_output(name):
        return pd.DataFrame({'message': [f'Hello {name}!']})
    
    df = structure_output(name)
    return df
# highlight-end
```

The [@fused.cache](/basics/core-concepts/content-management/cache/) decorator persists a function's output across runs so you move faster. 

:::info
Workbench imports the `fused` module automatically. To write UDFs outside of Workbench, install the `fused` package with `pip install fused`.
:::


## Typed parameters

UDFs support [Python function annotations](https://peps.python.org/pep-3107/) to specify argument types. Parameters serialized in HTTP calls resolve to intended types. These ensure arguments resolve to specified types at run time.

```python
@fused.udf
def udf(
    bbox: fused.types.Bbox = None, # <- Typed parameters
    name: str = "Fused"
):
```

### Supported types

Fused supports the native Python types `int`, `float`, `bool`, `list`, `dict`, and `list`. Parameters without a specified type are handled as strings by default.

The geospatial types `fused.types.Bbox`, `fused.types.TileXYZ`, and `fused.types.TileGDF` on the [first parameter](/basics/core-concepts/filetile/#the-bbox-object) tell [Workbench](/workbench/overview/) to run the UDF as a [Map Tile or File](/basics/core-concepts/filetile/).

### `pd.DataFrame` as JSON

Pass tables and geometries as seriarized UDF parameters in HTTPS calls. DataFrames passed as JSON strings show up as a `pd.DataFrame` when typed. GeoJSON strings as a `gpd.GeoDataFrame`. 

```python
@fused.udf
def udf(
    df: pd.DataFrame = None,
    gdf: gpd.GeoDataFrame = None,
):
```

### Reserved parameters

Fused handles reserved parameters in special ways: `x`, `y`, `z`, `bounds`, `lat`, and `lng`. Use them strategically with `fused.run`.

## `utils` Module

Define a UDF's `utils` Module file in the Workbench ["Module" tab](/workbench/map-builder/udf-editor/#module-tab) and import it in the UDF. Use it to modularize code to make it readable, maintainable, and reusable. 


```python
from utils import function
```

### Import utils from other UDFs

UDFs import the `utils` Module from other UDFs with `fused.load` in the [UDFs GitHub repo](https://github.com/fusedio/udfs/tree/main) or [private GitHub repos](/basics/core-concepts/content-management/git/). Here the commit SHA `05ba2ab` pins `utils` to specific commit for version control.


```python
utils = fused.load(
    "https://github.com/fusedio/udfs/tree/05ba2ab/public/common/"
)
```


Modules in the [public UDFs](https://github.com/fusedio/udfs/tree/main) repo are imported from `fused.utils`.

```python
utils = fused.utils.common
```

`utils` Module are imported from other UDFs in a user's account.

```python
utils = fused.load("your@email.com/my_udf").utils
```

## `return` object

UDFs return either a table or an array. 
- Tables can be: `pd.DataFrame`, `pd.Series`, `gpd.GeoDataFrame`,  `gpd.GeoSeries`, and `shapely geometry`. 
- Arrays: `numpy.ndarray`, `xarray.DataArray`, and `io.BytesIO`. 

To return geospatial data see ["Tile" & "File"](/basics/core-concepts/filetile/).

## Save UDFs

UDFs downloaded from Workbench or saved locally are formatted as a `.zip` file containing associated files with the UDFs code, `utils` Module, metadata, and `README.md`. 

```
└── Sample_UDF
    ├── README.MD       # Description and metadata
    ├── Sample_UDF.py   # UDF code
    ├── meta.json       # Fused metadata
    └── utils.py        # `utils` Module
```

When outside of Workbench, save UDF to your local filesystem with `my_udf.to_directory('Sample_UDF')` and to the Fused cloud with `my_udf.to_fused()`.

