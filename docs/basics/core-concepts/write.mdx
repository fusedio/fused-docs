---
id: write
title:  Write UDFs
tags: [write, "@fused.udf", "@fused.cache", typed parameters, utility functions, return object]
sidebar_position: 1
toc_min_heading_level: 2
toc_max_heading_level: 2
---



import ImageAnatomy from '/img/udfanatomy.png';

<div style={{textAlign: 'center'}}>
<img src={ImageAnatomy} alt="File" style={{}} />
</div>


 Keep these key components in mind as you write a UDF.
- Decorate the function with the [`@fused.udf`](/basics/core-concepts/write/#fusedudf-decorator) decorator
- [Declare the function](/basics/core-concepts/write/#function-declaration) and, optionally, cache intermediate outputs with [`@fused.cache`](/basics/core-concepts/write/#fusedcache-decorator)
- Set [typed parameters](/basics/core-concepts/write/#typed-parameters) to dynamically execute code based on arguments
- Import [utility modules](/basics/core-concepts/write/#utils-module) to modularize code
- Set a vector table or raster as a [return object](/basics/core-concepts/#d-return-object)


## `@fused.udf` decorator

First decorate a Python function with `@fused.udf`. This makes the function run on the Fused cloud, which can provision and scale compute. 


## Function declaration

The next step is to structure the function's code. It can import Python libraries, run code to interact with upstream data sources, and return an object. Place import statements inside the function declaration to ensure they are included wherever the function is executed.

To illustrate, this UDF is a function called `udf` that returns a `gpd.GeoDataFrame` object. 


```python
# highlight-next-line
@fused.udf # <- Fused decorator
# highlight-start
def udf(bbox: fused.types.Bbox = None, name: str = "Fused"): # <- Function declaration
    import pandas as pd
    df = pd.DataFrame({'message': [f'Hello {name}!']})
    print(df)
    return df
# highlight-end
```

:::note
To make UDFs run successfully as both ["Tile" & "File"](/basics/core-concepts/call/#file--tile). It's good practice to reserve the first parameter of the function and set it to `None`, as Fused will handle it a special way when the UDF is called as a "Tile". 
:::

## Typed parameters

Fused UDFs support [Python function annotations](https://peps.python.org/pep-3107/), which allow you to specify argument types in the function signature. This is crucial for parameters serialized in HTTP calls to resolve to the intended types. These annotations ensure that each argument is resolved to the specified type to prevent type-related errors. 

### Supported types

Supported native Python types are `int`, `float`, `bool`, `list`, `dict`, and `list`. Any parameters that are not annotated with a specific type are handled as strings by default.

Fused also supports the geospatial types `fused.types.Bbox`, `fused.types.TileXYZ`, and `fused.types.TileGDF`. When one of these types is assigned to the first parameter of the function ([read more](/basics/core-concepts/call/#bbox-object-types)) Fused Workbench will handle the UDF as a "Tile" otherwise as a "File". 

### `pd.DataFrame` as JSON

DataFrames can be passed as JSON strings and have the UDF interpret them as a `pd.DataFrame`. The same applies for GeoJSON strings, which can be passed as a `gpd.GeoDataFrame` type parameter. This is helpful to pass tables and geometries as seriarized UDF parameters in HTTPS calls, so they can directly be used as a typed parameter. 


### Reserved parameters

The following are reserved parameter names: `x`, `y`, `z`, `bounds`, `lat`, and `lng`. `fused.run` will handle them in a special way.

## `utils` Module

When writing UDFs it's important to modularize code to make it readable, maintainable, and reusable. Every UDF has a `utils` Module file which can be edited in the ["Module" tab](/workbench/map-builder/udf-editor/#module-tab) of the Workbench UDF editor. The UDF can load these functions with an import statement such as: 

```python
from utils import function
```

### Import utils from other UDFs

UDFs can also use `fused.load` to import `utils` Module from other UDFs saved in the [UDFs GitHub repo](https://github.com/fusedio/udfs/tree/main) or a private repository (see how to [connect a GitHub account](/basics/core-concepts/content-management/git/)). 


```python
utils = fused.load('https://github.com/fusedio/udfs/tree/05ba2ab/public/common/')
```
Note how the commit SHA `05ba2ab` in the URL ensures that UDF is loaded from a specific commit, providing version control.

Modules in the public UDFs repo can also be imported using `fused.utils.UDF_NAME`, for example:

```python
utils = fused.utils.common
```

`utils` Module can also be imported from other UDFs in a user's account as such:

```python
utils = fused.load("your@email.com/my_udf").utils
```

## `return` object

The return object can be either a table or an array. For table, Fused accepts the following table return types: `pd.DataFrame`, `pd.Series`, `gpd.GeoDataFrame`,  `gpd.GeoSeries`, and `shapely geometry`. For array: `numpy.ndarray`, `xarray.DataArray`, and `io.BytesIO`. For returning geospatial data please see ["Tile" & "File"](/basics/core-concepts/call/#file--tile).

## Saving UDFs

UDFs downloaded from Workbench or saved locally are formatted as a `.zip` file containing associated files with the UDFs code, `utils` Module, metadata, and `README.md`. 

```
└── Sample_UDF
    ├── README.MD       # Description and metadata
    ├── Sample_UDF.py   # UDF code
    ├── meta.json       # Fused metadata
    └── utils.py        # `utils` Module
```

When writing a UDF in a Python environment outside of Workbench, you can use the following methods to save UDFs. You can save UDF to a local filesystem with the `my_udf.to_directory('Sample_UDF')`. Similarly, you can save UDFs to the Fused cloud with `my_udf.to_fused()`.

