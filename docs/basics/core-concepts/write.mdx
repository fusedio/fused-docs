---
id: write
title:  Write UDFs
tags: [write, "@fused.udf", "@fused.cache", typed parameters, utility functions, return object]
sidebar_position: 1
toc_min_heading_level: 2
toc_max_heading_level: 4
---

A UDF is a Python function that can easily be called via an API endpoint. It can easily be version controlled, shared, and reused across your workflows.


## UDF Structure


import ImageAnatomy from '/img/udfanatomy.png';

<div style={{textAlign: 'center'}}>
<img src={ImageAnatomy} alt="File" style={{}} />
</div>


 Keep these key components in mind as you write a UDF.
- Decorate the function with the [`@fused.udf`](/basics/core-concepts/write/#fusedudf-decorator) decorator
- [Declare the function](/basics/core-concepts/write/#function-declaration) and, optionally, cache intermediate outputs with [`@fused.cache`](/basics/core-concepts/write/#fusedcache-decorator)
- Set [typed parameters](/basics/core-concepts/write/#typed-parameters) to dynamically execute code based on arguments
- Import [utility modules](/workbench/map-builder/udf-editor/#module) to modularize code
- Set a vector table or raster as a [Return object](/basics/core-concepts/#d-return-object)


### `@fused.udf` decorator

First decorate a Python function with `@fused.udf`. This makes the function run on the Fused cloud, which can provision and scale compute. 


### Function declaration

The next step is to structure the function's code. It can import Python libraries, run code to interact with upstream data sources, and return an object. Place import statements inside the function declaration to ensure they are included wherever the function is executed.

To illustrate, this UDF is a function called `udf` that returns a `gpd.GeoDataFrame` object. 


```python
# highlight-next-line
@fused.udf # <- Fused decorator
# highlight-start
def udf(bbox: fused.types.Bbox = None, name: str = "Fused"): # <- Function declaration
    import pandas as pd
    df = pd.DataFrame({'message': [f'Hello {name}!']})
    print(df)
    return df
# highlight-end
```

:::note
To make UDFs run successfully as both ["Tile" & "File"](/basics/core-concepts/call/#file--tile). It's good practice to reserve the first parameter of the function and set it to `None`, as Fused will handle it a special way when the UDF is called as a "Tile". 
:::

### Typed parameters

Fused UDFs support [Python function annotations](https://peps.python.org/pep-3107/), which allow you to specify argument types in the function signature. This is crucial for parameters serialized in HTTP calls to resolve to the intended types. These annotations ensure that each argument is resolved to the specified type to prevent type-related errors. 

#### Supported types

Supported native Python types are `int`, `float`, `bool`, `list`, `dict`, and `list`. Any parameters that are not annotated with a specific type are handled as strings by default.

Fused also supports the geospatial types `fused.types.Bbox`, `fused.types.TileXYZ`, and `fused.types.TileGDF`. When one of these types is assigned to the first parameter of the function ([read more](/basics/core-concepts/call/#bbox-object-types)) Fused Workbench will handle the UDF as a "Tile" otherwise as a "File". 






#### `pd.DataFrame` as JSON

DataFrames can be passed as JSON strings and have the UDF interpret them as a `pd.DataFrame`. The same applies for GeoJSON strings, which can be passed as a `gpd.GeoDataFrame` type parameter. This is helpful to pass tables and geometries as seriarized UDF parameters in HTTPS calls, so they can directly be used as a typed parameter. 


#### Reserved parameters

The following are reserved parameter names: `x`, `y`, `z`, `bounds`, `lat`, and `lng`. `fused.run` will handle them in a special way.

### `utils` Module

When writing UDFs it's important to modularize code to make it readable, maintainable, and reusable. 

Every UDF has a `utils` module file which can be edited in the ["Module" tab](/workbench/map-builder/udf-editor/#module-tab) of the Workbench UDF editor. The UDF can load these functions with an import statement such as: `from utils import your_function`. 


### `return` object

Like with a regular Python function, the UDF return statement makes a UDF function exit and hand back the return object to its caller. Fused expects spatial outputs in `EPSG:4326` - `WGS84` CRS. If the returned object has a different CRS Fused will make a best effort to convert it.

#### Vector

Fused accepts the following Vector table return types:

- `gpd.GeoDataFrame`
- `pd.DataFrame`
- `gpd.GeoSeries`
- `pd.Series`
- `shapely geometry`

#### Raster

Fused accepts the following Raster return types:

- `numpy.ndarray`
- `xarray.DataArray`
- `datashader.transfer_functions.Image`
- `io.BytesIO`

The returned raster object must have metadata of its spatial extent on the map, which objects like `xarray.DataArray` contain. For example:

```python
@fused.udf
def udf():
    import rioxarray

    cog_url = f"s3://dataforgood-fb-data/hrsl-cogs/hrsl_general/v1.5/cog_globallat_10_lon_30_general-v1.5.4.tif"

    rds = rioxarray.open_rasterio(
        cog_url,
        masked=True,
        overview_level=4
    )

    # Inspect the output object
    print(type(rds))
    print(rds)

    return rds
```

:::tip

Fused constrains the output of calling UDFs to be a _single_ vector table or raster object.

As a special case, a UDF that returns a raster object without spatial metadata, like a numpy array, must also include the object's *bounds*. These are specified with a `GeoDataFrame` or array with the structure `[xmin, ymin, xmax, ymax]` as a second return object, separated by a coma. For example: 

```python
@fused.udf
def udf(bbox: fused.types.Bbox=None):
    ...
    return np.array([[…], […]]), bbox
```

If the bounds are not present, they default to `(-180, -90, 180, 90)`.
:::


## Saving UDFs

### UDF anatomy

UDFs downloaded from Workbench or saved locally are formatted as a directory of associated files containing the UDF's code, utility modules, and metadata, and `README.md`. 

```
└── Sample_UDF
    ├── README.MD       # Description and metadata
    ├── Sample_UDF.py   # UDF code
    ├── meta.json       # Fused metadata
    └── utils.py        # Utility module
```

### Methods

To save UDF to a local filesystem with the name `Sample_UDF`:

```python
import fused

@fused.udf
def my_udf():
    return "Hello from Fused!"

# Save locally
my_udf.to_directory('Sample_UDF')
```

To save UDFs to the Fused cloud:

```python
# Upload the UDF to the cloud
my_new_udf.to_fused()
```

