---
id: write
title:  Write UDFs
tags: [write, "@fused.udf", "@fused.cache", typed parameters, utility functions, return object]
sidebar_position: 1
toc_min_heading_level: 2
toc_max_heading_level: 4
---


Fused UDFs are **Python functions that run in the cloud**. They are the glue between your data and applications, and you can use them to build powerful workflows and apps to interact with any size dataset. Every UDF is can be shared as a map layer, called as an API endpoint, and deployed in an app. 

## How does it work?

You can write and run UDFs on the Fused [Workbench](/workbench/) browser IDE or in any Python environment using the [Fused Python SDK](/python-sdk/). 

As soon as you save a UDF Fused creates an API endpoint for it and, when an app calls the endpoint, Fused runs the UDF code on a serverless worker pool and returns the function output. Any tool in your stack can call a Fused UDF with a simple HTTP request to process and fetch data, which enables you to easily create reactive applications that integrate across your stack.

You can think of UDFs as building blocks to create workflows and integrations - without the devops or managing infrastructure. They integrate with your most important apps and can call each other (sequentially and in parallel) to assemble into complex workflows.

{/* ![alt text](https://fused-magic.s3.us-west-2.amazonaws.com/docs_assets/ecosystem_diagram.png) */}

## UDF structure

A UDF is just a Python function. Keep these key components in mind as you write a UDF.


import ImageAnatomy from '/img/udfanatomy.png';

<div style={{textAlign: 'center'}}>
<img src={ImageAnatomy} alt="File" style={{}} />
</div>



- Decorate the function with the [`@fused.udf`](/basics/core-concepts/write/#fusedudf-decorator) decorator
- [Declare the function](/basics/core-concepts/write/#function-declaration) and, optionally, cache intermediate outputs with [`@fused.cache`](/basics/core-concepts/write/#fusedcache-decorator)
- Set [typed parameters](/basics/core-concepts/write/#typed-parameters) to dynamically execute code based on arguments
- Import [utility functions](/basics/core-concepts/#c-udf-parameters) to modularize code
- Set a vector table or raster as a [Return object](/basics/core-concepts/#d-return-object)


### `@fused.udf` decorator

The main thing to know is that all you need to create a UDF is to decorate a Python function with `@fused.udf`. This supercharges the function with the ability to run its code in the Fused serverless cloud that automatically provisions and scales compute resources.

```python
# highlight-next-line
@fused.udf # <- Fused decorator
def udf():
    ...
    return gdf 
```

### Function declaration

The next step is to structure the function's business logic. It can import standard Python libraries and utility modules, run code to interact with upstream data sources, and return an object which will be the UDF's output.

To illustrate, this UDF is a function called `udf` that returns a `GeoDataFrame`. 


```python
@fused.udf
# highlight-start
def udf( # <- Function declaration
    bbox: fused.types.Bbox = None,
    table_path: str = "", 
    n: int=10
):
    from utils import table_to_tile

    gdf=table_to_tile(bbox, table=table_path)
    return gdf
# highlight-end
```

:::note
Note that import statements must be placed within the function declaration to ensure they go wherever the function goes.
:::


#### `@fused.cache` decorator

You can cache the output of slow sections of code, such as downloading or processing data, so they only need to run once. Just place slow code inside a helper function decorated with `@fused.cache`, then assign the function call to a variable. The output will persist across runs and enable quick iteration on downstream code without having to wait for the slow code to run each time.

:::tip

On the [Workbench UDF Editor](/workbench/map-builder/udf-editor/), every time you modify a UDF's code, Fused automatically runs the code from top to bottom. This reactive execution model keeps code and outputs consistent, and gives you immediate feedback. However, you likely don't want to wait for slow sections of code to run each time, which is where caching comes in handy.

:::


##### Basic caching

To illustrate, this function accepts an argument and a keywork argument. When the function is called to set `output_1` and `output_2`, Fused caches the output of each call as separate objects. That way, the UDF only runs the function once for each argument combination.

```python
@fused.udf
def udf(bbox):
    import pandas as pd

    @fused.cache
    def sample_function(name, company="Fused"):
        return f"{name}, at {company}, cached this function's output."

    output_1 = sample_function("Sina")
    output_2 = sample_function("Plinio", company="Fused.io")
    return pd.DataFrame([output_1, output_2], columns=["output"])

```

##### Advanced caching

At this point, ony might ask: if UDFs run for each tile in the viewport, how does Fused distinguish the cache for each tile? When working with [Tile-based execution](/basics/core-concepts/call/#tile) you should pass the [`bbox` object](/basics/core-concepts/call/#the-bbox-object) as a parameter to the cached function so each Tile's output is unique.

:::tip

Fused caches the function's output using a unique hash identifier generated based on a combination of the function's code, the value of its parameters, and the reserved `_cache_id` argument (which you may set). 

:::

This example shows how:
- Passing the `bbox` object to the cached function makes the output unique to each tile.
- A custom caching directory can be set with the optional `path` parameter.
- The cache for the function can be reset by running the UDF once with the optional `reset` parameter set to `True`.
- A unique `_cache_id` string identifier can optionally be passed to the function.

```python
@fused.udf
def udf(bbox):
    import pandas as pd
    import numpy as np

    @fused.cache(path='optional_cache_dir', reset=True)
    def sample_function(bbox, name, company="Fused"):
        x,y,z = bbox.iloc[0][['x', 'y', 'z']]
        return f"{name}, at {company}, cached this function's output for the tile {z} {x} {y}."

    seed = np.random.randn()
    output_1 = sample_function(bbox, "Plinio", company="Fused.io", _cache_id=str(seed))
    return pd.DataFrame([output_1], columns=["output"])
```

### Typed parameters

UDFs can optionally accept parameters and dynamically execute code based on those parameters. Applications calling the UDF can pass arguments to the UDF to dynamically change its behavior. When writing a UDF, you can explicitly type the parameters to ensure the UDF receives the correct data type.


#### Explicit Typing

Fused resolves each argument as the types specified in the function signature. The [Typing section](/python-sdk/#typing) discusses supported type and caveats.

For example this function accepts a `bbox` object of `fused.types.Bbox` type, a `table_path` string, and an `n` integer.

```python
@fused.udf

def udf(
    # highlight-start
    bbox: fused.types.Bbox = None, # UDF parameters
    table_path: str = "", 
    n: int = 10
    # highlight-end
):
    from utils import table_to_tile

    gdf=table_to_tile(bbox, table=table_path)
    return gdf
```
:::info
When UDF endpoints are called via HTTP requests argument values are specified with [query parameters](https://www.branch.io/glossary/query-parameters/), which require input parameters to be serializable. As such, Fused needs to know the types to cast them to. Read more about [supported types for UDF parameters](/python-sdk/#typing). 
:::

The `bbox` argument gives the UDF spatial awareness and users can decide its structure, for convenience - which you can read more about [here](/basics/core-concepts/#the-bbox-object).

When its endpoint is called like so, Fused injects a `bbox` parameter corresponding to a Tile with the `1,1,1` index, resolve `table_path` value as a string and the `n` value as an integer.

```bash
curl -XGET "https://app.fused.io/server/v1/realtime-shared/$SHARED_TOKEN/run/tiles/1/1/1?table_path=table.shp&n=4"
```

### Utility functions

When writing a UDF it's important to modularize its code into reusable and composable components. A UDF can import utility modules from their [local context](/basics/core-concepts/advanced/core-modules/#from-local) or from a [GitHub repo using `fused.load`](/basics/core-concepts/advanced/core-modules/#from-github).


```python
@fused.udf
def udf( 
    bbox: fused.types.Bbox = None,
    table_path: str = "", 
    n: int=10
):
    # highlight-start
    from utils import table_to_tile # <- Utility function
    # highlight-end
    gdf=table_to_tile(bbox, table=table_path)
    return gdf
```



### Return object

Like with a regular Python function, the UDF return statement makes a UDF function exit and hand back the return object to its caller. The return object must be a single vector table or raster object.

```python
@fused.udf
def udf():
    ...
    # highlight-start
    return gdf # <- Return object
    # highlight-end
```

:::info

Fused constrains the return object to be a _single_ vector table or raster object because:
- UDF outputs must be serializable so they can be transferred via HTTP calls
- Industry standard mapping services expect to receive a single vector or raster object

:::



#### Vector

Vectors represent real-world features with points, lines, and polygons. Fused accepts the following Vector return types:

- `gpd.GeoDataFrame`
- `pd.DataFrame`
- `gpd.GeoSeries`
- `pd.Series`
- `shapely geometry`

Fused expects all spatial data in `EPSG:4326` - `WGS84` coordinates, using Latitude-Longitude units in decimal degrees. If the CRS of the returned object is not in `EPSG:4326` CRS, Fused will make a best effort to convert it - so it's recommended that UDFs returning vector tables do so in the `EPSG:4326` CRS.

#### Raster

Raster data is comprised of pixels with values, typically arranged in a grid. Rasters can have one or multiple layers.

Fused accepts the following Raster return types

- `numpy.ndarray`
- `xarray.DataArray`
- `datashader.transfer_functions.Image`
- `io.BytesIO` (including png images)

The returned raster object must have a geospatial component. This tells Fused where on the map to render it as an image. For example, this UDF returns an `xarray` `DataArray`, which inherently contains coordinates that tell Fused where on the map to place it. Verify this by printing the object and its type.

```python
import fused
@fused.udf
def udf(lat=-10, lng=30, dataset='general', version='1.5.4'):
    import rioxarray

    lat2= int(lat//10)*10
    lng2 = int(lng//10)*10
    cog_url = f"s3://dataforgood-fb-data/hrsl-cogs/hrsl_{dataset}/v1.5/cog_globallat_{lat2}_lon_{lng2}_{dataset}-v{version}.tif"

    rds = rioxarray.open_rasterio(
        cog_url,
        masked=True,
        overview_level=4
    )
 
    # Show the output type
    print(type(rds))

    # Inspect the output object
    print(rds)

    return rds
```

:::tip
When returning a raster object that doesn’t have spatial metadata, like a numpy array, the UDF must return the object's *bounds* to tell Fused where to place it on the map. For example: 

```python
@fused.udf
def udf(bbox: fused.types.Bbox=None):
    ...
    return np.array([[…], […]]), bbox
```

If you forget to pass the bounds, Fused will default its bounds to `(-180, -90, 180, 90)` and the output image will expand to the size of the globe.
:::

The print statements of the UDF above should display the following in the `stdout` box, which shows the layer value and coordinates of the `DataArray` object.

```text
<class 'xarray.core.dataarray.DataArray'>
<xarray.DataArray (band: 1, y: 1126, x: 1126)>
[1267876 values with dtype=float64]
Coordinates:
  * band         (band) int64 1
  * x            (x) float64 30.0 30.01 30.02 30.03 ... 39.97 39.98 39.99 40.0
  * y            (y) float64 -0.0001389 -0.009028 -0.01792 ... -9.991 -10.0
    spatial_ref  int64 0
Attributes:
    AREA_OR_POINT:  Area
    scale_factor:   1.0
    add_offset:     0.0
```

:::tip
💡 There's 2 recommended ways to control the transparency of raster images.

  1. In RGB images, the color black (0,0,0) is automatically set to full transparency.
  2. If a 4 channel array is passed, i.e. RGBA, the value of the 4th channel is the transparency.
:::

