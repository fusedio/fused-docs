---
id: write
title:  Write UDFs
tags: [write, "@fused.udf", "@fused.cache", typed parameters, utility functions, return object]
sidebar_position: 1
toc_min_heading_level: 2
toc_max_heading_level: 4
---



import ImageAnatomy from '/img/udfanatomy.png';

<div style={{textAlign: 'center'}}>
<img src={ImageAnatomy} alt="File" style={{}} />
</div>


 Keep these key components in mind as you write a UDF.
- Decorate the function with the [`@fused.udf`](/basics/core-concepts/write/#fusedudf-decorator) decorator
- [Declare the function](/basics/core-concepts/write/#function-declaration) and, optionally, cache intermediate outputs with [`@fused.cache`](/basics/core-concepts/write/#fusedcache-decorator)
- Set [typed parameters](/basics/core-concepts/write/#typed-parameters) to dynamically execute code based on arguments
- Import [utility modules](/workbench/map-builder/udf-editor/#module) to modularize code
- Set a vector table or raster as a [Return object](/basics/core-concepts/#d-return-object)


### `@fused.udf` decorator

First decorate a Python function with `@fused.udf`. This makes the function run on the Fused cloud, which can provision and scale compute. 


### Function declaration

The next step is to structure the function's code. It can import Python libraries, run code to interact with upstream data sources, and return an object. Place import statements inside the function declaration to ensure they are included wherever the function is executed.

To illustrate, this UDF is a function called `udf` that returns a `gpd.GeoDataFrame` object. 


```python
# highlight-next-line
@fused.udf # <- Fused decorator
# highlight-start
def udf(bbox: fused.types.Bbox = None, name: str = "Fused"): # <- Function declaration
    import pandas as pd
    df = pd.DataFrame({'message': [f'Hello {name}!']})
    print(df)
    return df
# highlight-end
```

:::note
To make UDFs run successfully as both ["Tile" & "File"](/basics/core-concepts/call/#file--tile). It's good practice to reserve the first parameter of the function and set it to `None`, as Fused will handle it a special way when the UDF is called as a "Tile". 
:::

### Typed parameters

Fused UDFs support [Python function annotations](https://peps.python.org/pep-3107/), which allow you to specify argument types in the function signature. This is crucial for parameters serialized in HTTP calls to resolve to the intended types. These annotations ensure that each argument is resolved to the specified type to prevent type-related errors. 

#### Supported types

Supported native Python types are `int`, `float`, `bool`, `list`, `dict`, and `list`. Any parameters that are not annotated with a specific type are handled as strings by default.

Fused also supports the geospatial types `fused.types.Bbox`, `fused.types.TileXYZ`, and `fused.types.TileGDF`. When one of these types is assigned to the first parameter of the function ([read more](/basics/core-concepts/call/#bbox-object-types)) Fused Workbench will handle the UDF as a "Tile" otherwise as a "File". 






#### `pd.DataFrame` as JSON

DataFrames can be passed as JSON strings and have the UDF interpret them as a `pd.DataFrame`. The same applies for GeoJSON strings, which can be passed as a `gpd.GeoDataFrame` type parameter. This is helpful to pass tables and geometries as seriarized UDF parameters in HTTPS calls, so they can directly be used as a typed parameter. 


#### Reserved parameters

The following are reserved parameter names: `x`, `y`, `z`, `bounds`, `lat`, and `lng`. `fused.run` will handle them in a special way.

### `utils` Module

When writing UDFs it's important to modularize code to make it readable, maintainable, and reusable. 

Every UDF has a `utils` module file which can be edited in the ["Module" tab](/workbench/map-builder/udf-editor/#module-tab) of the Workbench UDF editor. The UDF can load these functions with an import statement such as: `from utils import your_function`. 


### `return` object

The return object can be a table or a raster. Tables with a geospatial geometry column can be rendered as a map layer.

#### Vector

Fused accepts the following Vector table return types: `gpd.GeoDataFrame`, `pd.DataFrame`, `gpd.GeoSeries`, `pd.Series`, and `shapely geometry`.

#### Raster

Fused accepts the following Raster return types: `numpy.ndarray`, `xarray.DataArray`, `io.BytesIO`

The returned raster object must have metadata of its spatial extent on the map, which objects like `xarray.DataArray` contain. For example:




Fused constrains the output of calling UDFs to be a _single_ table or raster object. Outputs with a spatial component can be rendered on maps. In this case Fused expects spatial outputs in `EPSG:4326` - `WGS84` CRS and will otherwise attempt to convert the CRS.

Vector tables already have a geospatial metadata to place the output on a map. Raster objects must have spatial metadata to be displayed on a map. 

As a special case, a UDF called as File that returns a raster object without spatial metadata, like a numpy array, must also include the object's *bounds*. These are specified with a `GeoDataFrame` or array with the structure `[xmin, ymin, xmax, ymax]` as a second return object. If the bounds are not present, they default to `(-180, -90, 180, 90)`. For example: 

```python
return np.array([[…], […]]), [xmin, ymin, xmax, ymax]
```





## Saving UDFs

### UDF anatomy

UDFs downloaded from Workbench or saved locally are formatted as a directory of associated files containing the UDF's code, utility modules, and metadata, and `README.md`. 

```
└── Sample_UDF
    ├── README.MD       # Description and metadata
    ├── Sample_UDF.py   # UDF code
    ├── meta.json       # Fused metadata
    └── utils.py        # Utility module
```

### Methods

When writing a UDF in a Python environment outside of Workbench, you can use the following methods to save UDFs. You can save UDF to a local filesystem with the `my_udf.to_directory('Sample_UDF')`. Similarly, you can save UDFs to the Fused cloud with `my_new_udf.to_fused()`.

