---
id: cache
title: Cache decorator
tags: [cache]
sidebar_position: 5
---

import Tag from '@site/src/components/Tag'

## <Tag color="#D1E550" fontColor="#141414" >ðŸš§ Under Construction</Tag>


Caching stores the result of slow function calls so they only need to run once. This makes UDFs much faster and helps persist objects across reruns.

### Basic

To cache a function that returns serializable data (e.g. `DataFrame`, `np.array`, `str`) decorate it with `@fused.cache`.



```python
@fused.udf
def udf():
    import pandas as pd

    @fused.cache
    def load_data(i):
        return pd.DataFrame({'id': i})

    first = load_data(i=1)
    second = load_data(i=2)
    return pd.concat([first, second])
```

The first time Fused sees the function code and parameters, Fused runs the function and stores the return value in a cache. The next time the function is called with the same parameters and code, Fused will skip running the function and return the cached value. The cache updates automatically as function code changes so the latest changes are always reflected in the cache.
### Advanced


This advanced example shows how you can:
- Pass [`bbox`](/core-concepts/filetile/#the-bbox-object) to make the output unique to each [Tile](/core-concepts/filetile/#tile)
- Set a custom cache directory with the optional `path` parameter
- Run the UDF once with `reset` set to `True` to reset the cache

```python
@fused.udf
def udf(bbox: fused.types.TileGDF=None):

    @fused.cache(path='optional_cache_dir', reset=True)
    def set_name(bbox, name):
        bbox['name'] = name
        return bbox

    return set_name(bbox, "San Francisco")
```
