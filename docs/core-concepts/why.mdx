---
id: why
title:  Why UDFs
tags: [write, why]
sidebar_position: 0
---

{/* Fused is a data analytics platform to write and deploy Python User Defined Functions (UDFs) behind HTTP endpoints and interactive applications.

- [Read files](/workbench/file-explorer/) in cloud storage with UDFs
- [Write](/core-concepts/write/) and share UDFs with ease
- [Run UDFs](/core-concepts/run/) from anywhere with simple [HTTP calls](/core-concepts/run/#http-requests)
- Scale and [parallelize](/core-concepts/async) without managing infrastructure
- [Create apps](/workbench/app-builder/) that run UDFs */}

Fused is build around User Defined Functions (UDFs) which Python functions that can be called from anywhere using HTTP requests.

## A simple demo

To explain in depth how UDfs work, let's start with a simple example:

```python showLineNumber
@fused.udf
def udf():
    import geopandas as gpd
    from shapely.geometry import Point
    
    return gpd.GeoDataFrame(
        {"poi": ["top_of_Eiffel_Tower"]}, 
        geometry=[Point(2.2945008587019395, 48.85833092066099)]
    )
```

This UDF returns a `GeoDataFrame` object with a single point, the coordinates of the top of the Eiffel Tower:

import ImgEiffelTower from '@site/static/img/udfs/why_udf_eiffel_tower_point.png';

<div style={{textAlign: 'center'}}>
<img src={ImgEiffelTower} alt="File" style={{width: 300}} />
</div>

Let's break it down:

import ImgFusedUdf from '@site/static/img/udfs/why_udfs_fused_udf_breakdown.png';

<div style={{textAlign: 'center'}}>
<img src={ImgFusedUdf} alt="File" style={{width: 700}} />
</div>

1. A `@fused.udf` decorator
2. imports _inside_ our UDF
3. Logic & `return`

These are the 3 basic building blocks of any UDF. 
(More details on exactly what each piece does in the next section: [Write UDFs](/core-concepts/write/)).

The power of UDFs comes in the ability to _call_ them. They are Python functions, but that can be called from anywhere.
By adding `@fused.udf` we're turning this piece of code into a file, in this case a `GeoDataFrame` with 1 point inside it.

We'll touch on the exact mechanics for how to share this UDF, but for now we can call it using with a HTTP request:

```
https://www.fused.io/server/v1/realtime-shared/my_eiffel_tower_udf/run/file?dtype_out_raster=geojson
```

import ImgHTTPUdf from '@site/static/img/udfs/why_udfs_calling_udf_http.png';

<div style={{textAlign: 'center'}}>
<img src={ImgHTTPUdf} alt="File" style={{width: 700}} />
</div>

{/* TODO: Make a public UDF with this, so people can try it themselves */}

This is the one of the powerful aspects of Fused: **You can write a Python UDF and interact with it as if it were a file on the receiving end!**

This concept is key to understanding what is possible with UDFs. This is why UDFs have a few key concepts:
- **`import` inside the UDF** -> Since UDFs are executable pieces of code, dependencies need to be within the code. That's why we need to have imports _inside_ functions, rather than at the top of `.py` file as you might be used to
- **UDFs can only `return` a few set of Python objects** -> UDFs only return **vector** (dataframes) or **raster** (images) files. (more about this [in this section](/core-concepts/write/#return-object))


## The problem we want to solve

Fused UDFs directly address the problems of productionizing data science and analytical workflows, including:

- Difficulty sharing and reproducing Notebooks
- Slow iteration cycles in development
- Limited discoverability of data within an organization
- Challenging reusability of code snippets across projects
- Friction transpiling code to production
- Managing workflow infrastructure
- Inefficient data delivery to applications
- Slow performance of analytical apps

Fused UDFs address these issues by standardizing how Python code is written, shared, and run.

## What is a UDF?

UDFs are Python functions that can be called from anywhere to apply a specific operation to data. For every UDF, Fused creates an endpoint that can be called to run the function code and return its output. This makes Fused easy to integrate with data applications and deliver dynamically generated data on demand.

import ImageDiagram from '@site/static/img/product_diagram.png';

<div style={{textAlign: 'center'}}>
<img src={ImageDiagram} alt="File" style={{}} />
</div>

You can think of UDFs as versatile building blocks to load and transform data across a range of use cases, including geospatial. They can act, for example, as virtual datasets, file readers, and workflow tasks.

## Virtual Datasets

{/* TODO: This should be moved into a "Examples of applications to use UDFs in" */}

UDFs can be used as virtual datasets, similar to database views, to deliver data behind an HTTP endpoint. They can return data in formats defined at call time based on the needs of the client application, such as tiffs, Parquet, GeoJSON, and others. This eliminates the need to pre-process or transfer datasets ahead of time.

{/* todo: materialize, caching */}

## File Readers

{/* TODO: Should also be moved inside "Examples of applications to use UDFs in" */}
{/* TODO: Need to demonstrate this section, I (Max) didn't understand this until Sina explained it to me, but it's a very handy aspect of UDFs*/}
{/* TODO: We could also mention UDF catalog here: I.e. you don't need yet another STAC reader, you can use what someone's already build. Gabe's apps would be a good starting point */}

UDFs can also be used to open files of various formats, like Parquet, CSV, and GeoJSON. This provides a standard interface to easily explore files in cloud object storage and eliminates the need to move, copy, or transform entire datasets.

## Workflow Tasks
{/* TODO: We should either point to an existing example or demo how this could be used, this is probably the most generic use case of UDFs here */}

UDFs can serve as reusable tasks in analysis pipelines that easily integrate with 3rd party applications to load, process, and write data. Multiple UDFs can be chained and called in parallel to create complex workflows that run and return data on demand via HTTP requests.