---
id: write
title:  Write UDFs
tags: [write, "@fused.udf", "@fused.cache", typed parameters, utility functions, return object]
sidebar_position: 1
toc_min_heading_level: 2
toc_max_heading_level: 2
---



import ImageAnatomy from '@site/static/img/udfanatomy.png';

<div style={{textAlign: 'center'}}>
<img src={ImageAnatomy} alt="File" style={{}} />
</div>


 Follow these steps to write a [User Defined Function (UDF)](/core-concepts/why/).
- Decorate a function with [`@fused.udf`](/core-concepts/write/#fusedudf-decorator)
- [Declare the function](/core-concepts/write/#function-declaration) logic
- Set [typed parameters](/core-concepts/write/#typed-parameters) to dynamically run based on inputs
- Import [utility modules](/core-concepts/write/#utils-module) to keep your code organized
- [Return](/core-concepts/write/#return-object) a vector table or raster
- [Save](/core-concepts/write/#save-udfs) the UDF

## `@fused.udf` decorator

First decorate a Python function with `@fused.udf` so it runs on the Fused cloud, which provisions and scales compute.


## Function declaration

Now structure the function's code. Import Python libraries, interact with upstream data sources, and return an object. Import statements go in the function so they come wherever the function runs.

This UDF is called `udf` and returns a `pd.DataFrame` object.


```python showLineNumbers
# highlight-next-line
@fused.udf # <- Fused decorator
# highlight-start
def udf(bbox: fused.types.Bbox = None, name: str = "Fused"): # <- Function declaration
    import pandas as pd

    @fused.cache # <- Cache decorator
    def structure_output(name):
        return pd.DataFrame({'message': [f'Hello {name}!']})

    df = structure_output(name)
    return df
# highlight-end
```

The [@fused.cache](/core-concepts/content-management/cache/) decorator persists a function's output across runs so you move faster.

:::info
Workbench imports the `fused` module automatically. To write UDFs outside of Workbench, install the `fused` package with `pip install fused`.
:::


## Typed parameters

UDFs support [Python function annotations](https://peps.python.org/pep-3107/) to specify argument types. Parameters serialized in HTTP calls resolve to intended types. These ensure arguments resolve to specified types at run time.

```python showLineNumbers
@fused.udf
def udf(
    bbox: fused.types.Bbox = None, # <- Typed parameters
    name: str = "Fused"
):
```

:::tip

To write UDFs that can be called as either [`File` or `Tile`](/core-concepts/filetile/), Fused recommends setting `bbox` as the first parameter, defaulted to `None`. This enables the UDF to be invoked successfully both as `File` (when `bbox` isn’t passed) and as `Tile`. For example:

```python showLineNumbers
@fused.udf
def udf(bbox: fused.types.Bbox=None):
    ...
    return ...
```

UDFs called with [`fused.run`](/core-concepts/run/#fusedrun) run as Tile only if a parameter specifies the `Tile` geometry.
:::


### Supported types

Fused supports the native Python types `int`, `float`, `bool`, `list`, `dict`, and `list`. Parameters without a specified type are handled as strings by default.

The geospatial types `fused.types.Bbox`, `fused.types.TileXYZ`, and `fused.types.TileGDF` on the [first parameter](/core-concepts/filetile/#the-bbox-object) tell [Workbench](/workbench/overview/) to run the UDF as a [Map Tile or File](/core-concepts/filetile/).

### `pd.DataFrame` as JSON

Pass tables and geometries as seriarized UDF parameters in HTTPS calls. DataFrames passed as JSON strings show up as a `pd.DataFrame` when typed. GeoJSON strings as a `gpd.GeoDataFrame`.

```python showLineNumbers
@fused.udf
def udf(
    df: pd.DataFrame = None,
    gdf: gpd.GeoDataFrame = None,
):
```

### Reserved parameters

Fused handles reserved parameters in special ways: `x`, `y`, `z`, `bounds`, `lat`, and `lng`. Use them strategically with `fused.run`.

## `utils` Module

Define a UDF's `utils` Module file in the Workbench ["Module" tab](/workbench/udf-builder/udf-editor/#module-tab) and import it in the UDF. Use it to modularize code to make it readable, maintainable, and reusable.


```python showLineNumbers
from utils import function
```

### Import utils from other UDFs

UDFs import the `utils` Module from other UDFs with `fused.load` in the [UDFs GitHub repo](https://github.com/fusedio/udfs/tree/main) or [private GitHub repos](/core-concepts/content-management/git/). Here the commit SHA `05ba2ab` pins `utils` to specific commit for version control.


```python showLineNumbers
utils = fused.load(
    "https://github.com/fusedio/udfs/tree/05ba2ab/public/common/"
)
```


Modules in the [public UDFs](https://github.com/fusedio/udfs/tree/main) repo are imported from `fused.utils`.

```python showLineNumbers
utils = fused.utils.common
```

`utils` Module are imported from other UDFs in a user's account.

```python showLineNumbers
utils = fused.load("your@email.com/my_udf").utils
```

## `return` object

UDFs return either a table or an array.
- Tables can be: `pd.DataFrame`, `pd.Series`, `gpd.GeoDataFrame`,  `gpd.GeoSeries`, and `shapely geometry`.
- Arrays can be: `numpy.ndarray`, `xarray.DataArray`, and `io.BytesIO`. Fused Workbench only supports rendering of `uint8` arrays.

To return geospatial data see ["Tile" & "File"](/core-concepts/filetile/).

## Save UDFs

UDFs exported from the [UDF Builder](/workbench/udf-builder/overview/) or saved locally are formatted as a `.zip` file containing associated files with the UDFs code, `utils` Module, metadata, and `README.md`.

```
└── Sample_UDF
    ├── README.MD       # Description and metadata
    ├── Sample_UDF.py   # UDF code
    ├── meta.json       # Fused metadata
    └── utils.py        # `utils` Module
```

When outside of Workbench, save UDF to your local filesystem with `my_udf.to_directory('Sample_UDF')` and to the Fused cloud with `my_udf.to_fused()`.

## Debug UDFs

#### UDF builder

A common approach to debug UDFs is to show intermediate results in the [UDF Builder](/workbench/udf-builder) [results panel](/workbench/udf-builder/results/) using `print` statements.

#### HTTP requests

When using HTTP requests, any error messages are included in the `x-fused-metadata` header of the response. hese messages can be used to debug. To inspect the header on a browser, open the [Developer Tools](https://developer.chrome.com/docs/devtools/network) network tab.
