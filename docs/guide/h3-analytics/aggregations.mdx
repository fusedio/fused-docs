---
id: aggregations
title: Aggregations
sidebar_label: Aggregations
sidebar_position: 5
---

# Aggregate

After ingesting a dataset to [H3 hexagons](/guide/h3-analytics/raster-to-h3) (or [vector to H3](/guide/h3-analytics/vector-to-h3)) it's possible to [visualize it in Fused](/guide/h3-analytics/visualization) but we can also directly work with the data.

This page shows how to aggregate data at different resolutions or create derivative layers.

![Aggregating H3 Data](/img/tutorials/geospatial/h3/aggregate_h3.png)

Example aggregating elevation data across the US at different H3 resolutions:

```python showLineNumbers
@fused.udf
def udf(
    bounds: fused.types.Bounds = [-74.556, 40.400, -73.374, 41.029],  # Default to full NYC
):
    path = "s3://fused-asset/hex/copernicus-dem-90m/"
    hex_reader = fused.load("https://github.com/fusedio/udfs/tree/8024b5c/community/joris/Read_H3_dataset/")

    df = hex_reader.read_h3_dataset(path, bounds, res=None) # res=None lets the hex_reader determine the resolution based on the current bounds

    return df
```

:::info Using existing ingested H3 reader

You can already use the [h3_reader.read_h3_dataset](https://github.com/fusedio/udfs/tree/dd40354/community/joris/Read_H3_dataset/) and specify:
- `res` at a specific resolution
- `value` to filter on a specific value (especially for [categorical data](#categorical-data))

This reader uses DuckDB under the hood to read the data meaning you can write additional queries _after_ reading the data as shown in creating [derivative layers](#derivative-layers).

:::

## Aggregate at lower resolutions

H3 hexagons allow for aggregation at different resolutions. The ingestion process already creates overviews at different H3 resolutions - see [Resolution Guide](/guide/h3-analytics/resolution-guide) for details. 

### Numerical data

Example numerical values:
- Temperature
- Elevation
- Income
- Population

Aggregating means:
- Summing values (i.e. how many people live in a H3 cell in total)
- Taking mean / max / min / stddev (i.e. what is the average temperature in a H3 cell)

Example: Aggregating elevation across the US at different H3 levels

```python showLineNumbers {4,11}
@fused.udf
def udf(
    bounds: fused.types.Bounds = [-74.556, 40.400, -73.374, 41.029],  # Default to full NYC
    res: int = 4, # Default to H3 resolution 4
):
    path = "s3://fused-asset/hex/copernicus-dem-90m/"
    hex_reader = fused.load("https://github.com/fusedio/udfs/tree/dd40354/community/joris/Read_H3_dataset/")
    df = hex_reader.read_h3_dataset(
        path, 
        bounds, 
        res=res
    )
    return df
```

### Categorical data

Example categorical data:
- Land Use
- Crop Type
- Zone

Aggregating means:
- Counting values (i.e. how many different crop types are there in a H3 cell)
- Taking mode (i.e. what is the most common crop type in a H3 cell)

Example: Aggregating Corn yields across the US at different H3 levels

import LazyReactPlayer from '@site/src/components/LazyReactPlayer'

<LazyReactPlayer 
    url="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/docs_rewrite/tutorials/geospatial/h3_aggregate_different_res_compressed.mp4"
    playing={true}
    muted={true}
    loop={true}
    controls={true}
    width="100%"
    height="auto"
    style={{
        maxWidth: "800px",
        margin: "0 auto 2rem auto",
        display: "block",
        aspectRatio: "16/9"
    }}
/>

<details>
<summary>Expand for code</summary>

```python showLineNumbers
@fused.udf
def udf(
    bounds: fused.types.Bounds = [-127.54220803198237,10.667151173068717,-66.93703570835524,55.22298640160706],
    res: int = None,  # if left to None, hex_reader will determine resolution itself
    data_value: int = 1,  # 1=Corn in CDL for this example
    year: int = 2024,
):
    import h3.api.basic_int as h3
    path = f"s3://fused-asset/hex/cdls_v8/year={year}/"

    common = fused.load("https://github.com/fusedio/udfs/tree/6dd2c4e/public/common/")
    hex_reader = fused.load("https://github.com/fusedio/udfs/tree/f2b3909/community/joris/Read_H3_dataset/")

    # Read all hexagons where the CDL value matches the requested data class (e.g. Corn)
    df = hex_reader.read_h3_dataset(path, bounds, res=res, value=data_value)
    print(df.T)
    
    if 'pct' not in df.columns:
        # Dynamically compute the % of each hex covered by the specified crop type
        data_res = h3.get_resolution(df["hex"].iloc[0])
        print(f"{data_res=}")

        con = common.duckdb_connect()
        df = con.query(f"""
            SELECT 
                hex,
                SUM(area) as total_area,
                ANY_VALUE(data) as data,
                h3_get_hexagon_area_avg({data_res}, 'm^2') as hex_area,
                (SUM(area) / h3_get_hexagon_area_avg({data_res}, 'm^2')) * 100 as pct
            FROM df 
            WHERE data == {data_value}
            GROUP BY hex
        """).to_df()

    print(df.shape)
    if df.shape[0] > 0:
        return df
    else:
        return None
```

</details>

## Derivative layers 

You can also create derivative layers by writing custom logic after reading data using the [h3_reader.read_h3_dataset](https://github.com/fusedio/udfs/tree/dd40354/community/joris/Read_H3_dataset/)

Example: Slope from elevation — Read elevation H3 data, register in DuckDB, then use `h3_grid_ring` and neighbor elevation to compute slope per hex. For the full UDF and explanation, see [Reading and querying H3 — Example: Slope from elevation](/guide/h3-analytics/reading-querying#example-slope-from-elevation).