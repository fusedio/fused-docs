---
title: H3 Aggregation
sidebar_label: Aggregation
sidebar_position: 4
description: Learn how to aggregate point and polygon data using H3 hexagons
keywords: [h3 aggregation, h3 sum, h3 mean, h3 count, aggregate h3, hexagon aggregation]
---

import LazyReactPlayer from '@site/src/components/LazyReactPlayer'

# H3 Aggregation

After converting data to H3 hexagons, you can aggregate values at different resolutions or create derivative layers.

![Aggregating H3 Data](/img/tutorials/geospatial/h3/aggregate_h3.png)

## Basic Aggregation

Read H3 data and let the reader automatically choose resolution based on viewport:

```python
@fused.udf
def udf(bounds: fused.types.Bounds = None):
    path = "s3://fused-asset/hex/copernicus-dem-90m/"
    hex_reader = fused.load("https://github.com/fusedio/udfs/tree/main/community/joris/Read_H3_dataset/")

    # res=None lets the reader choose based on bounds
    df = hex_reader.read_h3_dataset(path, bounds, res=None)
    return df
```

## Aggregate at Different Resolutions

H3's hierarchical structure allows easy aggregation between resolutions.

### Numerical Data

For continuous values (temperature, elevation, income):

```python
@fused.udf
def udf(bounds: fused.types.Bounds = None, res: int = 4):
    path = "s3://fused-asset/hex/copernicus-dem-90m/"
    hex_reader = fused.load("https://github.com/fusedio/udfs/tree/main/community/joris/Read_H3_dataset/")
    
    df = hex_reader.read_h3_dataset(path, bounds, res=res)
    return df
```

### Categorical Data

For discrete values (land use, crop type, zones):

<LazyReactPlayer 
    url="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/docs_rewrite/tutorials/geospatial/h3_aggregate_different_res_compressed.mp4"
    playing={true}
    muted={true}
    loop={true}
    controls={true}
    width="100%"
    height="auto"
    style={{
        maxWidth: "800px",
        margin: "0 auto 2rem auto",
        display: "block",
        aspectRatio: "16/9"
    }}
/>

<details>
<summary>Code: Crop type aggregation</summary>

```python
@fused.udf
def udf(
    bounds: fused.types.Bounds = None,
    res: int = None,
    data_value: int = 1,  # 1=Corn in CDL
    year: int = 2024,
):
    import h3.api.basic_int as h3
    path = f"s3://fused-asset/hex/cdls_v8/year={year}/"

    common = fused.load("https://github.com/fusedio/udfs/tree/main/public/common/")
    hex_reader = fused.load("https://github.com/fusedio/udfs/tree/main/community/joris/Read_H3_dataset/")

    df = hex_reader.read_h3_dataset(path, bounds, res=res, value=data_value)
    
    if 'pct' not in df.columns:
        data_res = h3.get_resolution(df["hex"].iloc[0])
        con = common.duckdb_connect()
        df = con.query(f"""
            SELECT 
                hex,
                SUM(area) as total_area,
                ANY_VALUE(data) as data,
                (SUM(area) / h3_get_hexagon_area_avg({data_res}, 'm^2')) * 100 as pct
            FROM df 
            WHERE data == {data_value}
            GROUP BY hex
        """).to_df()

    return df
```

</details>

## Derivative Layers

Create derived metrics from H3 data using DuckDB:

<LazyReactPlayer 
    url="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/docs_rewrite/tutorials/geospatial/elevation_to_slope_compressed.mp4"
    playing={true}
    muted={true}
    loop={true}
    controls={true}
    width="100%"
    height="auto"
    style={{
        maxWidth: "800px",
        margin: "0 auto 2rem auto",
        display: "block",
        aspectRatio: "16/9"
    }}
/>

<details>
<summary>Code: Calculate slope from elevation</summary>

```python
@fused.udf
def udf(bounds: fused.types.Bounds = None):
    path = "s3://fused-asset/hex/copernicus-dem-90m/"
    
    hex_reader = fused.load("https://github.com/fusedio/udfs/tree/main/community/joris/Read_H3_dataset/")
    df = hex_reader.read_h3_dataset(path, bounds, res=None)

    common = fused.load("https://github.com/fusedio/udfs/tree/main/public/common/")
    con = common.duckdb_connect()
    
    qr = """
    WITH hex_neighbors AS (
        SELECT hex, data_avg AS elevation,
               UNNEST(h3_grid_ring(hex, 1)) AS neighbor_hex
        FROM df
    ),
    neighbor_data AS (
        SELECT n.hex, n.elevation, n.neighbor_hex,
               df2.data_avg AS neighbor_elevation,
               h3_get_hexagon_edge_length_avg(h3_get_resolution(n.hex), 'm') AS edge_m
        FROM hex_neighbors n
        JOIN df df2 ON n.neighbor_hex = df2.hex
    ),
    slope_calc AS (
        SELECT hex, elevation,
               AVG(DEGREES(ATAN(ABS(elevation - neighbor_elevation) / edge_m))) * 100 AS avg_slope
        FROM neighbor_data
        GROUP BY hex, elevation
    )
    SELECT hex, ROUND(elevation, 2) AS elevation, ROUND(avg_slope, 2) AS avg_slope
    FROM slope_calc
    """
    return con.execute(qr).df()
```

</details>

## Next Steps

- [Joining H3 Datasets](/tutorials/Geospatial%20with%20Fused/h3-tiling/analysis-with-h3/joining-h3-datasets) - Combine multiple datasets
- [H3 Zonal Statistics](/tutorials/Geospatial%20with%20Fused/h3-tiling/analysis-with-h3/h3-zonal-stats) - Compute stats over regions

> ðŸ“š **Reference:** See [H3 Operations Reference](/reference/h3/operations) for quick snippets.

