---
id: realtime
title: Realtime
sidebar_label: Realtime
sidebar_position: 1
---


Realtime is the default way to run UDFs. You can run them in 2 main ways:
1. [`fused.run()`](/python-sdk/top-level-functions/#fusedrun) in Python
2. [**HTTPS call**](/guide/data-input-outputs/export-api/tokens-endpoints) from anywhere

## Realtime limits

Realtime UDF runs are:
- Less than **120s** to execute
- Less than **~4GB** of RAM

These run with no start-up time, so are quick to run, but with limited resources. Need more? See [Batch Jobs](/guide/working-with-udfs/execution/batch-jobs).

## `fused.run()`

[`fused.run()`](/python-sdk/top-level-functions/#fusedrun) is the simplest way to call another UDF

```python showLineNumbers
fused.run("my_udf")
```

![Calling another UDF in workbench](/img/core-concepts/execution/fused_run_simple_demo.png)

### Ways to reference a UDF

| Method | Syntax | When to use |
|--------|--------|-------------|
| Your UDF | `fused.run("my_udf")` | UDFs you created (requires auth) |
| Teammate's UDF | `fused.run("teammate@fused.io/my_udf")` | UDFs from your team |
| Team UDF | `fused.run("team/my_udf")` | Shared team UDFs |
| Public UDF | `fused.run("UDF_Name")` | [Public UDFs](https://github.com/fusedio/udfs/tree/main) (free) |
| [Token](/guide/data-input-outputs/export-api/tokens-endpoints#shared-token) | `fused.run("fsh_***")` | Share UDF without exposing code |
| Git commit | `fused.load("github.com/.../tree/{hash}/")` | Production stability |

<details>
<summary>Using git commit hash (recommended for production)</summary>

Pinning to a commit hash ensures your UDF won't break if the source changes:

```python showLineNumbers
commit_hash = "bdfb4d0"
udf = fused.load(f"https://github.com/fusedio/udfs/tree/{commit_hash}/public/Single_point_Eiffel_Tower/")
fused.run(udf)
```

![Commit hash demo](/img/core-concepts/run-udfs/commit_hash_demo.png)

:::warning
Avoid pointing to `main` branchâ€”your UDF will change when others push to it.
:::

</details>

## Execution engines

`fused.run()` can run locally or on Fused's serverless cloud:

```python showLineNumbers
# Remote (default) - runs on Fused server
fused.run(my_udf)

# Local - runs in your current process
fused.run(my_udf, engine="local")
```

:::warning
`fused.run()` defaults to `engine="remote"`. If you're not authenticated, explicitly use `engine="local"`.
:::

## Passing arguments

```python showLineNumbers
# my_udf
@fused.udf
def udf(name: str, count: int = 1):
    import pandas as pd
    return pd.DataFrame({"name": [name] * count})
```

```python showLineNumbers
fused.run(my_udf, name="hello", count=3)
```

You can also pass protected arguments like [`bounds`](/guide/working-with-udfs/geospatial/single-vs-tile/#bounds) and [`cache_max_age`](/guide/working-with-udfs/caching/#defining-your-cache-lifetime-cache_max_age):

```python showLineNumbers
fused.run("UDF_CDLs_Tile_Example", cache_max_age='1d')
```

## Async execution

Call UDFs asynchronously to run multiple in parallel:

```python showLineNumbers
@fused.udf
def udf(date: str='2020-01-01'):
    import pandas as pd
    import time
    time.sleep(2)
    return pd.DataFrame({'date': [date]})
```

```python showLineNumbers
async def run_parallel():
    import asyncio
    
    dates = ['2020-01-01', '2021-01-01', '2022-01-01']
    tasks = [fused.run("my_udf", date=d, sync=False) for d in dates]
    results = await asyncio.gather(*tasks)
    return pd.concat(results)
```

:::note
`sync=False` only works with `engine='remote'` and saved UDFs (by name or token).
:::

## When to scale up

| Need | Solution |
|------|----------|
| Run same UDF over multiple inputs | [`fused.submit()`](/guide/working-with-udfs/execution/parallel) |
| More than 120s execution time | [Batch Jobs](/guide/working-with-udfs/execution/batch-jobs) with `instance_type` |
| More than ~4GB RAM | [Batch Jobs](/guide/working-with-udfs/execution/batch-jobs) with `instance_type` |

:::tip
For HTTP endpoints, see [Tokens & Endpoints](/guide/data-input-outputs/export-api/tokens-endpoints).
:::
