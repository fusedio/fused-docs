---
id: realtime
title: Realtime
sidebar_label: Realtime
sidebar_position: 1
---

UDFs really shine once you start calling them from anywhere. Realtime is the default way to run UDFs. You can run them in 2 main ways:
1.  [`fused.run()`](/python-sdk/top-level-functions/#fusedrun) in Python. All you need is the [`fused` Python](/python-sdk/#python-install) package installed
    - Useful when wanting to run a UDF as part of another pipeline, inside another UDF or anywhere in Python / code.
2.  [**HTTPS call**](/guide/data-input-outputs/export-api/tokens-endpoints) from *anywhere*
    - Useful when you want to call a UDF outside of Python. For example, receiving dataframes into Google Sheets or plotting points and images in a [Felt map](/guide/data-input-outputs/export-api/geospatial#felt)
{/* TODO: Might want to mention `fused.submit()` here to be able to run multiple jobs? */}

### Defining Realtime UDF runs

Realtime UDF runs are defined as any job being:
- Less than 120s to execute
- Using less than a few Gb of RAM to run

These run in "real-time" with no start-up time, so are quick to run, but with limited resources and time-out if taking too long.

## [`fused.run()`](/python-sdk/top-level-functions/#fusedrun)

[`fused.run()`](/python-sdk/top-level-functions/#fusedrun) is the simplest & most common way to execute a UDF from any Python script or notebook.

The simplest way to call a public UDF is using a [public UDF name](/guide/working-with-udfs/execution/realtime#public-udf-name) and calling it as: `UDF_` + name. Let's take this UDF that returns [the location of the Eiffel Tower](https://github.com/fusedio/udfs/tree/main/public/Single_point_Eiffel_Tower) in a `GeoDataFrame` as an example:

```python showLineNumbers
fused.run("UDF_Single_point_Eiffel_Tower")
```


![Simple UDF fused.run() returning a geodataframe](/img/core-concepts/run-udfs/running_simple_eiffel_tower_udf.png)

There are a few other ways to run a UDF:

- [By name from your account](/guide/working-with-udfs/execution/realtime#name-from-your-account)
- [By public UDF name](/guide/working-with-udfs/execution/realtime#public-udf-name)
- [Using a token](/guide/working-with-udfs/execution/realtime#token)
- [Using a `udf` object](/guide/working-with-udfs/execution/realtime#udf-object)
- [From Github URL](/guide/working-with-udfs/execution/realtime#github-url)
- [From git commit hash (most recommended for teams)](/guide/working-with-udfs/execution/realtime#git-commit-hash-recommended-for-most-stable-use-cases)

### _Name_ (from your account)

_When to use: When calling a UDF you made, from your own account._

You can call any UDFs you have made simply by referencing it by name (given when you [save a UDF](/guide/working-with-udfs/writing-udfs/#save-udfs)).

(Note: This requires authentication)


![Hello World UDF](/img/core-concepts/run-udfs/hello_world_bbox_udf.png)

This UDF can then be run in a notebook locally (granted that you have authenticated):

```python showLineNumbers
fused.run("Hello_World_bbox")
```


![Running Hello World UDF](/img/core-concepts/run-udfs/running_hello_world_bbox_udf.png)

### _Name_ (from your teammate's account)

_When to use: When calling a UDF someone on your team made, from your own account._

Similarly, you can reference by name and run any UDFs under your teammates' accounts. Simply prefix the UDF name with the person's email address, separated by a `/`.

```python showLineNumbers
fused.run("teammate@fused.io/Hello_World_bbox")
```

Note that both your and your teammate's accounts must belong to the same organization.

### _Public UDF Name_

_When to run: Whenever you want to run a public UDF for free from anywhere_

Any UDF saved in the [public UDF repo](https://github.com/fusedio/udfs/tree/main) can be run for free.

Reference them by prefixing their name with `UDF_`. For example, [the public UDF `Get_Isochrone`](https://github.com/fusedio/udfs/tree/main/public/Get_Isochrone) is run with `UDF_Get_Isochrone`:

```python showLineNumbers
fused.run('UDF_Get_Isochrone')
```

### _Token_

_When to use: Whenever you want someone to be able to execute a UDF but might not want to share the code with them._

You can get the token from a UDF either in [Workbench](/workbench/) (Save your UDF then click "Share") or by returning the token in Python.

Here's a toy UDF that we want others to be able to run, but we don't want them to see the code:

```python showLineNumbers
# This example is from a notebook
import fused

@fused.udf()
def my_super_duper_private_udf(my_udf_input):
    import pandas as pd
    # This code is so private I don't want anyone to be able to read it
    return pd.DataFrame({"input": [my_udf_input]})
```

We then need to [save this UDF to Fused server](/guide/working-with-udfs/writing-udfs/#save-udfs) to make it accessible from anywhere.

```python showLineNumbers
# This example is from a notebook
my_super_duper_private_udf.to_fused()
```

:::note
`my_udf.to_fused()` saves your UDF to your personal user UDFs. These are private to you and your team. You can create a token that anyone (even outside your team) can use to run your UDF but by default these UDFs are private.
:::

We can create a token for this `my_super_duper_private_udf` and share it:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import LazyReactPlayer from '@site/src/components/LazyReactPlayer'

<Tabs className="unique-tabs">
  <TabItem value="python" label="Python" default>

    ```python showLineNumbers
    token = my_super_duper_private_udf.create_access_token()
    print(token)
    ```

    This would return something like: `'fsh_**********q6X'` (You can recognise this to be a shared token because it starts with `fsh_`)

  </TabItem>
  <TabItem value="workbench" label="Workbench">

    You can create a Share Token directly from Workbench:

    <LazyReactPlayer playsinline={true} className="video__player" playing={true} muted={true} controls height="100%" url="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/docs_rewrite/guide/working-with-udfs/execution/realtimeget_share_token.mp4" width="100%" />

  </TabItem>
</Tabs>

Once you have your `'fsh_***'` token, you can use it to run your UDF:

```python showLineNumbers
fused.run(token, my_udf_input="I'm directly using the token object")
```

or directly:

```python showLineNumbers
fused.run('fsh_**********q6X', my_udf_input="I can't see your private UDF but can still run it")
```

### _UDF_ object

_When to run: When you're writing your UDF in the same Python file / jupyter notebook and want to refer to the Python object directly. You might want to do this to test your UDF works locally for example_

You may also pass a UDF Python object to `fused.run`:

```python showLineNumbers
@fused.udf
def local_udf():
    import pandas as pd
    return pd.DataFrame({})

# Note that by default fused.run() will run your UDF on the Fused serverless server so we pass engine='local' to run this as a normal Python function
fused.run(local_udf, engine='local')
```

### _Github URL_

{/* Need to emphasise why this isn't recommended  */}
_When to use: [Not recommended] This is useful if you're working on a branch that you control. This method always points to the last commit on a branch so your UDF can break without you knowing if someone else pushes a new commit or merges & deletes your branch_

```python showLineNumbers
gh_udf = fused.load("https://github.com/fusedio/udfs/tree/main/public/REM_with_HyRiver/")
fused.run(gh_udf)
```

:::warning
We do NOT recommend you use this approach as your UDF might break if changes are done to it

    Especially using a URL pointing to a `main` branch means that your UDF will change if someone else pushes to it, in a way that isn't visible to you.

    For that reason we recommend using a [git commit hash](/guide/working-with-udfs/execution/realtime#git-commit-hash-recommended-for-most-stable-use-cases) instead

:::

### _Git commit hash_ (recommended for most stable use cases)

_When to use: Whenever you want to rely on a UDF such as in production or when using a UDF as a building block for another UDF._

This is the safest way to use a UDF. Since you're pointing to a specific git commit hash, you won't end up with changes breaking your UDF.

Using a git commit hash is the safest, and thus recommended way to call UDFs from Github.

This does mean you need to update the commit where your UDFs are being called if you want to propagate updates. But this gives you the most amount of control.

Let's again take the example of the Simple Eiffel Tower UDF:

![Running Hello World UDF](/img/core-concepts/run-udfs/commit_hash_demo.png)

```python showLineNumbers
commit_hash = "bdfb4d0"
commit_udf = fused.load(f"https://github.com/fusedio/udfs/tree/{commit_hash}/public/Single_point_Eiffel_Tower/")
fused.run(commit_udf)
```

### _Team UDF Names_

Team UDFs can be loaded or run by specifying the name "team", as in:

```python showLineNumbers
fused.load("team/udf_name")
```

This can be helpful when collaborating with team members as this does **not** require [making a shared token](/guide/working-with-udfs/execution/realtime#token)

## Execution engines

{/* Need more details for this */}

`fused.run` can run the UDF in various execution modes, as specified by the `engine` parameter either local or remote

- `local`: Run in the current process.
- `remote`: Run in the serverless Fused cloud engine (this is the default).
{/*- `batch`: Run a long-running job in a Fused server. This must first be enabled for the account.*/}

```python showLineNumbers
# By default, fused.run will use the remote engine
fused.run(my_udf)
```

```python showLineNumbers
# To run locally, explicitly specify engine="local"
fused.run(my_udf, engine="local")
```

:::warning
> ⚠️ **Important change:** `fused.run()` now defaults to `engine="remote"` in all cases, even when users are not authenticated. Previously, it would default to `engine="local"` for unauthenticated users.
> If you are not authenticated, you must explicitly specify `engine="local"` to run UDFs locally.
:::

Set `sync=False` to run a UDF asynchronously (see below).

## Async Execution

A UDF can be called asynchronously using the [async/await](https://docs.python.org/3/library/asyncio.html) syntax. A common implementation is to call a UDF multiple times in parallel with different parameters then combine the results.

:::note
Setting `sync=False` in `fused.run` is intended for asynchronous calls when running in the cloud with `engine='remote'`. The parameter has no effect if the UDF is ran in the local environment with `engine='local'`.
:::

To illustrate this concept, let's create a simple UDF and save it as `udf_to_run_async` in the workbench:

```python showLineNumbers
@fused.udf
def udf(date: str='2020-01-01'):
    import pandas as pd
    import time
    time.sleep(2)
    return pd.DataFrame({'selected_date': [date]})
```

:::note
We can not pass a UDF object directly to `fused.run`. Asynchronous execution is only supported for saved UDFs specifed by name or token.
:::

We can now invoke the UDF asynchronously for each date in the `dates` list and concatenate the results:

```python showLineNumbers
async def parent_fn():
    import pandas as pd
    import asyncio

    # Parameter to loop through
    dates = ['2020-01-01', '2021-01-01', '2022-01-01', '2023-01-01']

    # Invoke the UDF as coroutines
    promises_dfs = []
    for date in dates:
        df = fused.run("udf_to_run_async", date=date, engine='remote', sync=False)
        promises_dfs.append(df)

    # Run concurrently and collect the results
    dfs = await asyncio.gather(*promises_dfs)
    return pd.concat(dfs)
```

:::note
[nest_asyncio](https://pypi.org/project/nest-asyncio/) might be required to run UDFs async from Jupyter Notebooks.
```python showLineNumbers
!pip install nest-asyncio -q
import nest_asyncio
nest_asyncio.apply()
```
:::

## Passing arguments in [`fused.run()`](/python-sdk/top-level-functions/#fusedrun)

A typical [`fused.run()`](/python-sdk/top-level-functions/#fusedrun) call of a UDF looks like this:

```python showLineNumbers
@fused.udf
def my_udf(inputs: str):
    import pandas as pd
    return pd.DataFrame({"output": [inputs]})

fused.run(my_udf, inputs="hello world")
```

A [`fused.run()`](/python-sdk/top-level-functions/#fusedrun) call will require the following arguments:

1. [Mandatory] The first argument needs to be the UDF to run (name, object, token, etc [as seen above](/guide/working-with-udfs/execution/realtime#fusedrun))
2. [Optional] Any arguments of the UDF itself (if it has any). In the example above that's `inputs` because `my_udf` takes `inputs` as an argument.
3. [Optional] Any protected arguments as seen in the dedicated [API docs page](/python-sdk/top-level-functions/#fusedrun) (if applicable). These include for example:
   - `bounds` -> A geographical bounding box (as a list of 4 points: `[min_x, min_y, max_x, max_y]`) defining the area of interest.
   - `cache_max_age` -> The maximum [age of the UDF's cache](/guide/working-with-udfs/caching/#defining-your-cache-lifetime-cache_max_age).

#### Examples of using parameters

Changing the default cache max age:
```python showLineNumbers
fused.run("UDF_CDLs_Tile_Example", cache_max_age='1d')
```

:::tip Running jobs in parallel?
For running UDFs over multiple inputs in parallel, see [`fused.submit()`](/guide/working-with-udfs/execution/parallel).
:::

:::tip Calling UDFs via HTTP?
You can also call UDFs via HTTPS endpoints, turning your data into an API. See [Tokens & Endpoints](/guide/data-input-outputs/export-api/tokens-endpoints) for shared tokens, tiling, serialization formats, and more.
:::
