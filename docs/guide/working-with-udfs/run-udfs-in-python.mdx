---
id: fused-run
title: Running UDFs
sidebar_label: Running UDFs
sidebar_position: 3
---

Run a UDF and get results back.

## Calling a UDF

UDFs are callable objects—call them directly like regular Python functions:

```python
my_udf(
    *args,               # positional arguments
    engine=None,         # "remote" (default), "local", or instance type
    cache_max_age=None,  # max cache age, e.g. "48h", "10s"
    cache=True,          # set False to disable caching
    **kwargs,            # keyword arguments
)
```

See the [`Udf` API reference](/python-sdk/api-reference/udf) for full details.

## Loading a UDF

Use [`fused.load()`](/python-sdk/api-reference/fused-load) to get a UDF object, then call it directly:

| Method | Syntax | Use case |
|--------|--------|----------|
| Your UDF | `fused.load("my_udf")` | UDFs you created |
| Teammate's UDF | `fused.load("teammate@fused.io/my_udf")` | UDFs from your team |
| Team UDF | `fused.load("team/my_udf")` | Shared team UDFs |
| Public UDF | `fused.load("UDF_Name")` | [Public UDFs](https://github.com/fusedio/udfs/tree/main) (free) |
| [Token](/guide/data-input-outputs/export-api/tokens-endpoints#shared-token) | `fused.load("fsh_***")` | Share UDF without exposing code |
| Git commit | `fused.load("github.com/.../tree/{hash}/")` | Production stability |

```python
# Load and call
my_udf = fused.load("my_udf")
result = my_udf(name="hello")
```

:::tip Pin to commit hash for production
```python
commit_hash = "bdfb4d0"
my_udf = fused.load(f"https://github.com/fusedio/udfs/tree/{commit_hash}/public/My_UDF/")
result = my_udf()
```
Avoid pointing to `main` branch—your UDF will change when others push to it.
:::

## Parameters

### `engine`

| Engine | Where it runs | Use case |
|--------|---------------|----------|
| `"remote"` (default) | Spins up new serverless instance | Standard usage |
| `"local"` | Current process | Run in existing compute |
| Instance type | Dedicated machine | Heavy workloads |

**`local` contexts:**

| Context | What happens |
|---------|--------------|
| Inside a UDF | Shares that UDF's compute (120s, ~4GB) |
| Inside a batch job | Shares the batch instance resources |
| On your laptop | Runs on local machine |

### `instance_type`

Pass an instance type as `engine` to run on a dedicated machine:

```python
result = my_udf(engine="medium")  # 64 GB RAM
```

| Type | RAM | Time limit | Startup |
|------|-----|------------|---------|
| `"realtime"` (default) | ~4GB | 120s | ~5s |
| `"small"` | 2 GB | None | ~30s |
| `"medium"` | 64 GB | None | ~30s |
| `"large"` | 512 GB | None | ~30s |

:::tip Default instance type
Set a default instance type when defining a UDF:

```python
@fused.udf(instance_type="large")
def my_udf():
    ...
```

In Workbench, UDFs with a non-realtime instance type will prompt for confirmation before running as a batch job.
:::

<details>
<summary>All AWS instance types</summary>

| Instance Type | vCPUs | Memory (GB) |
|---------------|-------|-------------|
| `m5.large` | 2 | 8 |
| `m5.xlarge` | 4 | 16 |
| `m5.2xlarge` | 8 | 32 |
| `m5.4xlarge` | 16 | 64 |
| `m5.8xlarge` | 32 | 128 |
| `m5.12xlarge` | 48 | 192 |
| `m5.16xlarge` | 64 | 256 |
| `r5.large` | 2 | 16 |
| `r5.xlarge` | 4 | 32 |
| `r5.2xlarge` | 8 | 64 |
| `r5.4xlarge` | 16 | 128 |
| `r5.8xlarge` | 32 | 256 |
| `r5.12xlarge` | 48 | 384 |
| `r5.16xlarge` | 64 | 512 |
| `t3.small` | 2 | 2 |
| `t3.medium` | 2 | 4 |
| `t3.large` | 2 | 8 |
| `t3.xlarge` | 4 | 16 |
| `t3.2xlarge` | 8 | 32 |

</details>

<details>
<summary>All GCP instance types</summary>

| Instance Type | vCPUs | Memory (GB) |
|---------------|-------|-------------|
| `c2-standard-4` | 4 | 16 |
| `c2-standard-8` | 8 | 32 |
| `c2-standard-16` | 16 | 64 |
| `c2-standard-30` | 30 | 120 |
| `c2-standard-60` | 60 | 240 |
| `m3-ultramem-32` | 32 | 976 |
| `m3-ultramem-64` | 64 | 1,952 |

</details>

### `cache_max_age`

Control how long results are cached. UDFs are cached for **90 days by default**.

| Value | Meaning |
|-------|---------|
| `None` (default) | Follow `@fused.udf()` setting (90 days) |
| `"0s"` | No caching |
| `"10s"`, `"48h"`, `"1d"` | Cache for specified duration |

```python
result = my_udf(cache_max_age="1h")  # Cache for 1 hour
result = my_udf(cache=False)         # Disable caching
```

:::tip
Set a default cache duration in the UDF decorator:
```python
@fused.udf(cache_max_age="1d")
def my_udf():
    ...
```
:::

Learn more about [caching](/guide/working-with-udfs/udf-best-practices/caching).

## Passing arguments

Pass UDF parameters as keyword arguments:

```python
@fused.udf
def my_udf(name: str, count: int = 1):
    import pandas as pd
    return pd.DataFrame({"name": [name] * count})

result = my_udf(name="hello", count=3)
```

## Reserved parameters

These parameters control how Fused structures the `bounds` object for [tile UDFs](/guide/working-with-udfs/udf-best-practices/geospatial-single-vs-tile).

### With `x`, `y`, `z`

```python
overture_udf = fused.load("UDF_Overture_Maps_Example")
result = overture_udf(x=5241, y=12662, z=15)
```

### With `bounds` as GeoDataFrame

```python
import geopandas as gpd
bounds = gpd.GeoDataFrame.from_features({...})
result = overture_udf(bounds=bounds)
```

### With `bounds` as bbox list

```python
# [min_x, min_y, max_x, max_y]
result = overture_udf(bounds=[-122.349, 37.781, -122.341, 37.818])
```

## See also

- [Run UDFs efficiently](/guide/working-with-udfs/udf-best-practices/realtime) — best practices
- [Parallel execution](/guide/working-with-udfs/fused-submit) — run over multiple inputs
- [Caching](/guide/working-with-udfs/udf-best-practices/caching) — how caching works
- [`Udf` API reference](/python-sdk/api-reference/udf) — full API details

---

## [[Legacy](/python-sdk/api-reference/fused-run)]: `fused.run()`

The `fused.run()` function still works but direct UDF calling is preferred:

```python
# Legacy
result = fused.run(my_udf, name="hello")

# Preferred
result = my_udf(name="hello")
```
