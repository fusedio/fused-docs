---
id: caching
title: How to use caching
sidebar_label: How to use caching
sidebar_position: 4
---

Fused caches UDF results automatically to make repeated calls faster. Understanding the two caching mechanisms helps you control freshness vs performance.

## Two types of cache

| Type | When it applies | Storage | Default TTL | Speed |
|------|-----------------|---------|-------------|-------|
| UDF cache | `fused.run()` results | S3 | 90 days | Good |
| `@fused.cache` | Functions inside UDFs | mount | 12 hours | Fast |

Both work the same way: store the result of [function + inputs], return cached result on repeat calls. Change the function or inputs → cache miss → recompute.

## UDF cache

Every `fused.run()` call is cached automatically. No configuration needed.

```python
fused.run(my_udf)  # First call: runs UDF
fused.run(my_udf)  # Second call: returns cached result
```

**Disable caching** when you need fresh results:

```python
@fused.udf(cache_max_age=0)
def udf():
    ...

# Or at call time
fused.run(my_udf, cache_max_age=0)
```

**Reset cache** to force a fresh run once:

```python
fused.run(my_udf, cache_reset=True)
```

## @fused.cache

Use `@fused.cache` for expensive operations *inside* a UDF—loading slow file formats, heavy computations that repeat across runs.

```python
@fused.udf
def udf(ship_length: int = 100):
    
    @fused.cache
    def load_data(path):
        import pandas as pd
        return pd.read_csv(path)  # Slow format, cache it
    
    df = load_data("s3://bucket/large_file.csv")
    return df[df.Length > ship_length]
```

The CSV loads once and caches. Changing `ship_length` doesn't reload the file—only changing the `path` would.

**When to use it:**
- Loading CSV, Shapefile, or other slow formats
- Expensive computations that don't depend on all UDF parameters
- API calls you don't want to repeat

**When NOT to use it:**
- Very large datasets (>10GB)—consider [ingesting to cloud-native formats](/guide/data-input-outputs/read-write/geospatial/ingestion) instead
- Operations that depend on `bounds`—you'll cache a new file for every map pan

## Common gotchas

### Realtime vs batch have separate caches

```python
fused.run("my_udf")                         # realtime cache
fused.run("my_udf", instance_type="small")  # different cache (batch)
```

### Parent/child UDF changes

When calling one UDF from another, the child won't automatically refresh when the parent changes:

```python
@fused.udf
def child_udf():
    data = fused.run("parent_udf")  # Won't re-fetch if parent changes
    return data
```

Fix: disable cache on the child so it always calls the parent:

```python
@fused.udf(cache_max_age=0)
def child_udf():
    data = fused.run("parent_udf")  # Always gets latest from parent
    return data
```

### Don't cache bounds-dependent code

```python
# Bad: creates new cache entry for every map pan
@fused.cache
def process(bounds):
    ...

# Good: cache the data load, filter by bounds outside
@fused.cache
def load_data(path):
    return gpd.read_file(path)

gdf = load_data(path)
return gdf[gdf.geometry.within(bounds_geom)]
```

## cache_max_age reference

Control how long cached results stay valid.

**Format:** `30s` (seconds), `10m` (minutes), `24h` (hours), `7d` (days)

**Where you can set it:**

| Context | Example |
|---------|---------|
| UDF definition | `@fused.udf(cache_max_age="24h")` |
| fused.run() | `fused.run(udf, cache_max_age="1h")` |
| @fused.cache | `@fused.cache(cache_max_age="30m")` |
| HTTP endpoint | `udf.fused.io/token?cache_max_age=0` |

**Priority:** `fused.run()` > `@fused.udf()` > default (90 days)

## See also

- [Data ingestion](/guide/data-input-outputs/read-write/geospatial/ingestion) — for large datasets, ingest to Parquet/GeoParquet instead of caching
- [Run UDFs in python](/guide/working-with-udfs/run-udfs-in-python) — full `fused.run()` reference
