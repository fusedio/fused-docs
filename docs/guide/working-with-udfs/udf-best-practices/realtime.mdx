---
id: realtime
title: Run UDFs efficiently
sidebar_label: Run UDFs efficiently
sidebar_position: 1
---

Realtime is the default way to run UDFs—no configuration needed. Every UDF runs in realtime mode unless you explicitly request a batch instance.

This guide covers best practices for calling UDFs from other UDFs and building pipelines. For the full API reference, see the [`Udf` class](/python-sdk/api-reference/udf).

## Limits

| Resource | Limit |
|----------|-------|
| Execution time | 120s |
| RAM | ~4GB |

Need more? See [Scaling out UDFs](/guide/working-with-udfs/udf-best-practices/scaling-out).

## Calling another UDF

Load and call UDFs directly:

```python
@fused.udf
def udf():
    child = fused.load("child_udf")
    result = child(name="hello")
    return result
```

![Calling another UDF in workbench](/img/core-concepts/execution/fused_run_simple_demo.png)

In Workbench, UDF calls create visual links between parent and child UDFs, making pipelines easy to follow.

:::note
For geospatial UDFs, you can pass `bounds` as a bbox list, GeoDataFrame, or tile coordinates. See [Reserved parameters](/guide/working-with-udfs/running-udfs#reserved-parameters).
:::

## Best practices

### Keep results fresh

By default, UDF results are cached. To always get fresh data, disable caching:

```python
@fused.udf(cache_max_age=0)
def udf():
    parent = fused.load('parent_udf')
    return parent()
```

:::warning
Setting `cache_max_age=0` means this UDF runs from scratch every time—no caching. Use this when your output depends on frequently changing data.
:::

### Pin to commit hash for production

When loading UDFs from GitHub, pin to a specific commit:

```python
commit_hash = "bdfb4d0"
my_udf = fused.load(f"https://github.com/fusedio/udfs/tree/{commit_hash}/public/My_UDF/")
result = my_udf()
```

Avoid pointing to `main` branch—your UDF will break when others push changes.

## Warm & cold starts

After inactivity, Fused needs to spin up an instance and load the environment. This **cold start** typically takes 10-15s.

Once warm, subsequent realtime calls execute within seconds. Instances stay warm with regular use. Fused does not charge for cold start time.

![Cold start vs warm execution](/img/core-concepts/cold_warm_start.png)

## When to scale up

| Need | Solution |
|------|----------|
| Run same UDF over multiple inputs | [Parallel execution](/guide/working-with-udfs/udf-best-practices/scaling-out#parallel-execution) |
| More than 120s or ~4GB | [Dedicated instances](/guide/working-with-udfs/udf-best-practices/scaling-out#dedicated-instances) |

## See also

- [Running UDFs](/guide/working-with-udfs/running-udfs) — full reference
- [`Udf` API reference](/python-sdk/api-reference/udf) — all methods and parameters
- [Tokens & endpoints](/guide/data-input-outputs/export-api/tokens-endpoints) — call UDFs via HTTP
- [Caching](/guide/working-with-udfs/udf-best-practices/caching) — how caching works
