---
id: realtime
title: Run jobs efficiently
sidebar_label: Run jobs efficiently
sidebar_position: 1
---

Realtime is the default way to run UDFs—no configuration needed. Every UDF runs in realtime mode unless you explicitly request a batch instance.

This guide covers best practices for calling UDFs from other UDFs and building pipelines. For the full `fused.run()` reference, see [Run UDFs in python](/guide/working-with-udfs/fused-run).

## Limits

| Resource | Limit |
|----------|-------|
| Execution time | 120s |
| RAM | ~4GB |

Need more? See [How to run a batch job](/guide/working-with-udfs/udf-best-practices/batch-jobs).

## Calling another UDF

Use `fused.run()` to call one UDF from another:

```python
@fused.udf
def parent_udf():
    # Call child UDF
    result = fused.run("child_udf", name="hello")
    return result
```

![Calling another UDF in workbench](/img/core-concepts/execution/fused_run_simple_demo.png)

In Workbench, `fused.run("udf_name")` creates a visual link between parent and child UDFs, making pipelines easy to follow.

:::note
For geospatial UDFs, you can pass `bounds` as a bbox list, GeoDataFrame, or tile coordinates. See [Reserved parameters](/guide/working-with-udfs/fused-run#reserved-parameters).
:::

## Best practices

### Keep results fresh

By default, UDF results are cached. To always get fresh data when calling another UDF, set `cache_max_age=0` on your UDF:

```python
@fused.udf(cache_max_age=0)
def udf():
    data = fused.run('parent_udf')
    return data
```

:::warning
Setting `cache_max_age=0` means this UDF runs from scratch every time—no caching. Use this when your output depends on frequently changing data.
:::

### Pin to commit hash for production

When calling UDFs from GitHub, pin to a specific commit:

```python
commit_hash = "bdfb4d0"
udf = fused.load(f"https://github.com/fusedio/udfs/tree/{commit_hash}/public/My_UDF/")
fused.run(udf)
```

Avoid pointing to `main` branch—your UDF will break when others push changes.

## Warm & cold starts

After inactivity, Fused needs to spin up an instance and load the environment. This **cold start** typically takes 10-15s.

Once warm, subsequent realtime calls execute within seconds. Instances stay warm with regular use. Fused does not charge for cold start time.

![Cold start vs warm execution](/img/core-concepts/cold_warm_start.png)

## When to scale up

| Need | Solution |
|------|----------|
| Run same UDF over multiple inputs | [How to run in parallel](/guide/working-with-udfs/udf-best-practices/parallel) |
| More than 120s or ~4GB | [How to run a batch job](/guide/working-with-udfs/udf-best-practices/batch-jobs) |

## See also

- [Run UDFs in python](/guide/working-with-udfs/fused-run) — full `fused.run()` reference
- [Tokens & endpoints](/guide/data-input-outputs/export-api/tokens-endpoints) — call UDFs via HTTP
- [Caching](/guide/working-with-udfs/udf-best-practices/caching) — how caching works
