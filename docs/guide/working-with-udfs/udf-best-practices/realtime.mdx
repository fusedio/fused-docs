---
id: realtime
title: How to run a Realtime job
sidebar_label: How to run a Realtime job
sidebar_position: 1
---


Realtime is the default way to run UDFs. You can run them in 2 main ways:
1. [`fused.run()`](/python-sdk/top-level-functions/#fusedrun) in Python
2. [**HTTPS call**](/guide/data-input-outputs/export-api/tokens-endpoints) from anywhere

## Realtime limits

Realtime UDF runs are:
- Less than **120s** to execute
- Less than **~4GB** of RAM

These run with no start-up time, so are quick to run, but with limited resources. Need more? See [Batch Jobs](/guide/working-with-udfs/udf-best-practices/batch-jobs).

## `fused.run()`

[`fused.run()`](/python-sdk/top-level-functions/#fusedrun) is the simplest way to call another UDF

```python showLineNumbers
fused.run("my_udf")
```

![Calling another UDF in workbench](/img/core-concepts/execution/fused_run_simple_demo.png)

### Ways to reference a UDF

| Method | Syntax | When to use |
|--------|--------|-------------|
| Your UDF | `fused.run("my_udf")` | UDFs you created (requires auth) |
| Teammate's UDF | `fused.run("teammate@fused.io/my_udf")` | UDFs from your team |
| Team UDF | `fused.run("team/my_udf")` | Shared team UDFs |
| Public UDF | `fused.run("UDF_Name")` | [Public UDFs](https://github.com/fusedio/udfs/tree/main) (free) |
| [Token](/guide/data-input-outputs/export-api/tokens-endpoints#shared-token) | `fused.run("fsh_***")` | Share UDF without exposing code |
| Git commit | `fused.run("github.com/.../tree/{hash}/")` | Production stability |

<details>
<summary>Using git commit hash (recommended for production)</summary>

Pinning to a commit hash ensures your UDF won't break if the source changes:

```python showLineNumbers
commit_hash = "bdfb4d0"
udf = fused.load(f"https://github.com/fusedio/udfs/tree/{commit_hash}/public/Single_point_Eiffel_Tower/")
fused.run(udf)
```

![Commit hash demo](/img/core-concepts/run-udfs/commit_hash_demo.png)

:::warning
Avoid pointing to `main` branch—your UDF will change when others push to it.
:::

</details>

## Execution engines

| Engine | Where it runs | Use case |
|--------|---------------|----------|
| `remote` (default) | Spins up new serverless UDF | Standard usage—each `fused.run()` gets its own compute |
| `local` | Current process | Run in existing compute context |

### `engine="local"` contexts

`local` runs the UDF in whatever compute you're already using:

| Context | What happens |
|---------|--------------|
| Inside a UDF | Runs in that UDF's compute (shares 120s limit & ~4GB RAM) |
| Inside a batch job | Runs in the [batch job](/guide/working-with-udfs/udf-best-practices/batch-jobs)'s compute (shares instance resources) |
| On your laptop | Runs on your local machine (requires `fused` package [installed](/python-sdk/#python-install)) |

<details>
<summary>Example: Inside a UDF</summary>

```python showLineNumbers
@fused.udf
def my_udf():
    # upstream_udf runs in this UDF's compute, sharing the 120s limit
    result = fused.run("upstream_udf", engine="local")
    return result
```

</details>

<details>
<summary>Example: Inside a batch job</summary>

```python showLineNumbers
@fused.udf(instance_type="large")
def batch_udf():
    # upstream_udf runs in the batch instance's compute
    result = fused.run("upstream_udf", engine="local")
    return result
```

This lets you leverage the [batch job's](/guide/working-with-udfs/udf-best-practices/batch-jobs) resources (more RAM, no time limit) for the inner UDF call.

</details>

<details>
<summary>Example: On your laptop</summary>

Requires [installing the `fused` package](/python-sdk/#python-install) and authenticating.

```python showLineNumbers
import fused

# Runs on your local machine's hardware
result = fused.run(my_udf, engine="local")
```

</details>

:::note
`engine="local"` in a batch job is similar to running on your laptop—both use "local" hardware. The batch job just provides cloud-hosted local compute.
:::

## Passing arguments

```python showLineNumbers
# my_udf
@fused.udf
def udf(name: str, count: int = 1):
    import pandas as pd
    return pd.DataFrame({"name": [name] * count})
```

```python showLineNumbers
fused.run(my_udf, name="hello", count=3)
```

You can also pass protected arguments like [`bounds`](/guide/working-with-udfs/udf-best-practices/geospatial-single-vs-tile/#bounds) and [`cache_max_age`](/guide/working-with-udfs/udf-best-practices/caching/#defining-your-cache-lifetime-cache_max_age):

```python showLineNumbers
fused.run("UDF_CDLs_Tile_Example", cache_max_age='1d')
```

## Async execution

Call UDFs asynchronously to run multiple in parallel:

```python showLineNumbers
@fused.udf
def udf(date: str='2020-01-01'):
    import pandas as pd
    import time
    time.sleep(2)
    return pd.DataFrame({'date': [date]})
```

```python showLineNumbers
async def run_parallel():
    import asyncio
    
    dates = ['2020-01-01', '2021-01-01', '2022-01-01']
    tasks = [fused.run("my_udf", date=d, sync=False) for d in dates]
    results = await asyncio.gather(*tasks)
    return pd.concat(results)
```

:::note
`sync=False` only works with `engine='remote'` and saved UDFs (by name or token).
:::

## When to scale up

| Need | Solution |
|------|----------|
| Run same UDF over multiple inputs | [`fused.submit()`](/guide/working-with-udfs/udf-best-practices/parallel) |
| More than 120s execution time | [Batch Jobs](/guide/working-with-udfs/udf-best-practices/batch-jobs) with `instance_type` |
| More than ~4GB RAM | [Batch Jobs](/guide/working-with-udfs/udf-best-practices/batch-jobs) with `instance_type` |

:::tip
For HTTP endpoints, see [Tokens & Endpoints](/guide/data-input-outputs/export-api/tokens-endpoints).
:::
