---
slug: realtime-data-processing
title: Realtime data processing
---

# Realtime data filtering with DuckDB WASM

This tutorial will show you how to build this dashboard processing all of the USDA Crop Data Layer for a year in realtime:

<iframe 
    style={{
        width: "100%",
        height: "600px",
        minHeight: "500px",
        margin: "0 auto",
        display: "block",
        border: "1px solid #e1e5e9",
        borderRadius: "8px"
    }}
    src="https://unstable.fused.io/canvas/fc_2Q5aNgJzLTagImf6MOdWTG" 
    title="Fused Canvas - Realtime Data Processing Dashboard" 
    frameBorder="0" 
    allowFullScreen
    allow="fullscreen">
</iframe>

[Open in a new tab](https://unstable.fused.io/canvas/fc_2Q5aNgJzLTagImf6MOdWTG)

# 1. Querying data with DuckDB WASM

The simplest way to use DuckDB in the browser is to use DuckDB WASM to query a hosted file. Feel free to edit the SQL query directly:

<iframe 
    style={{
        width: "100%",
        height: "200px",
        minHeight: "500px", 
        margin: "0 auto",
        display: "block",
        border: "1px solid #e1e5e9",
        borderRadius: "8px"
    }}
    src="https://www.fused.io/server/v1/realtime-shared/UDF_Duckdb_Table_loading_from_s3/run/file"
    title="DuckDB WASM Data Loading Demo"
    frameBorder="0"
    allowFullScreen
    allow="fullscreen">
</iframe>

This UDF:
- Signs S3 once so browser can fetch it
- Loads parquet as view `df`
- Auto-runs query as you type (small debounce)
- 'Run' button stays disabled until data is ready and becomes optional

See the code in [Fused Catalog](https://www.fused.io/workbench/catalog/Duckdb_Table_loading_from_s3-f34e72ff-592b-443d-b987-0bc667980463)

## 2. Calling data from a UDF

Fused UDFs allow you to directly call data from a UDF. This allows us to fetch a large dataset like the 2024 USDA Crop Data Layer and process it in a UDF:
- Fetch data from Source Cooperative
- Remove background nodata (`0`)
- Aggregate data from a hex7 into a hex5 resolution
- Calculate the percentage that each crop type makes up of the total area of each cell 

This way we can pass less data directly to DuckDB WASM and make the first data load much faster. 

<iframe 
    style={{
        width: "100%",
        height: "200px",
        minHeight: "500px", 
        margin: "0 auto",
        display: "block",
        border: "1px solid #e1e5e9",
        borderRadius: "8px"
    }}
    src="https://www.fused.io/server/v1/realtime-shared/UDF_Duckdb_Table_loading_from_s3/run/file"
    title="DuckDB WASM Data Loading Demo"
    frameBorder="0"
    allowFullScreen
    allow="fullscreen">
</iframe>


### Getting Data

Data comes from [Source Cooperative](https://source.coop/fused/hex), based on the 2024 USDA Crop Data Layer. Fused [repartitioned this into H3 hexagons](https://docs.fused.io/blog/cdl-census-hex) and made it available on [Source Cooperative](https://source.coop/fused/hex) for anyone to access.

We'll visualize the 2024 `hex8` data as a parquet file:

```bash
https://source.coop/fused/hex/release_2025_04_beta/cdl/hex8_2024.parquet
```

This has aggregated the data by `hex8` and has the following columns:

| column | description |
|--------|-------------|
| `value` | USDA Crop Data Layer classification code (e.g., 141, 176, 152, 142, 190) |
| `area` | Area in square meters for each crop type within the hex cell |
| `hex` | H3 hexagon identifier at resolution 8 |

### Processing Data with DuckDB

Before we display the data we want to:
- Remove any nodata (`0`) in CDL
- Calculate the percentage that each crop type makes up of the total area of each hex8 cell 
- Return `lat / lon` coordinates for each hex8 cell to be able to display the data on a map

We can write a simple [Fused UDF](/core-concepts/write) to do this for us:

{/* 
TODO: Update with the latest code 
Explain in code:
- Bounds? from US?
*/}

<details>
    <summary>Expand to see code</summary>
    ```python
    @fused.udf
    def udf(bounds: fused.types.Bounds = [-138.80276917029278,-10.699680369962277,-54.08965045331159,65.89861176695153], buffer_multiple: float = 1, hex_res: int = 4):
        crop_type=''
        
        import pandas as pd
        path = "s3://fused-users/fused/asset/CDL_h12k1p1/year=2024/"
        H3_From_To_Pos = fused.load("https://github.com/fusedlabs/fusedudfs/tree/5b022e0/H3_From_To_Pos/")
        df = H3_From_To_Pos.read_hexfile_bounds(bounds=bounds, url=f"{path}overview/hex{hex_res}.parquet", clip=1)
        CDL = fused.load("UDF_CDLs_Tile_Example")
        df = df[df["data"].isin(CDL.crop_type_list(crop_type))]
        import h3.api.basic_int as h3
        df['lat'] = df.hex.map(lambda x:h3.cell_to_latlng(x)[0])
        df['lng'] = df.hex.map(lambda x:h3.cell_to_latlng(x)[1])
        
        print(CDL.crop_stats(df))

        crop_stats = CDL.crop_stats(df)
        name_mapping = crop_stats['name'].to_dict()
        
        con = fused.utils.common.duckdb_connect()

        df = con.sql(
            """
            INSTALL spatial;
            LOAD spatial;
            
            SELECT 
                data,
                lat, 
                lng,
                area, 
                area / (h3_cell_area(hex,'m^2')/100) as pct,
            FROM df
            WHERE data != 0
            """
        ).df()

        df['name'] = df['data'].map(name_mapping)
        

        sample_cols = ['data', 'name', 'lat', 'lng', 'area', 'pct']
        available_cols = [col for col in sample_cols if col in df.columns]
        print(df[available_cols].head(3))
        
        df = df.sort_values('pct', ascending=False)
        df = df.sort_values('data').set_index('data')
        df['pct']=df['pct'].astype(int)
        import h3.api.basic_int as h3
        df['hex']=df.apply(lambda r: h3.latlng_to_cell(r[0],r[1],hex_res),1)
        del df['lat']
        del df['lng']
        del df['name']
        print(df)
        return df.sample(100)
    ```
</details>

{/* TODO: Add link to community UDF once we have it  */}
{/* You can directly see the code for this UDF here */}

This returns a dataframe directly. We can then pass this data to another UDF to render it on a map.

## Live filtering on Map

<iframe
  src="https://www.fused.io/server/v1/realtime-shared/UDF_WASM_Filtering_CDL/run/file?dtype_out_raster=png&dtype_out_vector=html"
  width="100%"
  height="600px"
  frameBorder="0"
></iframe>


Here's how the map is built:

1. Data Source: Fetches Parquet from previous UDF
2. Browser Database: Loads into DuckDB WASM with H3/spatial extensions
3. Real-time Filtering: Applies SQL WHERE conditions on user input
4. Geometry Generation: Converts H3 cells to hexagon boundaries
5. Map Visualization: Renders colored hexagons with tooltips
6. Live Statistics: Shows count, area, and averages for filtered data

The most interesting parts are:

### Reading from Data UDF

No need to save to files, we've [deployed the previous UDF as an endpoint](/tutorials/engineering-etl/#turn-your-data-into-an-api):

```javascript
async function loadParquet(bytes) {{
    await duckdb.registerFileBuffer('data.parquet', bytes);
    await conn.query('DROP TABLE IF EXISTS spatial_data_full;');
    await conn.query(`
    CREATE TABLE spatial_data_full AS
    SELECT row_number() OVER() AS id,
            CAST(hex AS BIGINT) AS h3_cell,
            CAST(data AS INTEGER) AS data,
            CAST(area AS DOUBLE) AS area,
            CAST(pct  AS DOUBLE) AS pct
    FROM read_parquet('data.parquet')
    WHERE hex IS NOT NULL
    `);
}}
```

### Real-time filtering using DuckDB

The user passes the crop type ID, and the map is updated in real time:

```javascript
async function applyFilter(expr) {{
    await conn.query('DROP TABLE IF EXISTS spatial_data;');
    await conn.query('CREATE TABLE spatial_data AS SELECT * FROM spatial_data_full WHERE (' + expr + ')');
}}
```

{/* TODO: Add link to catalog once its up */}
{/* You can see the full code here for yourself */}

### Customizing with the AI Assistant 

Fused UDFs allow you to return data or HTML. This map was built directly using the [AI Assistant](/workbench/ai-assistant/). 

We started with a simple map and added:
- Hover tooltips
- Input box to pass SQL query to filter the data
- Statistics to display total count, area and percentage of coverage of the filtered data

Because Fused UDFs are serverless, not only can the AI Assistant build the map, but you get direct feedback seeing your results in real time!

## Want to try it yourself?

You can book a demo directly with Max, our Developer Advocate, right [here](https://calendly.com/max-fused/30min)!

We'd love to show you how to build this for yourself!

Sign up for a free account [here](https://www.fused.io/workbench) and try it out for yourself!

