---
slug: dynamic-tile-to-h3
title: Dynamic Tile to H3
authors: [fused]
tags: [h3, geospatial]
sidebar_position: 2
---

# Dynamic Tile to H3

Dynamically tile data into H3 hexagons in a given viewport. Hex resolution is calculated based on the bounds of the viewport.

The following examples are available in a [dedicated Fused Canvas](https://www.fused.io/canvas/fc_6axFAIdiqYrWuLNkDXi06c)

:::note Set your UDF to [Tile UDF Mode](/tutorials/Geospatial%20with%20Fused/filetile/#tile-udf)

The examples in this page all use the [Tile UDF Mode](/tutorials/Geospatial%20with%20Fused/filetile/#tile-udf) to dynamically compute H3 based on the viewport bounds.

Read more about the differences between [Tile UDF Mode](/tutorials/Geospatial%20with%20Fused/filetile/#tile-udf) and [Single UDF Mode](/tutorials/Geospatial%20with%20Fused/filetile/#single-udf).

:::

## Polygon to Hex

The following example uses a [simplified Census Block Group dataset of the state of California](https://www.fused.io/workbench/files?path=s3%3A%2F%2Ffused-asset%2Fdemos%2Fcatchment_analysis%2Fsimplified_acs_bg_ca_2022.parquet), showing a heatmap of the population density per hex 9 cell:

<iframe 
  src="https://www.fused.io/server/v1/realtime-shared/fc_6axFAIdiqYrWuLNkDXi06c-hex_tile_map_template_with_tooltip_v2/run/file"
  width="100%"
  height="600px"
  frameBorder="0"
  style={{borderRadius: '8px'}}
></iframe>

Link to UDF in [Fused Catalog](https://www.fused.io/workbench/catalog/census_to_hex_template_v2-53ff4b2f-fb6e-4284-9c0d-4b5f04b4f3d1)

<details>
<summary>Code</summary>
```python showLineNumbers
@fused.udf
def udf(
    bounds: fused.types.Bounds = [-125.0, 24.0, -66.9, 49.0],
    path: str = "s3://fused-asset/demos/catchment_analysis/simplified_acs_bg_ca_2022.parquet",
    min_hex_cell_res: int= 11, # Increase this if working with high res local data
    max_hex_cell_res: int= 4,
):
    import pandas as pd
    import geopandas as gpd
    
    common = fused.load("https://github.com/fusedio/udfs/tree/f430c25/public/common/")
    
    # Dynamic H3 resolution
    def dynamic_h3_res(b):
        z = common.estimate_zoom(b)
        return max(min(int(2 + z / 1.5),min_hex_cell_res), max_hex_cell_res)
    
    parent_res = max(dynamic_h3_res(bounds) - 1, 0)
    
    # Load and clip data
    gdf = gpd.read_parquet(path)
    tile = common.get_tiles(bounds, clip=True)
    gdf = gdf.to_crs(4326).clip(tile)
    
    # Early exit if empty
    if len(gdf) == 0:
        return pd.DataFrame(columns=["hex", "POP", "pct"])
    
    # Hexify
    con = common.duckdb_connect()
    df_hex = common.gdf_to_hex(gdf, res=parent_res, add_latlng_cols=None)
    con.register("df_hex", df_hex)
    
    # Aggregate to parent hexagons and calculate percentages
    # In this case we're aggregating by sum
    query = f"""
    WITH agg AS (
        SELECT 
            h3_cell_to_parent(hex, {parent_res}) AS hex, 
            SUM(POP) AS POP
        FROM df_hex
        GROUP BY hex
    )
    SELECT
        hex,
        POP,
        POP * 100.0 / SUM(POP) OVER () AS pct
    FROM agg
    ORDER BY POP DESC
    """
    
    return con.sql(query).df()
```
</details>

### Requirements

- Polygon Dataset
```csv
          GEOID  POP  ...                                           geometry
0  060376500012  82   ...  POLYGON ((-118.32649 33.88282, -118.32206 33.8...
1  060376500014  315  ...  POLYGON ((-118.32647 33.87978, -118.32214 33.8...
2  060376503002  145  ...  POLYGON ((-118.3525 33.87249, -118.34388 33.87...
```

- Passing the [viewport `bounds`](/tutorials/Geospatial%20with%20Fused/filetile/#bounds)

```python showLineNumbers
bounds: fused.types.Bounds = [-118.32649, 33.87249, -118.32206, 33.88282]
```

- Field to hexagonify & Aggregation function. In this example we're summing the population: `POP`

### Logic

1. Get tile & hex resolution

```python showLineNumbers
common = fused.load("https://github.com/fusedio/udfs/tree/f430c25/public/common/")

def dynamic_h3_res(b):
    z = common.estimate_zoom(b)
    return max(min(int(2 + z / 1.5),min_hex_cell_res), max_hex_cell_res)

parent_res = max(dynamic_h3_res(bounds) - 1, 0)
```

2. Load data & clip to tile

```python showLineNumbers
gdf = gpd.read_parquet(path)
tile = common.get_tiles(bounds, clip=True)
gdf = gdf.to_crs(4326).clip(tile)
```

3. Hexify

```python showLineNumbers
# We'll use functions from the common UDFs
df_hex = common.gdf_to_hex(gdf, res=parent_res, add_latlng_cols=None)
```

4. Aggregate

```python showLineNumbers
query = f"""
WITH agg AS (
    SELECT 
        h3_cell_to_parent(hex, {parent_res}) AS hex, 
        SUM(POP) AS POP
    FROM df_hex
    GROUP BY hex
)
SELECT
    hex,
    POP,
    POP * 100.0 / SUM(POP) OVER () AS pct
FROM agg
ORDER BY POP DESC
"""

hex_df = con.sql(query).df()
```

## Raster to Hex

This example uses [AWS's Terrain Tiles](https://registry.opendata.aws/terrain-tiles/) tiled GeoTiff data. Hexagons show elevation data:

<iframe 
  src="https://www.fused.io/server/v1/realtime-shared/fsh_5o5UNLYxDNTN5ldzVFkeuR/run/file"
  width="100%"
  height="600px"
  frameBorder="0"
  style={{borderRadius: '8px'}}
></iframe>

Link to UDF in [Fused Catalog](https://github.com/fusedio/udfs/tree/966a45f/community/sina/DEM_Tile_Example/)

<details>
<summary>Code Details</summary>
```python showLineNumbers
@fused.udf
def udf(bounds: fused.types.Bounds = [-90.691,-21.719,-21.300,75.897], stats_type="mean", type='hex', color_scale:float=1):
    import pandas as pd
    import rioxarray

    common = fused.load("https://github.com/fusedio/udfs/tree/b7637ee/public/common/")
    # convert bounds to tile
    tile = common.get_tiles(bounds, clip=True)

    # 1. Initial parameters
    x, y, z = tile.iloc[0][["x", "y", "z"]]
    url = f"https://s3.amazonaws.com/elevation-tiles-prod/geotiff/{z}/{x}/{y}.tif"
    if type=='png':
        return url_to_plasma(url, min_max=(-1000,2000/color_scale**0.5), colormap='plasma')
    else:
        
        res_offset = 1  # lower makes the hex finer
        h3_size = max(min(int(3 + z / 2), 12) - res_offset, 2)
        print(h3_size)
    
        # 2. Read tiff
        da_tiff = rioxarray.open_rasterio(url).squeeze(drop=True).rio.reproject("EPSG:4326")
        df_tiff = da_tiff.to_dataframe("data").reset_index()[["y", "x", "data"]]
    
        # 3. Hexagonify & aggregate
        df = aggregate_df_hex(
            df_tiff, h3_size, latlng_cols=["y", "x"], stats_type=stats_type
        )
        df["elev_scale"] = int((15 - z) * 1)
        df["metric"]=df["metric"]*color_scale
        df = df[df["metric"] > 0]
        return df



def url_to_plasma(url, min_max=None, colormap='plasma'):
    common = fused.load("https://github.com/fusedio/udfs/tree/b7637ee/public/common/")

    return common.arr_to_plasma(common.url_to_arr(url).squeeze(), min_max=min_max, colormap=colormap, reverse=False)


@fused.cache
def df_to_hex(df, res, latlng_cols=("lat", "lng")):  
    common = fused.load("https://github.com/fusedio/udfs/tree/b7637ee/public/common/")
    qr = f"""
            SELECT h3_latlng_to_cell({latlng_cols[0]}, {latlng_cols[1]}, {res}) AS hex, ARRAY_AGG(data) as agg_data
            FROM df
            group by 1
          --  order by 1
        """
    con = common.duckdb_connect()
    return con.query(qr).df()


@fused.cache
def aggregate_df_hex(df, res, latlng_cols=("lat", "lng"), stats_type="mean"):
    import pandas as pd

    df = df_to_hex(df, res=res, latlng_cols=latlng_cols)
    if stats_type == "sum":
        fn = lambda x: pd.Series(x).sum()
    elif stats_type == "mean":
        fn = lambda x: pd.Series(x).mean()
    else:
        fn = lambda x: pd.Series(x).mean()
    df["metric"] = df.agg_data.map(fn)
    return df

```
</details>

### Requirements

- Raster Dataset (in this case [AWS's Terrain Tiles](https://registry.opendata.aws/terrain-tiles/)):

```bash
                y           x  data
0       84.776183 -179.725474 -2191
1       84.776183 -179.176421 -2176
2       84.776183 -178.627369 -2176
```

- Passing the [viewport `bounds`](/tutorials/Geospatial%20with%20Fused/filetile/#bounds)

```python showLineNumbers
bounds: fused.types.Bounds = [-90.691,-21.719,-21.300,75.897]
```

### Logic

1. Get tile & hex resolution

```python showLineNumbers
x, y, z = tile.iloc[0][["x", "y", "z"]]
url = f"https://s3.amazonaws.com/elevation-tiles-prod/geotiff/{z}/{x}/{y}.tif"

res_offset = 1  # lower makes the hex finer
h3_size = max(min(int(3 + z / 2), 12) - res_offset, 2)
```

2. Read array & return as dataframe

```python showLineNumbers
da_tiff = rioxarray.open_rasterio(url).squeeze(drop=True).rio.reproject("EPSG:4326")
df_tiff = da_tiff.to_dataframe("data").reset_index()[["y", "x", "data"]]
```

3. Hexagonify & aggregate

```python showLineNumbers
df = df_tiff
res = h3_size
latlng_cols=("lat", "lng")

# duckdb query 
qr = f"""
        SELECT h3_latlng_to_cell({latlng_cols[0]}, {latlng_cols[1]}, {res}) AS hex, ARRAY_AGG(data) as agg_data
        FROM df
        group by 1
    """
```

4. Aggregate 

```python showLineNumbers
@fused.cache
def aggregate_df_hex(df, res, latlng_cols=("lat", "lng"), stats_type="mean"):
    import pandas as pd

    df = df_to_hex(df, res=res, latlng_cols=latlng_cols)
    if stats_type == "sum":
        fn = lambda x: pd.Series(x).sum()
    elif stats_type == "mean":
        fn = lambda x: pd.Series(x).mean()
    else:
        fn = lambda x: pd.Series(x).mean()
    df["metric"] = df.agg_data.map(fn)
    return df
```