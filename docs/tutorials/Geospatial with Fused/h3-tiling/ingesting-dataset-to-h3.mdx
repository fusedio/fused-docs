---
slug: ingesting-dataset-to-h3
title: Ingesting Dataset to H3
authors: [fused]
tags: [h3, geospatial]
sidebar_position: 4
---

# Ingesting Dataset to H3

## Vector to Hex

Example of ingesting a release of the Overture Building dataset to H3 hexagons:

:::note Run this in a notebook or a Python shell, not in Workbench

The following is similar to a [vector dataset ingestion](/tutorials/Geospatial%20with%20Fused/geospatial-data-ingestion/ingest-your-data), running on [batch jobs](/core-concepts/run-udfs/run_large/). 

Therefore we recommend running this in a notebook or a Python shell, not in Workbench.

:::

```python showLineNumbers
# Run this in a notebook or a Python shell, not in Workbench
username = fused.api.whoami() # Getting username to save data in your own S3 bucket
release = '2025-01-22-0'
```

```python showLineNumbers
# Run this in a notebook or a Python shell, not in Workbench
args = [{'input_path': f's3://us-west-2.opendata.source.coop/fused/overture/{release}/theme=buildings/type=building/',
         'output_path': f's3://fused-users/fused/{username}/overture_overview/{release}/',
         'hex_res': 11}]
```

In this example we'll be simply [counting the number of buildings](https://github.com/fusedlabs/fusedudfs/blob/main/Overture_Hexify/Overture_Hexify.py#L36-L39) per hexagon.

```python showLineNumbers
# Run this in a notebook or a Python shell, not in Workbench
Overture_Hexify = fused.load("https://github.com/fusedlabs/fusedudfs/tree/main/Overture_Hexify/")
j = Overture_Hexify(arg_list=args)

j.run_remote(instance_type='r5.16xlarge', disk_size_gb=999)
```

Reading the ingested data becomes a lot simpler & faster:

<iframe 
  src="https://www.fused.io/server/v1/realtime-shared/fsh_1P5dqTKyPeryNpoPslct0o/run/file"
  width="100%"
  height="600px"
  frameBorder="0"
  style={{borderRadius: '8px'}}
></iframe>

<details>
<summary>Code</summary>
```python showLineNumbers
common = fused.load("https://github.com/fusedio/udfs/blob/main/public/common/")
@fused.udf
def udf(bounds: fused.types.Bounds = [-122.71963771127753,36.53196328805067,-120.70395948802646,38.082911654639275]):
    res = bounds_to_res(bounds)
    print(res)
    releases = ['2024-02-15-alpha-0', '2024-03-12-alpha-0', '2024-08-20-0', '2024-09-18-0', '2024-10-23-0', '2024-11-13-0', '2024-12-18-0', '2025-01-22-0', '2025-03-19-1', '2025-04-23-0', '2025-05-21-0']
    release1 = releases[-1]
    df1 = common.read_hexfile(bounds, f"s3://fused-users/fused/sina/overture_overview/{release1}/hex{res}.parquet", clip=True)

    return df1

@fused.cache
def bounds_to_res(bounds, res_offset=0, max_res=14, min_res=3):
    z = common.estimate_zoom(bounds)
    return max(min(int(3 + max(0, z - 3) / 1.7 + res_offset), max_res), min_res)
```
</details>


## Raster to H3

The `fused` package includes functionality to automate the ingestion of raster data
to an H3 dataset, through [`fused.h3.run_ingest_raster_to_h3()`](/python-sdk/api-reference/h3/#fusedh3run_ingest_raster_to_h3).

In the following example, we will illustrate the usage of this function by
ingesting a small Digital Elevation Model (DEM) file for the New York City
region, available at `"s3://fused-asset/data/nyc_dem.tif"` (see in [File
Explorer](https://www.fused.io/workbench/files?path=s3%3A%2F%2Ffused-asset%2Fdata%2Fnyc_dem.tif)).

The basic ingestion can be triggered from Workbench by running the following UDF:

```python showLineNumbers
@fused.udf
def udf():
    src_path = "s3://fused-asset/data/nyc_dem.tif"
    output_path = "s3://fused-users/fused/joris/nyc_dem_h3/"  # <-- update this path

    # run the ingestion process
    result_extract, result_partition = fused.h3.run_ingest_raster_to_h3(
        src_path, output_path, metrics=["avg"],
    )

    # verify that the ingestion finished succesfully,
    # and if not, print the error to help debugging
    if not result_extract.all_succeeded():
        print(result_extract.errors())
    if result_partition is not None and not result_partition.all_succeeded():
        print(result_partition.errors())
```

What is required to run this:
- Your input data (`src_path`) needs to be available in a raster format (e.g. a
  TIFF file, any raster format readable by GDAL) on S3.
- Specify a writeble location on S3 as the output directory (`output_path`)
- Specify the metrics to compute per H3 cell: typically, multiple multiple pixel
  values from the input raster data will be used to calculate the value for a
  certain H3 cell. In this case of a DEM, we want the average pixel value
  (`metrics=["avg"]`).

Important to understand is that the `run_ingest_raster_to_h3` function will run
multiple UDFs under the hood to perform the separate steps of the ingestion
process in parallel. Therefore, the above UDF itself does not need much
resources (the heavy lifting is done in the UDF runs it spawns) but can take
longer than the 2-min limit of [realtime UDF runs](/core-concepts/run-udfs/run-small-udfs#defining-realtime-udf-runs).

For this small example, it runs fine on realtime. But for larger data, we will
typically run this main UDF using a ["small" batch
instance](/core-concepts/run-udfs/run_large#running-a-job-from-workbench).

```python showLineNumbers
# highlight-start
@fused.udf(instance_type="small")
# highlight-end
def udf():
    src_path = "s3://fused-asset/data/nyc_dem.tif"
    ...
```

### What data did it create?

The [`run_ingest_raster_to_h3`](/python-sdk/api-reference/h3/#fusedh3run_ingest_raster_to_h3) function will write a set of files to the specified
output directory:

- A number of Parquet files with the actual ingested data
  (`577234808489377791.parquet` in the example, but typically this will be
  multiple files)
- A single `_sample` metadata file, with information about the files and chunks
  that can help speed up reading a subset of the data.
- Overview files in the `/overview` sub-directory, such as `hex3.parquet` for
  the overview at H3 resolution 3.

For the NYC DEM example, this looks like:

![Files created by the ingestion process](/img/tutorials/geospatial/raster_to_h3_nyc_dem.png)

See an example of the ingested elevation data in [File
Explorer](https://www.fused.io/workbench/udf/files?path=s3%3A%2F%2Ffused-asset%2Fhex%2Fnyc_dem%2F).

### Reading and visualizing the H3 dataset

Both the data and overview files are Parquet files that can be read individually
by any tool supporting the Parquet format. To make this easier, the example below
uses the `read_h3_dataset` utility, that will automatically choose between reading
a subset of actual data files vs overview files based on the viewport (`bounds`).

```python showLineNumbers
@fused.udf
def udf(
    bounds: fused.types.Bounds = [-74.556, 40.400, -73.374, 41.029],  # Default to full NYC
    res: int = None,
):
    path = "s3://fused-users/fused/joris/nyc_dem_h3/"

    # highlight-start
    utils = fused.load("https://github.com/fusedio/udfs/tree/7a33f4b/community/joris/Read_H3_dataset/")
    df = utils.read_h3_dataset(path, bounds, res=res)
    # highlight-start

    print(df.head())
    return df
```

```
using resolution 7
                  hex   data_avg
0  608725921037287423  13.776936
1  608725921054064639  14.747111
2  608725921070841855  21.287103
3  608725921087619071  17.117635
4  608725921104396287   3.297785
```

The data includes a `"hex"` column with the H3 cell ids at a specific
resolution, and one or more columns derived from the raster data. In this case
we have a single `"data_avg"` column with the average height in the H3 cell.

We can visualize the data with DeckGL using the `map_utils` helper:

```python showLineNumbers
@fused.udf
def udf(
    bounds: fused.types.Bounds = [-74.556, 40.400, -73.374, 41.029],  # Default to full NYC
    res: int = 9,
):
    path = "s3://fused-users/fused/joris/nyc_dem_h3/"

    utils = fused.load("https://github.com/fusedio/udfs/tree/7a33f4b/community/joris/Read_H3_dataset/")
    df = utils.read_h3_dataset(path, bounds, res=res)

    map_utils = fused.load("https://github.com/fusedio/udfs/tree/7a33f4b/community/milind/map_utils")

    config = {
        "hexLayer": {
            "@@type": "H3HexagonLayer",
            "filled": True,
            "pickable": True,
            "extruded": False,
            "opacity": 0.25,
            "getHexagon": "@@=properties.hex",
            "getFillColor": {
                "@@function": "colorContinuous",
                "attr": "data_avg",
                "domain": [0, 400],
                "steps": 20,
                "colors": "BrwnYl"
            }
        }
    }
    return map_utils.deckgl_hex(
        df, 
        config=config
    )
```

<iframe 
  src="https://unstable.udf.ai/fsh_a5N9mw6GSbjNbR1U7UKXx.html"
  width="100%"
  height="600px"
  frameBorder="0"
  style={{borderRadius: '8px'}}
></iframe>

## Specifying the metrics

In the basic DEM example above, we specified `metrics=["avg"]` to get the average
height for each H3 cell.

In general, when converting the raster data to H3, an H3 cell can cover
(partially) multiple pixels from the raster, and thus an aggregation is needed
to calculate the resulting data point for the given H3 cell.

The type of aggregation best suited will depend on the kind of raster data:

- `"cnt"`: for raster with discrete or categorical pixel values, e.g. as land
  use data, specify `metric="cnt"` to get a count per category for each H3 cell.
  This results in a "data" column with the category, a "cnt" column with the
  count for that category, and a "cnt_total" column with a sum of the counts per
  H3 cell (which allows to calculate the fraction of the H3 cell that is covered
  by a certain category).
- `"avg"`: for raster data where each pixel represents the average value for
  that area, e.g. temperate, elevation or population density, the average gets
  preserved when converting to H3 cell areas (using a weighted average).
- `"sum"`: for raster data where each pixel represents the total of the variable
  for that area, e.g. population counts, use the sum metric to preserve sums.

In addition, also the `"min"`, `"max"` and `"stddev"` metrics are supported to
calculate the minimum, maximum and standard deviation, respectively, of the
pixel values covered by the H3 cell. Those metrics can be combined with
calculating sums or averages, e.g. `metrics=["avg", "min", "max"]`, while the
`"cnt"` metric cannot be combined with any other metric, currently.

While the H3 cells at the data resolution might not cover that many pixel values
(by default a resolution is chosen that matches the pixel area as close as
possible), but note that those aggregations are also used for creating the
overview files when aggregating the higher resolution H3 cells to lower
resolution data.

### Counting raster values

For raster with discrete or categorical pixel values, e.g. as land use data, the
`"cnt"` metric will count the number of occurences per catgory for each H3 cell.

This results in a "data" column with the category (i.e. original pixel values),
a "cnt" column with the count for that category, and a "cnt_total" column with a
sum of the counts per H3 cell (which allows to easily calculate the fraction of
the H3 cell that is covered by a certain category).

Illustrating this with the example of ingested Cropland Data Layer (CDL) data,
the resulting dataset looks like:

<details>
<summary>Code</summary>
```python showLineNumbers
@fused.udf
def udf(
    bounds: fused.types.Bounds = [-73.983, 40.763, -73.969, 40.773],  # Default to a small area in NYC
    res: int = None,
):
    # Cropland Data Layer (CDL) data, crop-specific land cover data layer
    # provided by the USDA National Agricultural Statistics Service (NASS).
    # Ingested using the "cnt" metric, counting the occurence of the land cover classes
    path = "s3://fused-asset/hex/cdls_v8/year=2024/"

    utils = fused.load("https://github.com/fusedio/udfs/tree/79f8203/community/joris/Read_H3_dataset")
    df = utils.read_h3_dataset(path, bounds, res=res)

    print(df.head())
    return df
```
</details>

```
                  hex  data  cnt  cnt_total
0  626740321835323391   122   12         14
1  626740321835323391   123    1         14
2  626740321835323391   121    1         14
3  626740321835327487   122    9         17
4  626740321835327487   121    4         17
```

Important to note: each H3 cell id can occur multiple times in the data in this
case, because we have one row per category ("data") that occurs in that specific
H3 cell.

In the example above, you can see the first H3 cell (626740321835323391)
occuring 3 times, having counts for three categories (121, 122, 123).
