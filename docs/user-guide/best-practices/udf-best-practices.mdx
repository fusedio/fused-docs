---
id: udf-best-practices
title: Making the most out of UDFs
sidebar_label: Building & Running UDFs
sidebar_position: 0
---

_An opinionated guide to making the most out of Fused UDFs_

# Build & Running UDFs

[Fused UDFs](/core-concepts/write/) are Python functions that run on serverless compute and can be called from anywhere with `fused.run(my_udf)`. This guide is a resource meant to help you on your way to making the most out of UDFs.

## A short reminder: The anatomy of a UDF

A Fused UDF can be very simple:

```python showLineNumbers
@fused.udf
def udf(my_awesome_input: int = 1):
    import pandas as pd

    return pd.DataFrame({"Look at my output: ": [my_awesome_input]})
```

Each UDF has a few specific elements:
- The [`@fused.udf` decorator](/core-concepts/write/#fusedudf-decorator)
- Arguments -ideally typed-
- imports _inside_ the function
- Some logic
- A [supported `return` object](/core-concepts/write/#return-object)

:::note
All of this is explained in the ["Write UDF"](/core-concepts/write/) section in much more details
:::

You can then run UDFs from _anywhere_ you have access to Python with `fused.run(udf)`. These are still Python functions, so there are some things to keep in mind to keep them fast & efficient

## Writing efficient UDFs

### Keep things small

UDFs run on Python serverless compute, but [quickly timeout](/core-concepts/run-udfs/run-small-udfs/#defining-small-job). The main benefit of Fused UDFs is how responsive they are. And the best way to do that is to keep things fast is to keep them small:

- Break pipelines into single tasks UDFs
- [Leverage `fused.run()`](/user-guide/best-practices/udf-best-practices/#leverage-fusedrun) to chain together UDFs

<details>
    <summary>Example: Breaking down a complex pipeline into smaller UDFs</summary>

    ❌ Not recommended:

    ```python showLineNumbers
    @fused.udf
    def inefficient_pipeline_udf(data_path):
        import pandas as pd

        df = pd.read_csv(data_path)
        # Some complicated processing logic to create df_processed
        # ...

        return processed_df
    ```

    ✅ Instead, break it down:

    ```python showLineNumbers
    @fused.udf
    def load_data_udf(data_path):
        import pandas as pd
        return pd.read_csv(data_path)
    ```

    ```python showLineNumbers
    @fused.udf
    def process_data_udf(df):
        import pandas as pd
        # Some complicated processing logic to create df_processed
        # ...
        return processed_df
    ```

    ```python showLineNumbers
    @fused.udf
    def pipeline_udf(data_path):
        import pandas as pd

        df = fused.run(load_data_udf, data_path=data_path)
        processed_df = fused.run(process_data_udf, df=df)

        return processed_df
    ```
</details>

### Run often, Iterate quickly

Just like writing short cells when developing in a Jupyter Notebook, we recommend you keep your UDFs short & fast to execute

You should aim for: **UDFs that take 30s - 1min to run**

UDFs run with [`fused.run()`](/core-concepts/run-udfs/run-small-udfs/#fusedrun) [timeout after 120s](/core-concepts/run-udfs/run-small-udfs/#defining-small-job) so we recommend you keep a buffer in case your UDF takes a bit longer to execute

![UDF Design Guidelines](/static/img/user-guide/best-practices/udf_design_timing.png)

{/* Each time you run [`fused.run(my_udf)`](/core-concepts/run-udfs/run-small-udfs/#fusedrun), your UDF is sent out to our serverless server to compute and the [`return` object](/core-concepts/write/#return-object) is sent back to you. When developing we really recommend you start really small and build from there: */}

{/* TODO: Need a good example of this, show people what this could look like */}

### [Cache](/core-concepts/cache/) as much as you can

### Prepare your large datasets

### Don't start from scratch: [UDF Catalog](/workbench/udf-catalog/)

## Debugging UDFs 

### Use `print()`

### Use `time.time()`

## Leverage `fused.run()`

{/* 
Topics:
- Writing efficient UDFs
    - Cache as much as possible, but only when inputs & function don't change
    - Typing your inputs as much as possible
    - Aim for short jobs -> about 30s-1min so your jobs don't timeout
        - Use other UDFs if you're doing multiple operations
- Debugging UDFs
    - print statement with `print(f"{val=}")`
    - Use time.time() to find slow parts of your UDF if you're unsure about what's taking time
- Use workbench for exploration if you want a map view
- Using UDFs for all sorts of tasks
    - Leverage other UDFs to offload big tasks while staying in your local development
    - Leverage `fused.run()` locally to keep working in your favourite env
        - `fused.load()` + `fused.render()` in notebooks
- Don't hesitate to play around with `fused.run_remote()` for large jobs
*/}

{/* 
For more:
- Write UDFs page
- Run UDFs
- Check examples for specific applications
 */}


