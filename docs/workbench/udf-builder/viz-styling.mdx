---
id: styling
title: Layer Styling
tags: [styling]
sidebar_position: 3
toc_min_heading_level: 2
toc_max_heading_level: 6
---

# Layer Styling: Visualization 

The UDF builder displays data from your UDF on the map. You can customize the visual representation using the visualization icon located on the map.

import ReactPlayer from 'react-player';

<ReactPlayer className="video__player" playing={false} muted={true} controls height="100%" url="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/docs_rewrite/visualization_open_edit4.mp4" width="100%" />

## Overview

Fused's visualization system is built on [DeckGL](https://deck.gl/docs), a powerful JavaScript framework for large-scale geospatial data visualizations. The system uses a three-layer architecture that automatically selects the appropriate rendering method based on your UDF output.

### Layer Architecture

Every Visualization uses this JSON structure:

```javascript
{
  "tileLayer": {
    "@@type": "TileLayer",        // For viewport-optimized rendering
    "minZoom": 0,
    "maxZoom": 19,
    "tileSize": 256,
    "pickable": true
  },
  "rasterLayer": {
    "@@type": "BitmapLayer",      // For raster data (images, arrays)
    "pickable": true
  },
  "vectorLayer": {
    "@@type": "GeoJsonLayer",     // For vector data (GeoDataFrames)
    "stroked": true,
    "filled": true,
    "pickable": true
  }
}
```

### File vs Tile Rendering

- **Tile Mode**: Uses `TileLayer` for large datasets, only rendering data visible in the current viewport
- **File Mode**: Renders complete datasets using `rasterLayer` or `vectorLayer` directly

Fused automatically selects the appropriate layer based on your UDF output type.

### Default Map View

You can set a default map view that automatically centers on your data:

import Imgdefaultviewstate from '/img/workbench/layer-styling/default_map_view.png';

<div style={{textAlign: 'center'}}>
<img src={Imgdefaultviewstate} alt="Default map view settings" style={{width: 800}} />
</div>

**Presets**

Use the "Preset" button to quickly generate styling configurations. You can always undo changes with `Ctrl + Z`.

![Preset button](/img/workbench/layer-styling/surprise_me.png)

## Layer Types

### Vector: GeoJsonLayer

Use for `GeoDataFrame` outputs or any `DataFrame` with a geometry column. Supports dynamic styling based on data properties.

![File](/img/workbench/layer-styling/surprise_me.png)

**Expected DataFrame structure:**
| geometry | value | building_type |
|----------|-------|---------------|
| POLYGON(...) | 25 | residential |
| POLYGON(...) | 45 | commercial |
| POLYGON(...) | 12 | industrial |

<details>
  <summary>Expand to see Visualise code</summary>
  ```json
  {
    "tileLayer": {
      "@@type": "TileLayer",
      "minZoom": 0,
      "maxZoom": 19,
      "tileSize": 256,
      "pickable": true
    },
    "rasterLayer": {
      "@@type": "BitmapLayer",
      "pickable": true
    },
    "vectorLayer": {
      // highlight-next-line
      "@@type": "GeoJsonLayer",
      "stroked": true,
      "filled": true,
      "pickable": true,
      "extruded": false,
      "lineWidthMinPixels": 1,
      // highlight-next-line
      "getFillColor": [100, 150, 200, 180],
      "getLineColor": [50, 50, 50, 255]
    }
  }
  ```
</details>

**Key Properties:**
- `stroked`: Show polygon/line outlines
- `filled`: Fill polygon interiors
- `extruded`: Enable 3D elevation effects
- `pickable`: Enable hover tooltips and interaction

### Vector: H3HexagonLayer

Use for `DataFrame` outputs with H3 hexagon indices (no geometry column required).

<iframe
  id="h3_demo_preview"
  loading="lazy"
  src="/img/deckgl_h3.html"
  height="300px"
  width="100%"
  scrolling="no"
></iframe>

**Expected DataFrame structure:**
| hex | population | metric |
|-----|------------|--------|
| 8a2a1072b59ffff | 1250 | 45.2 |
| 8a2a1072b5bffff | 890 | 32.1 |
| 8a2a1072b5dffff | 2100 | 67.8 |

<details>
  <summary>Expand to see Visualise code</summary>
  ```json
  {
    "tileLayer": {
      "@@type": "TileLayer",
      "minZoom": 0,
      "maxZoom": 19,
      "tileSize": 256,
      "pickable": true
    },
    "rasterLayer": {
      "@@type": "BitmapLayer",
      "pickable": true
    },
    "vectorLayer": {
      // highlight-next-line
      "@@type": "H3HexagonLayer",
      "stroked": true,
      "filled": true,
      "pickable": true,
      "extruded": false,
      "opacity": 1,
      "coverage": 0.9,
      "lineWidthMinPixels": 5,
      // highlight-next-line
      "getHexagon": "@@=properties.hex",
      "getFillColor": [255, 165, 0, 180],
      "getLineColor": [200, 200, 200, 255]
    }
  }
  ```
</details>

**Required Property:**
- `getHexagon`: Specify the DataFrame column containing H3 indices (e.g., `"@@=properties.hex"`)

**Example UDF**
- [DuckDB H3 Example](https://www.fused.io/workbench/udf/catalog/DuckDB_H3_SF-1139e998-0e09-4b73-b366-e2d406728341)

### Raster: BitmapLayer

Use for raster outputs like satellite imagery, elevation models, or PNG files.

![Crops](/img/workbench/layer-styling/crops.png)

**Expected UDF output:**
| Output Type | Description | Example |
|-------------|-------------|---------|
| numpy array | 3D array (height, width, channels) | `(256, 256, 3)` RGB image |
| PIL Image | PNG/JPEG image object | `Image.open('satellite.png')` |
| bytes | Encoded image data | PNG/JPEG bytes |

<details>
  <summary>Expand to see Visualise code</summary>
  ```json
  {
    "tileLayer": {
      "@@type": "TileLayer",
      "minZoom": 0,
      "maxZoom": 19,
      "tileSize": 256,
      "pickable": true
    },
    "rasterLayer": {
      // highlight-next-line
      "@@type": "BitmapLayer",
      "pickable": true
    },
    "vectorLayer": {
      "@@type": "GeoJsonLayer",
      "pickable": true
    }
  }
  ```
</details>

:::tip Transparency Guidelines
**Raster Images:**
- **RGB images**: Black pixels (0,0,0) are automatically transparent
- **RGBA images**: Use the alpha channel for transparency control

**Vector Colors:**
- **Good opacity**: Use 180-255 for visible features (e.g., `[255, 100, 100, 200]`)
- **Avoid low opacity**: Values below 100 make features barely visible (e.g., `[255, 255, 255, 25]`)
- **Solid colors**: Omit alpha for full opacity (e.g., `[255, 100, 100]`)
:::

![Raster example](/img/workbench/layer-styling/crops.png)

**Example UDF**
- [CDLs Tile Example](https://www.fused.io/workbench/udf/catalog/CDLs_Tile_Example-a9f78d6d-4820-44ac-9032-5d19591e1a55)

## Color Styling Methods

There are four ways to style colors in Fused. Each method serves different use cases:

### 1. Hardcoded Colors

Use fixed RGB/RGBA values for uniform styling.

import ImgSingleColor from '@site/static/img/viz_single.png';

<div style={{ textAlign: 'center' }}>
<img src={ImgSingleColor} alt="File" style={{ width: '80%'}} />
</div>

**Expected DataFrame structure:**
| geometry | any_column |
|----------|------------|
| POLYGON(...) | any_value |
| POLYGON(...) | any_value |

*Note: Column values don't affect styling - all features get the same color.*

<details>
  <summary>Expand to see Visualise code</summary>
  ```json
  {
    "tileLayer": {
      "@@type": "TileLayer",
      "minZoom": 0,
      "maxZoom": 19,
      "tileSize": 256,
      "pickable": true
    },
    "rasterLayer": {
      "@@type": "BitmapLayer",
      "pickable": true
    },
    "vectorLayer": {
      "@@type": "GeoJsonLayer",
      "stroked": true,
      "filled": true,
      "pickable": true,
      "lineWidthMinPixels": 1,
      // highlight-next-line
      "getFillColor": [20, 200, 200, 100],
      "getLineColor": [50, 50, 50, 255]
    }
  }
  ```
</details>

**When to use:** Simple visualizations, proof of concepts, or when all features should look identical.

### 2. Property-Based Colors

Use data column values to calculate colors dynamically.

import ImgProperty from '@site/static/img/viz_property.png';

<div style={{ textAlign: 'center' }}>
<img src={ImgProperty} alt="File" style={{ width: '80%'}} />
</div>

**Expected DataFrame structure:**
| geometry | value | height |
|----------|-------|--------|
| POLYGON(...) | 5 | 25 |
| POLYGON(...) | 8 | 40 |
| POLYGON(...) | 3 | 15 |

*Note: Numerical columns are used directly in color calculations.*

<details>
  <summary>Expand to see Visualise code</summary>
  ```json
  {
    "tileLayer": {
      "@@type": "TileLayer",
      "minZoom": 0,
      "maxZoom": 19,
      "tileSize": 256,
      "pickable": true
    },
    "rasterLayer": {
      "@@type": "BitmapLayer",
      "pickable": true
    },
    "vectorLayer": {
      "@@type": "GeoJsonLayer",
      "stroked": true,
      "filled": true,
      "pickable": true,
      "extruded": true,
      // highlight-next-line
      "getElevation": "@@=properties.value * 10",
      "lineWidthMinPixels": 1,
      // highlight-next-line
      "getFillColor": "@@=[properties.value * 50, properties.value * 30, properties.value * 2]",
      "getLineColor": [50, 50, 50, 255]
    }
  }
  ```
</details>

**When to use:** When you want colors to directly reflect data values with custom calculations.

**Example UDF**
- [DuckDB NYC Example](https://www.fused.io/workbench/udf/catalog/DuckDB_NYC_Example-a19d8f4c-d839-47f7-9be3-7dc8b3d03115)

### 3. Conditional Colors with `hasProp`

Handle missing data gracefully with fallback colors.

**Expected DataFrame structure:**
| geometry | value | status |
|----------|-------|--------|
| POLYGON(...) | 25 | active |
| POLYGON(...) | NaN | inactive |
| POLYGON(...) | 15 | active |

*Note: Can handle missing/null values with fallback styling.*

<details>
  <summary>Expand to see Visualise code</summary>
  ```json
  {
    "tileLayer": {
      "@@type": "TileLayer",
      "minZoom": 0,
      "maxZoom": 19,
      "tileSize": 256,
      "pickable": true
    },
    "rasterLayer": {
      "@@type": "BitmapLayer",
      "pickable": true
    },
    "vectorLayer": {
      "@@type": "GeoJsonLayer",
      "stroked": true,
      "filled": true,
      "pickable": true,
      "extruded": true,
      "getElevation": {
        // highlight-next-line
        "@@function": "hasProp",
        "property": "value",
        "present": "@@=properties.value",
        "absent": 1
      },
      "lineWidthMinPixels": 1,
      "getFillColor": {
        // highlight-next-line
        "@@function": "hasProp",
        // highlight-next-line
        "property": "value",
        // highlight-next-line
        "present": "@@=[properties.value * 50, properties.value * 3, properties.value * 2]",
        // highlight-next-line
        "absent": [255, 0, 255]
      }
    }
  }
  ```
</details>

**When to use:** When your data might have missing values and you need reliable fallbacks.

### Understanding `hasProp` Function

The `hasProp` function is a core Fused utility for conditional styling based on data property presence. It's the foundation for handling missing or null values gracefully in visualizations.

**How it works:**
```json
"getFillColor": {
  "@@function": "hasProp",
  "property": "metric",
  "present": "@@=[255, (1 - properties.metric/500) * 255, 0]",
  "absent": [220, 255, 100]
}
```

**Key Properties:**
- `"@@function": "hasProp"`: Declares the conditional function
- `"property": "column_name"`: Specifies which DataFrame column to check
- `"present": expression`: Styling when the property exists and is not null
- `"absent": value`: Fallback styling when the property is missing or null

**Common Use Cases:**
- **Missing data**: Handle null/NaN values in datasets
- **Optional columns**: Style features that may not have certain attributes
- **Data validation**: Provide visual feedback for incomplete records
- **Progressive enhancement**: Add styling layers based on data availability

**Example with elevation:**
```json
"getElevation": {
  "@@function": "hasProp",
  "property": "height",
  "present": "@@=properties.height * 10",
  "absent": 1
}
```

This ensures buildings without height data still appear with a default elevation of 1 unit.

**Example UDF**
- [Ookla Download Speed](https://www.fused.io/workbench/udf/catalog/Ookla_Download_Speeds-12a8bc7e-5baf-4eac-b695-a4434cff0554)

### 4. Category Colors

Use predefined color palettes for categorical data.

import ImgCategory from '@site/static/img/viz_category.png';

<div style={{ textAlign: 'center' }}>
<img src={ImgCategory} alt="File" style={{ width: '80%'}} />
</div>

**Expected DataFrame structure:**
| geometry | building_type | zone |
|----------|---------------|------|
| POLYGON(...) | residential | A |
| POLYGON(...) | commercial | B |
| POLYGON(...) | industrial | A |

*Note: Categorical columns with distinct values for color mapping.*

<details>
  <summary>Expand to see Visualise code</summary>
  ```json
  {
    "tileLayer": {
      "@@type": "TileLayer",
      "minZoom": 0,
      "maxZoom": 19,
      "tileSize": 256,
      "pickable": true
    },
    "rasterLayer": {
      "@@type": "BitmapLayer",
      "pickable": true
    },
    "vectorLayer": {
      "@@type": "GeoJsonLayer",
      "stroked": true,
      "filled": true,
      "pickable": true,
      "lineWidthMinPixels": 1,
      "getFillColor": {
        // highlight-next-line
        "@@function": "colorCategories",
        // highlight-next-line
        "attr": "building_type",
        // highlight-start
        "domain": [
          "residential", 
          "commercial",
          "industrial",
          "public"
        ],
        // highlight-end
        "colors": "Bold"
      }
    }
  }
  ```
</details>

**When to use:** Categorical data like building types, land use classifications, or administrative regions.

:::warning
Note that unexpected behaviors may arise if too many domains are used.
:::

**Example UDF**
- [FEMA Buildings US](https://www.fused.io/workbench/udf/catalog/FEMA_Buildings_US-ae1feed0-215a-42b5-8cf4-d95f5c1216dc)

### 5. Continuous Color Scales

Use gradient color scales for continuous numerical data.

<div style={{ textAlign: 'center' }}>
  <img src="/img/workbench/layer-styling/color_continuous.png" alt="Color Continuous" style={{ width: '80%' }} />
</div>

**Expected DataFrame structure:**
| hex | population | density |
|-----|------------|---------|
| 8a2a1072b59ffff | 1250 | 45.2 |
| 8a2a1072b5bffff | 890 | 32.1 |
| 8a2a1072b5dffff | 2100 | 67.8 |

*Note: Numerical columns with values within the specified domain range.*

<details>
  <summary>Expand to see Visualise code</summary>
  ```json
  {
    "tileLayer": {
      "@@type": "TileLayer",
      "minZoom": 0,
      "maxZoom": 19,
      "tileSize": 256,
      "pickable": true
    },
    "rasterLayer": {
      "@@type": "BitmapLayer",
      "pickable": true
    },
    "vectorLayer": {
      // highlight-next-line
      "@@type": "H3HexagonLayer",
      "stroked": true,
      "filled": true,
      "pickable": true,
      "extruded": true,
      "opacity": 1,
      "coverage": 0.9,
      "lineWidthMinPixels": 5,
      // highlight-next-line
      "getHexagon": "@@=properties.hex",
      "getFillColor": {
        // highlight-next-line
        "@@function": "colorContinuous",
        // highlight-next-line
        "attr": "population",
        // highlight-next-line
        "domain": [0, 10000],
        "steps": 15,
        // highlight-next-line
        "colors": "SunsetDark",
        "nullColor": [184, 184, 184]
      },
      "getElevation": {
        "@@function": "hasProp",
        "property": "population",
        "present": "@@=properties.population / 100",
        "absent": 1
      },
      "elevationScale": 10
    }
  }
  ```
</details>

**When to use:** Continuous numerical data like population density, temperature, or elevation values.

**Example UDF**
- [DuckDB H3 Example](https://www.fused.io/workbench/udf/catalog/DuckDB_H3_SF-1139e998-0e09-4b73-b366-e2d406728341)


## Advanced Features

### 3D Visualization

Enable 3D effects by setting `extruded: true` and using `getElevation`:

**Expected DataFrame structure:**
| geometry | height_value | floors |
|----------|--------------|--------|
| POLYGON(...) | 45 | 15 |
| POLYGON(...) | 120 | 40 |
| POLYGON(...) | 30 | 10 |

*Note: Numerical columns used for building height/elevation in 3D view. Use `"@@=properties.column_name"` syntax to reference height data.*

<details>
  <summary>Expand to see Visualise code</summary>
  ```json
  {
    "tileLayer": {
      "@@type": "TileLayer",
      "minZoom": 0,
      "maxZoom": 19,
      "tileSize": 256,
      "pickable": true
    },
    "rasterLayer": {
      "@@type": "BitmapLayer",
      "pickable": true
    },
    "vectorLayer": {
      "@@type": "GeoJsonLayer",
      "stroked": true,
      "filled": true,
      "pickable": true,
      // highlight-next-line
      "extruded": true,
      "getElevation": "@@=properties.height_value * 5",
      // highlight-next-line
      "elevationScale": 10,
      "getFillColor": [100, 150, 200, 180]
    }
  }
  ```
</details>

:::tip
Hold `Cmd` (macOS) or `Ctrl` (Windows/Linux) while dragging to tilt the map view and see 3D effects.

You can try it out in the map right below this in the "Vector `H3HexagonLayer`" section above 👆
:::

**Example UDF**
- [DSM Zonal Stats](https://www.fused.io/workbench/udf/catalog/DSM_Zonal_Stats-0c801e56-d0c4-47e8-a5ce-90d37703bdb7)

### Debug Layers

Use `DebugTileLayer` with custom loading and error states for development:

<ReactPlayer playsinline={true} className="video__player" loop={true} playing={false} muted={true} controls height="100%" url="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/docs_rewrite/debug_layer7.mp4" width="100%" />

```json
{
  "tileLayer": {
    "@@type": "DebugTileLayer",
    "minZoom": 0,
    "maxZoom": 15,
    "tileSize": 256,
    "pickable": true
  },
  "loadingLayer": {
    "@@type": "GeoJsonLayer",
    "stroked": true,
    "filled": false,
    "pickable": true,
    "lineWidthMinPixels": 10,
    "getLineColor": [25, 55, 0, 255]
  },
  "errorLayer": {
    "@@type": "GeoJsonLayer",
    "stroked": true,
    "filled": true,
    "pickable": true,
    "lineWidthMinPixels": 10,
    "getLineColor": [255, 255, 0, 255],
    "getFillColor": [255, 20, 255, 40]
  }
}
```

### Performance Optimization

- **Zoom levels**: Set appropriate `minZoom` and `maxZoom` to control data loading
- **Line width units**: Use `lineWidthUnits: "pixels"` for consistent appearance across zoom levels  
- **Tile size**: Adjust `tileSize` for optimal performance with your data density

{/* NOTE: Commenting all of this out as the current interactive example doesn't allow to style the visualization. Need to select a UDF but not currently possible.*/}
{/* ## Interactive Example

You can explore styling in this live example:


<iframe
  id="udf_overture_example"
  src="https://www.fused.io/public/UDF_Overture_Maps_Example"
  style={{ width: '100%', height: '500px', border: 'none' }}
  title="Overture Maps Example"
/> */}

## FAQ: Debugging your visualizations

<details>
  <summary>Why is my vector layer not colorized?</summary>

  Let's take the example of a UDF that returns a `GeoDataFrame` with `hex` values:
  
  ```python showLineNumbers
  @fused.udf()
  def udf(
      bounds: fused.types.Bounds = None,
  ):  
      # get_hex() is a non-important function for this demo that gives us US counties
      df_hex = get_hex(gdf, hex_res)
      df_hex['state_id'] = [id[:2] for id in df_hex["GEOID"]]
      
      return df_hex 
  ```

  And our visualization JSON looks like this:
  ```json
    {
    "hexLayer": {
      "@@type": "H3HexagonLayer",
      "filled": true,
      "pickable": true,
      "extruded": false,
      "getHexagon": "@@=properties.hex",
      "getFillColor": {
        "@@function": "colorContinuous",
        "attr": "state_id",
        "domain": [
          0,
          50
        ],
        "steps": 2,
        "colors": "Magenta"
      }
    }
  }
  ```

  You should make sure:
  1. `hexLayer > getFillColor > attr` is set to a column that exists in the `GeoDataFrame` (in this case `state_id`)
  2. Make sure your `attr` column is in either `int` or `float` type, not in `str`. In this case we should cast `state_id` to `int`:

  ```python {7} showLineNumbers
  @fused.udf()
  def udf(
      bounds: fused.types.Bounds = None,
  ):
      df_hex = get_hex(gdf, hex_res)
      df_hex['state_id'] = [id[:2] for id in df_hex["GEOID"]]
      df_hex['state_id'] = df_hex['state_id'].astype(int)
      
      return df_hex 
  ```

  3. Making sure your values are within the correct domain (`hexLayer > getFillColor > domain`). In our case, we're showing US States, so the domain should be `[0, 50]`.

</details>

<details>
  <summary>Why are my 3D buildings not showing?</summary>

  **Common 3D visualization issues:**

  1. **Wrong elevation function**: Don't use distance functions like `haversine` for elevation
     ```json
     // ❌ Wrong - haversine is for distances
     "getElevation": {
       "@@function": "haversine",
       "attr": "HEIGHT"
     }
     
     // ✅ Correct - direct property reference
     "getElevation": "@@=properties.HEIGHT"
     ```

  2. **Missing required properties**: Ensure you have both `extruded: true` and a height column
     ```json
     "vectorLayer": {
       "@@type": "GeoJsonLayer",
       "extruded": true,
       "getElevation": "@@=properties.height_value",
       "elevationScale": 10
     }
     ```

  3. **Low transparency**: Avoid very low alpha values that make buildings invisible
     ```json
     // ❌ Too transparent (barely visible)
     "getFillColor": [255, 255, 255, 25]
     
     // ✅ Good visibility
     "getFillColor": [100, 150, 200, 180]
     ```

</details>

<details>
  <summary>Why is my layer not appearing at all?</summary>

  **Common visibility issues:**

  - **Pickable setting**: Check that `pickable: true` is set for interactivity
  - **Data type mismatch**: Verify your UDF returns the expected data type (`GeoDataFrame` for vector, `array` for raster)
  - **Zoom level issues**: Ensure zoom levels (`minZoom`, `maxZoom`) include your current map zoom level
  - **Missing geometry**: GeoJsonLayer requires a geometry column in your GeoDataFrame
  - **Incorrect layer type**: Make sure you're using the right `@@type` for your data (GeoJsonLayer vs H3HexagonLayer)

</details>

For more details on DeckGL properties, see the [DeckGL documentation](https://deck.gl/docs/api-reference/layers/geojson-layer#properties).