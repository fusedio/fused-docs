# Fused Documentation - Complete Reference

> Fused is an end-to-end cloud platform for data analytics, built around User Defined Functions (UDFs): Python functions that can be run via HTTPS requests from anywhere, without any install required.

This comprehensive reference contains the complete text of all Fused documentation, including all API methods, examples, tutorials, and guides.

================================================================================

# BLOG POSTS

## Introducing Fused AI Canvas
Path: blog/2025-10-30-intro-canvas/index.mdx
URL: https://docs.fused.io/blog/2025-10-30-intro-canvas

# Introducing Fused AI Canvas

Today we're introducing Fused AI Canvas, a new way to organize your UDFs on a free form canvas

## A Free Form Canvas

Organize & move your UDFs as you build your workflow on a free form canvas, allowing you to build analysis & workflows without being limited to a linear flow!

<img 
    style=}
    src="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/blogs/2025-10-30-intro-canvas/moving_elements_on_canvas.gif" 
    alt="Moving elements on canvas"
/>

## Create workflows

Fused Canvas still runs individual serverless UDFs but you can now more easily connect them together

<img 
    style=}
    src="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/blogs/2025-10-30-intro-canvas/connecting_udfs.gif" 
    alt="Connecting UDFs"
/>

## Share in 1 click

Share your work to anyone with a single click

<img 
    style=}
    src="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/blogs/2025-10-30-intro-canvas/share_in_one_link.gif" 
    alt="Share canvas"
/>

## Try it out

Try out Fused Canvas right away for free

================================================================================

## Building Geospatial Real-Time Analysis in Fused
Path: blog/2025-10-24-chris-webinar/index.mdx
URL: https://docs.fused.io/blog/2025-10-24-chris-webinar

Chris Kyed, Data Scientist at Pacific Spatial Solutions, showcases 3 real time geospatial analysis uses cases for Fused. 

Last year Chris showcased how Pacific Spatial uses Fused to analyze 100 Billion drive records. Pacific Spatial Solutions is a company that provides geospatial analysis & data science services for various industries in Japan.

### Ocean Health Mapping

River plumes carry nutrients/sediment to the ocean and are split in 2 broad categories:
- Good plume: natural sediment/nutrient redistribute & add biodiversity
- Bad plume: excessive sediment/waste water and toxins/agricultural fertilizer with negative biodiversity impacts

Mapping them can be helpful for understanding the health and human activities impact on the ocean.

[Image: Ocean health mapping]

These datasets are open and available through the Jaxa Earth API :
- Chlorophyll-a concentration (Daytime/Half-monthly)
- Sea surface temperature (Daytime/Half-monthly)
- Precipitation Rate (Half-monthly)

### Rainfall & Incidence Data

Traffic accidents and traffic safety has been one of the most important problems for the last many decades. Now that we have publicly accessible data regarding the accidents, we need to find ways to access and analyze it.

The Japanese National Police Agency published yearly traffic incidence data all around the country. 

- Index of Open data on traffic accident statistics

[Image: Japan incidence data]

Explore the code directly in Fused:
- Incidence Data as tiled H3
- Japanese Police Intersection Accidents

### Tokyo Shadow Map

Japanese summers can get very hot, which is amplified in large urban areas creating urban heat islands. 

Prolonged exposure to the sun can cause dehydration and sunstroke, so we want to give Tokyo residents and tourists an app that can help them navigate the city in a more comfortable way.

Pacific Spatial Solutions is creating shadow maps for the city of Tokyo by combining 121 point clouds in batch and transforming them into 0.5m resolution DSM data and dynamically rendering them in Fused:

[Image: Tokyo shadow maps]

- Online Japan Shadow Map
- 3D point cloud data

### Learn more about Fused

- Try out Fused for yourself for free!
- Dive deeper in the Geospatial with Fused tutorials
- Learn more about working with H3 Tiles

================================================================================

## Analytics is Changing (Again)
Path: blog/2025-08-01-analytics_is_changing/index.mdx
URL: https://docs.fused.io/blog/2025-08-01-analytics_is_changing

# Analytics is Changing (Again)

AI has revolutionized how we write code; now it's reshaping how data teams can work.

    className="video__player"
    playing=
    muted=
    controls
    height="450px"
    url="https://fused-magic.s3.us-west-2.amazonaws.com/blog-assets/from_udf_ai_to_dashboard_exploring_data_compressed.mp4"
    width="800px"
    style=}
/> */}

### Data + Compute + LLMs = Analytics at the Speed of Thought

The way we **interact with data changes constantly**; we only need to look at the last few years to see that we are seeing a shift as part of the "Great Decoupling‚Äù ‚Äì a broader movement toward zero-infrastructure. 

By adding Serverless Compute ‚Äì via **cloud functions** or the **browser** ‚Äì to formats like Apache Parquet and engines such as DuckDB, we unlock blazing fast analytics without clusters or VMs. Now AI is entering the mix, and we think this is the perfect timing to put all the pieces together.

We don‚Äôt think analysts, data engineers & scientists are going anywhere. We believe that ‚ÄúAI won‚Äôt replace you, a human using AI will‚Äù. AI amplifies the creativity and speed of the people already doing the work.

Here‚Äôs how we think the future of analytics looks like:

- **Data context limits hallucination**: Having LLMs know exactly about the structure and content of your data means AI is much less likely to hallucinate.
- **Code execution as validation**: AI code editors help write code, but can‚Äôt actually run it. At Fused we‚Äôre building on top of our real time execution engine, so errors in code are spotted and fixed much faster, all in the same workflow.
- **Human analysts to guide the work**: LLMs can write every possible query imaginable to parse a dataset, or make whichever chart you want. Answering the questions becomes easier, so asking the right questions becomes more valuable.

[Image: Three ways working with AI is changing analytics]

### So... What is Vibe Analytics?

A few months ago Andrej Karpathy coined the term Vibe Coding: letting LLMs loose and just give in to whatever code suggestion comes around, to quickly get a prototype of a new project, specifically for web development.

We‚Äôve since seen the term Vibe Analytics starting to pop up around, applying a similar approach but to analytics: leveraging LLMs to make it easier and faster to create analysis, make dashboards and share them to the rest of the team. 

### Come Build With Us!

Help us build the future of data analytics. Reach out to us directly (info@fused.io) or see our open positions.

---
We did take inspiration from Andrej Karpathy's recent Software is Changing (Again) talk at AI Startup School, as you may have noticed from the title.

================================================================================

## Fused is SOC2 Type 1 Compliant!
Path: blog/2025-07-08-soc2_type1/index.mdx
URL: https://docs.fused.io/blog/2025-07-08-soc2_type1

# Fused is now SOC 2 Type 1 compliant!

We're excited to announce that Fused has achieved SOC 2 Type 1 compliance. This is a significant milestone for us, as it demonstrates our commitment to security and transparency.

At Fused, we want to allow all data teams to get work done quickly. We want to make sure to do this on top of a secure and compliant platform.

Through the comprehensive auditing process overseen by Insight Assurance, we've demonstrated our adherence
to the stringent requirements outlined by the SOC 2 Type 1 standard, reinforcing our dedication to safeguarding
sensitive data and maintaining operational resilience.

Request the full report by email: `info@fused.io`. 

We're actively pursuing SOC 2 Type 2 certification, building on our existing Type 1 compliance.

================================================================================

## Notes from EO Summit 2025
Path: blog/2025-06-19-eo_summit/index.mdx
URL: https://docs.fused.io/blog/2025-06-19-eo_summit

# Notes from EO Summit 2025

Last week, we were at EO Summit, Fused came out of beta, we officially launched our new site and are open for business! 

Our mission is to help data teams get stuff done quickly, which is relevant for the people we talked to at EO Summit.

[Image: Fused at EO Summit]

Here are some of our takeaways:

### 1. AI makes writing code simpler, but executing it at scale is still hard

A lot of us are going through a bit of an existential crisis, while realising that damn, yep, AI can help us write code to glue datasets together quickly. Knowing the intricacies of a Python library isn‚Äôt a competitive advantage for individuals and companies to build the best analytics anymore. 

That‚Äôs all well and good when working on a small, one-off project. But conferences like EO Summit keep showing that there‚Äôs more data than ever before. Archives of imagery, 3D point clouds and any dataset keeps growing in scale, resolution & time backlog. Problems aren‚Äôt always local, nor limited to a small time & place. 

AI is changing what it means to build software & products, there‚Äôs not doubt about that. But executing it at scale is still a dark art. 

### 2. So much data, yet we still struggle to get things done in a timely manner

At another conference, the Cloud Native Geopaptial last month Brianna Pag√°n shared her story of the Los Angeles fires taking down her home, and while having so much data available, so little was actually accessible in a helpful manner quickly. This topic came again at this conference, wildfires being the prime example of the complexity of making timely and updated use of data in times of need despite having so much.

A few months ago, our own Milind Soni made a quick interactive dashboard in a few hours as a proof of concept of what rapid tools could look like for wildfire updates using Fused.

These conversations are directly going into our internal product development discussion; as we write this, we're developing tools to build these dashboard for rapid iteration. Stay tuned for more on that soon! 

### 3. The gap between data & applications

Nadine Alameh, at the head of the Taylor Geospatial Institute & former CEO of the OGC, the consortium in charge of standards for all things geospatial, mentioned the lack of companies in the middle solving problems between data providers and companies building analytics products. This is something Aravind, head of Terrawatch -who organised this conference- has been saying for a while.  

That‚Äôs why we were excited about being at EO Summit, we think we can make a difference tackling these problems!

[Image: Talking to attendees]

We‚Äôre building tools that make getting data from all types of places & formats together, execute code (however it was written) at any scale with a few lines of code and sharing it all to whomever needs it, be it interactive dashboard, CSVs or tile servers. 

If you‚Äôd like to learn more about Fused, book some time with Max, our Developer Advocate right here to get a demo!

================================================================================

## Scaling Environmental Insights with Fused and H3
Path: blog/2025-05-27-environmental-insights/index.mdx
URL: https://docs.fused.io/blog/2025-05-27-environmental-insights

# Scaling Environmental Insights with Fused and H3

Farmers and analysts face a familiar challenge: weather and crop data is fragmented, slow to process, and hard to act on.

We worked with Emma Quirk (Senior Data Analyst) and Majid Alivand (Senior Data & Analytics Manager) to showcase how Fused can help bring all these datasets together. In this webinar they give an overview of the industry challenges interfacing backend data analytics with frontend data consumption. Emma walks through the notebook she used to model climate and irrigation patterns for vineyards.

## Addressing the Challenge

Building useful & actionable weather models for environmental insights requires bringing datasets from:
- Different sources
- Different resolutions
- Different formats

To address these challenges, Emma & Majid used Fused + H3 to bring together datasets like GridMET climate, CDL crops, LANID irrigation, and gSSURGO soils by converting them from raster to H3 to build unified parquet files.

By building UDFs to manipulate each dataset, the team can iterate on their analysis in seconds while H3 allows them to more easily combine all the datasets together.

## Why H3?

- Harmonized format across datasets and regions
- Scalable queries at multiple resolutions
- Compact storage parquets with improved spatial performance
- No reprojection needed for global analyses
- Equal neighbors for clean spatial logic

## Try it out for yourself

Try out the notebook from the presentation for yourself:
- Colab Notebook

Sign up for a free Fused account and try it out for yourself!

================================================================================

## Launching Fused Apps
Path: blog/2025-05-20-launching-fused-apps/index.mdx
URL: https://docs.fused.io/blog/2025-05-20-launching-fused-apps

# Launching Fused Apps

Today we're launching Fused Apps, allowing you to write Python in the browser, creating, editing & sharing interactive apps 

## üêç Write Python in the browser

Fused Apps are one of the the fastest way to write Python, directly in the browser. 
- No environment setup, just start writing Python
- Create interactive apps using Streamlit 
- Save & rename your Apps

## üîó Share your apps with anyone

As soon as you save your Fused App, you can create a shareable link for anyone to open

<LazyReactPlayer
    playsinline=
    className="video__player"
    muted=
    controls
    style=}
    width="100%"
    url="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/blogs/2025-05-13-inside-fused-apps/sharing_fused_apps_links_higher_res.mp4"
/>

## üîí Standalone & Private, running in your browser 

Fused Apps are built on top of Pyodide, Streamlit & Stlite but offer many features:
- Github Integration for team collaboration
- Run light-weight LLMs locally in your browser with libraries like `transformers.js.py`

[Image: CDL Bunnies]

## üìö Access a Catalog of existing Fused Apps to get started

We've curated a catalog of existing Fused Apps to get you started, including:
- üåΩ Explore different crops around the US
- üõ∞Ô∏è Visualize the trend of objects sent to Space
- üå≤ Pan a map of Forest statistics per global municipality

<LazyReactPlayer
    playsinline=
    className="video__player"
    muted=
    controls
    style=}
    width="100%"
    url="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/blogs/2025-05-13-inside-fused-apps/App_catalog_browsing.mp4"
/>

You can try out Fused Apps for yourself directly in Fused Workbench and read our dedicated Docs page

## ‚öôÔ∏è How we built Fused Apps: Technical Details

We wrote a dedicated technical blog post going into details of how Fused Apps are built:
- How we originally built Fused Apps
- The challenges of Python in the browser
- Our approach to building a product

## Join our webinar on May 22nd!

On Thursday May 22nd we'll be hosting a webinar showcasing how our customers use Fused

- Join on LinkedIn

[Image: Webinar thumbnail]

================================================================================

## Inside Fused Apps: Python in The Browser
Path: blog/2025-05-20-inside-fused-apps/index.mdx
URL: https://docs.fused.io/blog/2025-05-20-inside-fused-apps

# Inside Fused Apps: Python in The Browser

This is a technical deep dive into how we built **Fused Apps**, a way to build a Python-based workflow in your browser, that you can save and share with someone. You can read the full product announcement here.

At Fused, we‚Äôre building tools to help data scientists work more efficiently: we want to give them the ability to work on any dataset, create an analysis and scale it to the whole world with just a few lines of code. But data scientists don‚Äôt work in a vacuum, and analysis aren‚Äôt (always) done because people are simply curious about a topic. 

We built Fused Apps in the spirit of allowing a single person to do all the work themselves; and in this first episode of *Inside Fused*, a series of blogposts about how we‚Äôre building Fused, we want to take you behind the curtain to show how Fused Apps is built. 

### Fused Apps at a glance

Fused provides both a Python package to run User Defined Functions (UDFs), and Workbench, a browser-based IDE to write, execute, visualize them as well as create Fused Apps to make interactive frontends. 

Here‚Äôs what Fused Apps look like:

[Image: Fused apps preview]

_Fused Apps. From left to right: the list of apps that have been loaded in Workbench, the app code editor, and the running app itself._

The App code editor & renderer allow users to write their own Python code using Streamlit to build a frontend entirely in Python, a language most data scientists already work with.

We want data scientists to be able to go from ‚Äúhey, that‚Äôs a cool idea‚Äù to ‚Äúhere‚Äôs what it looks like‚Äù without tech getting in their way. Especially in a world where LLMs make writing code simpler, the bottleneck becomes the speed at which data scientists can execute & ship code, not write it.

Fused Apps offers a way for data scientists to orchestrate their entire workflow using Python, without having to worry about backends, scaling, or clusters. Fused Apps complement our UDF builder, which offers a way to build data processing and backend functions, by offering an end-to-end workflow. At Fused, we use this for ingesting and managing datasets, managing resources we make available to our UDFs, and finalizing analyses.

<LazyReactPlayer
    playsinline=
    className="video__player"
    muted=
    controls
    style=}
    width="100%"
    url="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/blogs/2025-05-13-inside-fused-apps/Vision_Pro_cdl_exploring_sped_up.mp4"
/>

_Fused Apps work on *any* device, as long as there's a browser!_

### How we built it

In short, Fused Apps tie together a frontend application for users to write Python code with Streamlit, a backend that saves & serves these apps and provides shareable links, and a product experience tying all of this together (error handling, autocomplete suggestions, async UI functionalities, etc.)

Fused Apps are built on top of Stlite & Streamlit. Streamlit being a library allowing you to write a frontend application, entirely in Python, and Stlite an in-browser version of Streamlit. This allows people familiar with Python but not so much frontend development (like data scientists) to have something rendered on screen in HTML, but only with writing Python. 

Stlite provides the ability to run apps in the browser, and while Stlite Sharing does support URL-encoded mechanisms for app sharing, the URL is the same as the code, preventing users from *updating* said code; there‚Äôs also no such thing as app catalogs, etc. So we ended up using Stlite as the engine and built a product experience around that. 

The frontend for building a Python-in-the-browser application already exists, with Streamlit & Stlite. However the backend had to be built from the ground up.

Originally, we didn‚Äôt even have a way for people to save their apps! Our internal workflow while developing & testing this was to have a Slack channel where we pasted our app links in to be able to find them later on

[Image: Early days Slack sharing links]

This is at the the core of our development philosophy: Build a prototype, use it a bunch, find the pain points, fix them, build more. In this case, saving & tracking apps was the next piece to build.

This is how we added functionality like Github integration, sharing options, and an app catalog. All these were only added after we got some traction internally and from early customers.

<LazyReactPlayer
    playsinline=
    className="video__player"
    muted=
    controls
    style=}
    width="100%"
    url="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/blogs/2025-05-13-inside-fused-apps/sharing_fused_apps_links_higher_res.mp4"
/>
_Sharing Fused Apps is just a couple of clicks now_

### Python, in the browser

The next piece of this puzzle is to realise that running Python locally on your machine and in the browser is quite different. We want to make the experience for the user as seamless as possible: we‚Äôre building products for data scientists to build everything in Python.

We use Pyodide to run Python in WASM. This enables the same Python language to be used in a new environment ‚Äì the browser. The browser environment is key because it gives us a way to safely ship applications to users.

Safely shipping software to people wasn‚Äôt always the simplest. Previous efforts via Flash and Java applets enabled a generation of rich web content. The promise of Java applets was run anywhere ‚Äì that the same code could run on anyone‚Äôs computer. These technologies died out mainly because of security model problems. (Java lives on in Blu-ray disks.)

At the time of writing this, in mid 2025, browser applications are considered well sandboxed (with the possible exceptions of RowHammer/Spectre type issues), browser applications open when you want them, and go away completely when you dismiss them, all the while performing more and more complex tasks. Browser applications handle video encoding/decoding for video conferencing, graphics rendering for games, maps, and design, and more frequently, for programming. Companies like Figma are building complex, professional grade applications for the browser first.

From a development perspective, the browser becomes an operating system. It becomes less important to know what exact hardware & underlying operating system the users have, and we develop applications for the browsers‚Äô APIs. Those applications are inherently portable to new devices, because the heavy lifting is porting the browser to these new devices. 

### Building a Product

There are other projects out there that allow building hosted Stlite applications, however these miss some of the features that people expect from a well rounded product. Here are few things we‚Äôve added to Fused Apps:
- Package Handling (Every Fused Apps comes with `fused` and `pyarrow` pre-installed)
- Error handling 
- Naming & saving of Apps
- Github integration for teams
- Creating shareable links allowing users to send their apps to anyone with a browser

Beyond the technical challenges we want to build a product that helps data scientists build, iterate and ship faster. A data scientist can build an analysis that takes in different parameters and make an interactive graph for their project manager to test out directly all without needing support

A big part of this is the philosophy of how we build things at Fused: We‚Äôre a team of engineers & data scientists. A lot of the features we‚Äôre listing above here come directly from our own usage of Fused Apps while making real applications with some of our customers.

We care about how fast it takes for a new user to click on a Fused App and start running it, or what the experience of saving & sharing an app looks like. 

Every Fused App comes with some packages pre-installed, such as `fused` and `pyarrow`, which are helpful for data scientists. (Streamlit comes with a number of other common packages like Pandas and NumPy already.) But this comes at the expense of loading time, as each new app is a self-contained application which requires downloading all the required packages. This is leading us to spend time optimizing the initial loading time of Pyodide.

### What can we expect from Pyodide

Fused Apps, and any implementation of Python in the browser, isn‚Äôt as customizable as a fully local setup. Packages with native code that are not prebuilt for WASM will not work. At the time of writing, some popular packages like Pandas & Numpy are built and supported, but others aren‚Äôt. The backbone of the map processing pipeline, GDAL, for example, isn‚Äôt currently supported. This isn‚Äôt from lack of popularity, but reflects the complexity of building GDAL.

Some packages will need architecture updates. As another example people currently call into ffmpegfrom Python using the CLI. The WASM environment does not have a CLI concept, and this would need to be replaced with library calls. Other packages which are not well suited to this architecture (such as Torch) might have alternatives developed because the wasm ecosystem is so attractive a development target.

#### LLMs in the Browser

An example of this is transformers.js.py. This library (developed by Yuichiro Tachibana, also behind Stlite) needed more than one level of architectural adaptation to get running in the browser, but once adapted it brought the capability of running lightweight LLMs. This allows us to ship applications that run small LLMs models, running locally in the browser! 

We made a Fused App exploring the USDA‚Äôs Crop Data Layer (CDL) dataset, a dataset of different crop types in the US. Instead of showing all 130+ categories, we can just take a text input, run a similarity analysis on the fly against all the categories and find the closest CDL crop type! 

[Image: CDL Bunnies]

_You too can find out what Bunnies prefer by trying this Fused App here_

#### Compatibility & load times

This is a fast changing ecosystem though, for example we‚Äôve made a small contribution of a build of the H3 package specifically because we wanted to have H3 supported in Python in the browser. The list of supported packages built in Pyodide is growing quickly. 

Moving large amounts of data in and out of the browser is slow, so data-intensive libraries like Torch or Dask are not well-suited for this. We solve this by bringing in the compute performance & flexibility of Fused UDFs, which run native (non-WASM) Python in a cloud environment. Fused UDFs run code much closer to the data, improving performance, and are not limited by what packages are available for Pyodide, improving flexibility.

Install times for Pyodide are relatively long from a user point of view, as the application isn‚Äôt stored locally and installed each time it's opened. This will most likely keep improving over time as the technology is developed further. For example Pyodide wants to add memory snapshotting to help with this, but it isn‚Äôt stable yet.

Even when the application is stored locally, we found we needed to reinitialize Pyodide in some cases. There is no concept of switching virtual environments in Pyodide, since running a new script reuses the same Python VM. When switching between apps in Fused, we reinitialize Pyodide in order to prevent packages from one app interfering with another. If we didn‚Äôt do this, a user might accidentally rely on a package installed by App A in developing App B, which would then not work when sharing App B.

We also needed to be careful with when the app can run, since the app has access to the user‚Äôs browser context. We chose to give users the chance to inspect the app‚Äôs code before running it if it would have access to their Fused account.

Code written in Stlite and Pyodide looks almost the same as regular Python, but there are slight differences. Many of these come in the form of adapting synchronous and asynchronous code. Stlite for example allows for top-level `await` because the browser‚Äôs event loop is being used. This can be tricky to work with because regular advice for working around asynchronous code in Python does not work with Pyodide.

[Image: CDL loading async model & logging]
_Async-aware UI allows us to provide improved feedback as an app loads a light weight LLM model or data to display_

In order to create a good product experience, we added our own syntax checking and linting on top of Pyodide. 

[Image: Error handling]

_Lots of small features go a long way to delighting users with a smooth experience._

### Delivering at near-zero cost

Fused Apps are part of the free tier of Fused. You can use Fused Apps without logging in at all, and with a free login you can save and share your apps. We want to take a moment here to explain why this is naturally a free offering and will continue to be free.

As a browser-based application, all of the code execution and data transfer happens in the user's browser. This means that we do not need to sandbox code execution or pay for cloud compute resources to run anyone‚Äôs Fused Apps. 

Where we do incur costs are in the shared control plane layer of Fused. Technically, the control place layer doesn‚Äôt see much difference between an app and a UDF. As a result, the incremental cost of serving an app user is very low and it is easy for us to offer that for free. The core offering of Fused is the backend serverless execution of code, which is our paid product.

### Try it out for yourself 

Don‚Äôt take our word for it, give Fused Apps a try for yourself! As we mentioned, Fused Apps are free and don‚Äôt require login. You can check out our catalog of public Apps in Fused Workbench.

Recently we announced re-partitioning the Crop Data Layer dataset into H3 hexagons for anyone to use and hosted the resulting dataset on Source Cooperative.

Alongside this we created a public Fused App allowing you to explore any crop for the 2024 dataset

### We're hiring: Help us build the future of data science workflows!

We firmly believe data scientists need tools that give them the independence to do their work rather than asking for support to scale their analysis or share their results. 

We need smart people to help us build all of this. We are hiring for:

- Deep knowledge of Python & Pyodide
- Opinionated thinking in building the future of data science pipelines
- People wanting to join a fast moving startup and build things

If you‚Äôd like to join the team, **send us your info here**!

[Image: The team]

_Join the team!_

================================================================================

## How Sylvera uses Fused to prototype and power DeckGL applications
Path: blog/2025-05-16-danieljahn/index.mdx
URL: https://docs.fused.io/blog/2025-05-16-danieljahn

**TL;DR Sylvera quickly builds and tests new app features by serving data to DeckGL applications using Fused HTTPS endpoints.**

At its core, Sylvera rates carbon projects. Our ratings are powered by several earth observation and geospatial analysis data products. From climate risk data, and deforestation indicators, to biomass-predicting ML models, a wealth of data goes into generating a single-letter rating.

```javascript showLineNumbers
const BOUNDS_AFRICA: [number, number, number, number] = [
  -25.35, -46.95, 51.35, 37.35,
];
const UDF_H_AOI_FILE_CALL = "FUSED_UDF";

function createTileLayer(id: string, data: string[]): TileLayer<ImageBitmap>  = props;

      return [
        new BitmapLayer(otherProps, ),
      ];
    },
  });
}

function createBitmapLayer(
  id: string,
  image: string,
  bounds: [number, number, number, number]
) );
}

const createFusedFileLayer = (
  layerId: string,
  fusedId: string,
  bounds: [number, number, number, number],
  year: number
) => -$`;
  const param = `year=$`;
  const imageUrl = `https://www.fused.io/server/v1/realtime-shared/$/run/file?dtype_out_raster=png&dtype_out_vector=csv&$`;

  const layer = createBitmapLayer(key, imageUrl, bounds);

  return layer;
};

const createBasemapLayer = () => //.png",
  ]);
};

  const bounds = BOUNDS_AFRICA;
  const year = 2000;

  const basemap = createBasemapLayer();
  const fused = createFusedFileLayer(
    "fused",
    UDF_H_AOI_FILE_CALL,
    bounds,
    year
  );

  return (

  );
}

  createRoot(container).render(<App />);
}
```
</details>

## Conclusion and future work

The application we built isn't yet fully featured to be put in front of users ‚Äì but that's the point. We were not aiming for a finished product yet. Instead, we achieved rapid iteration that enabled us to gather relevant stakeholder feedback.

The speed we could reach wouldn't have been possible without Fused's development platform. Fused unifies three traditionally separate stages ‚Äî prototyping, scaling, and visualization‚Äîinto a single seamless solution. Thanks to this, Fused was an indispensable tool for product iteration.

In the future, we would like to explore the coming integration with Zarr stores. Being able to not only visualize the results but also to immediately persist them into a Zarr store will be a game-changing capability for anyone who uses Zarr as the persistence layer.

================================================================================

## Repartitioning Crop Data Layer & US Census into H3 hexagons
Path: blog/2025-05-06-cdl-census-hex/index.mdx
URL: https://docs.fused.io/blog/2025-05-06-cdl-census-hex

# Repartitioning Crop Data Layer & US Census into H3 hexagons

Fused has repartitioned the USDA Crop Data Layer and US Census into H3 hexagons.

These 2 datasets are both available on Source Cooperative for anyone to use, free of charge!

[Image: Source coop CDL hex]

### What are these datasets?

We've taken 2 popular datasets and made them available in H3 Hexagons, this provides a number of benefits:
- Much faster ability to aggregate data at different scales
- A simple way to join datasets together (as they, and any other H3 tiled dataset are using the same grid)

You can read more about H3 Indexes on the dedicated page.

We're providing:

1. Crop Data Layer (from USDA CroplandCros)

- Available for `[2012, 2014, 2016, 2018, 2020, 2022, 2024]`
- Available in `hex7` and `hex8` resolutions

2. US Census (from data.census.gov)

- Available for `2020`
- Available in `hex7` and `hex8` resolutions

### Using these datasets

These datasets are completely free for anyone to use, with or without Fused. To showcase what's possible we have made a public Fused UDF anyone can use without an account to explore these.

[Image: CDL from source udf]

You can try it here without any account.

================================================================================

## Fused featured in Maxar TED Talk
Path: blog/2025-04-08-TED/index.mdx
URL: https://docs.fused.io/blog/2025-04-08-TED

# Fused featured in Maxar TED Talk

[Image: Fused Powering Maxar]

Fused is excited to be featured in a TED Talk today by Peter Wilczynski, CPO at Maxar, which explored a multi-source site monitoring scenario of Vancouver's greening initiatives over the past five years powered by the Fused platform.

[Image: Fused Maxar Workbench]

Site monitoring scenarios are at their most effective when data from disparate sources is combined‚Äîfrom satellite imagery and map data to municipal and demographic data. Analytics today requires bringing all these different sources of data together: from raw pixels to contextual intelligence ‚Äî in real-time, seamlessly, and at scale.

This is an iterative process, each dataset being in its own format & hosted on different cloud providers, updated independently and on different schedules.

Fused is built by data scientists, engineers & open source contributors who know the reality of building pipelines with breaking changes in libraries, new file formats that require rethinking how data is ingested and business requirements that constantly change.

We firmly believe we need tools that help us bring as many datasets together as possible, especially in a world where LLMs and AI can increasingly talk directly to data.

If you‚Äôd like to try out an instance of the Fused workbench with pre-loaded data from Maxar later this month, which Peter demoed on screen, sign up for the waitlist on fused.maxar.com to get access and see for yourself this is more than a pre-recorded tech demo!

================================================================================

## Announcing Fused AI Builder
Path: blog/2025-04-01-announcing-ai-builder/index.mdx
URL: https://docs.fused.io/blog/2025-04-01-announcing-ai-builder

# Announcing Fused AI Builder

**Fused AI Builder let's you create LLM Agents that can directly call & execute deployed Python code through Fused UDFs!**

### Give LLMs the ability the talk to your data & code

We're launching Fused AI Builder, a simple way for you to give an LLM access to any UDF you want

</Tabs>

================================================================================

## Announcing Fused 2.0
Path: blog/2025-02-25-fused/index.mdx
URL: https://docs.fused.io/blog/2025-02-25-fused

# Announcing Fused 2.0

**Fused 2.0 is our biggest update to date, with changes across Workbench & `fused-py`!**

### A New UDF Editor in Workbench

[Image: New Fused Workbench]

#### Introducing Collections: A simple way to organize your UDFs

Collections now allows you to organize your UDFs together as you work on different projects, save them together and keep your editor focused on the project at hand.

<LazyReactPlayer className="video__player" playing= muted= controls height="100%" url="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/announcements/fused_2_0/load_collections_new.mp4" width="100%" />

Collection is still in early access so you need to enable it under "Preferences -> Enable UDF Collections [Beta]" to access it

#### Redesigned UDF Editor

UDF Editor now comes with a host of new features & redesigned UI:
- Adding a new Full Screen Map View
- The Visualize Tab is now under the UDF expanded parameters, allowing you to hide your Code Editor and just focus on tweaking the visualization of your data
- Split screen "Editor" & "Module" on top of each other: Keeping your code clean in the main "Editor" Tab is now easier by moving functions under the "Module" tab.

#### A New Share Page

We've moved all the tools & information you need to easily share your UDFs into a dedicated page (and button). You can easily:
- Create a token to share your UDFs 
- Edit the Description, Tags & Image preview of your UDFs

<LazyReactPlayer className="video__player" playing= muted= controls height="100%" url="https://fused-magic.s3.us-west-2.amazonaws.com/workbench-walkthrough-videos/announcements/fused_2_0/share_udf.mp4" width="100%" />

### Changes to `fused-py`

Our Python library `fused-py` is getting some updates to make processing data in Python simpler, from a small one time task to processing huge datasets

#### Simplifying how Fused handles geometries

- Moving away from Fused having many different `fused.types` to only having 2 simple types: `fused.types.Bounds` and `fused.types.Tile`.
- Replacing `bbox` object with `bounds`: a more generic term to pass geometries to UDFs

#### `fused.submit()` for simple, multi job runs

We're introducing `fused.submit()` as a simple way to run many UDFs all at once in parallel

[Image: fused.submit() demo]

This can significantly speed up parallel tasks like:
- Fetching lots of individual data points from an API
- Scaling small processing steps to lots of data points

#### Improved caching

Under the hood we've significantly improved how Fused caches results of recurring UDFs & cached functions + we've introduced new tools for developers to control caching:
- A default 90 days cache time for all UDFs
- Editing the cache duration with the new `cache_max_age` argument

Read more about Caching

### Full Fused 2.0 Changelog

Read our Changelog to see every change happening with Fused 2.0

================================================================================

## Enhance your data with GERS IDs
Path: blog/2025-02-18-jennings/index.mdx
URL: https://docs.fused.io/blog/2025-02-18-jennings

**TL;DR Enriching your spatial data with GERS IDs can make it interoperable across the data ecosystem. You can use Fused UDFs to create custom HTTPS endpoints to enrich your data with GERS.**

The Global Entity Reference System (GERS) is a framework that structures, encodes, and matches map data to a shared universal reference within Overture. GERS helps organizations identify and reference their own datasets with standard identifiers to Overture data to help unify datasets.

<LazyReactPlayer playsinline= className="video__player" playing= muted= controls height="100%" url="https://fused-magic.s3.us-west-2.amazonaws.com/blog-assets/gers_sheets.mp4" width="100%" />

\
In this blog post we show how to create simple endpoints with Fused UDFs to enrich a dataset with GERS IDs. We'll use the Overture Building footprints to first enrich a polygon with GERS IDs then another one to look-up metadata for a specified GERS ID.

## The benefit of GERS

When third-party dataset is spatially matched to an Overture feature it's "enriched" with that feature's GERS ID and becomes "GERS-enabled". This makes it easy to associate it by ID to any other GERS-enabled dataset.

```
                            gers_id             buliding_name
0  08b2a1072534cfff020018b8a6efde22  James A. Farley Building
1  08b2a100d2cb6fff02000821de8bdff1      Pennsylvania Station
```

For example, a municipal government with a dataset of building footprints for local offices, coffee shops, and museums could match those entities to a GERS ID. This would enable the government to easily join its data other "GERS-enabled" datasets to enrich them with additional information such as insurance data, historical property values, restaurant reviews, fire risk, or rooftop solar potential.

## Create a UDF to enrich a polygon with GERS IDs

We can create a UDF that takes in a polygon and returns a GERS ID. This UDF will spatially match the polygon to Overture Buildings and return the GERS ID of the building that intersects the polygon. This is useful for enriching a dataset with GERS IDs.

Users can design and preview the workflow interactively, allowing them to test assumptions and visualize their effect. Parameters can be adjusted, and the output can be previewed before running the UDF on the entire dataset.

```python showLineNumbers

aoi = json.dumps(,"geometry":}]})

@fused.udf
def udf(bbox: fused.types.TileGDF=aoi):

    utils = fused.load("https://github.com/fusedio/udfs/tree/e1fefb7/public/Overture_Maps_Example/").utils

    # 1. Convert bbox to GeoDataFrame
    if isinstance(bbox, str):
        bbox = gpd.GeoDataFrame.from_features(json.loads(bbox))

    # 2. Load Overture Buildings that intersect the given bbox centroid
    gdf = utils.get_overture(bbox=bbox.geometry.centroid, overture_type='building', min_zoom=10)

    # How many Overture buildings fall within the bbox centroid?
    print("Buildings in centroid: ", len(gdf))

    # 3. Rule to set only one GERS on the input polygon
    bbox['id'] = gdf.id.values[0]

    return bbox
```

### Create an HTTPS endpoint

With Fused, it's easy to turn your UDF into an HTTPS endpoint. This enables you to run the UDF it programmatically via HTTPS requests to integrate the functionality into various workflows and applications.

This endpoint runs a public UDF with the code above. You can call it with a geojson of a single polygon in the bbox query parameter and it will return a geojson with the polygon and an assigned GERS ID.

```
https://www.fused.io/server/v1/realtime-shared/UDF_Overture_Buildings_GERS_Enrich/run/file?dtype_out_vector=geojson&bbox=,"geometry":}]}
```

## Create a UDF to look-up metadata for a GERS IDs

We can also create a sample UDF to do a reverse operation: look-up a Building and its attributes by passing a GERS id. A user will be able to pass a GERS id and the UDF will look-up the building and return its geometry along with attributes about the building.

To do this, we create a UDF that takes in a `gers_id` parameter. Because the first 16 digits of GERS correspond to an H3 cell, we can use the ID to create a polygon to spatially filter the dataset. It'll bring up any buildings that intersect the H3 cell. Once we have the building, we can easily work with its geometry object and attributes using GeoPandas.

```python showLineNumbers
@fused.udf
def udf(gers_id: str='08b2a100d2cb6fff02000821de8bdff1'):

    from shapely.geometry import Polygon

    utils = fused.load("https://github.com/fusedio/udfs/tree/e1fefb7/public/Overture_Maps_Example/").utils

    # 1. H3 from GERS
    h3_index = gers_id[:16]
    print('h3_index', h3_index)

    # 2. Polygon from H3
    bounds = Polygon([coord[::-1] for coord in h3.cell_to_boundary(h3_index)])
    bbox = gpd.GeoDataFrame()

    # 3. Load Overture Buildings
    gdf = utils.get_overture(bbox=bbox, overture_type='building', min_zoom=10)

    # 4. Subselect building
    gdf = gdf[gdf['id'] == gers_id]

    # 5. De-struct the names column
    normalized_df = pd.json_normalize(gdf['names'])
    gdf = gdf.reset_index(drop=True).join(normalized_df)

    return gdf[['id', 'primary', 'subtype', 'class', 'geometry']]
```

### Create an HTTPS endpoint

Here's how you can create and use an HTTPS endpoint for your GERS building lookup UDF.

This endpoint returns a CSV table of the building's GERS ID, primary name, subtype, class, and geometry. You can use this endpoint to enrich your dataset with GERS IDs by calling it with a GERS ID query parameter.

```
https://www.fused.io/server/v1/realtime-shared/UDF_Overture_Buildings_GERS_Lookup/run/file?08b2a100d2cb6fff02000821de8bdff1&dtype_out_vector=csv
```

For example, you could call this endpoint from a Google Sheet to enrich a dataset with GERS IDs. This sample Google Sheet returns the enriches the "primary" name column for any given Building GERS. Just drag the formula to apply it to any row below. It works by calling the "GERS lookup" endpoint with a GERS ID query parameter.

================================================================================

## We're partnering with Overture to make their Data easily accessible with Fused
Path: blog/2025-02-11-overture/index.mdx
URL: https://docs.fused.io/blog/2025-02-11-overture

**_TL;DR: We've made it easier to work with Overture data by leveraging Fused._**

Fused has been working with the team at The Overture Maps Foundation to enable direct access to their data through Fused UDFs. We are excited to share that the Overture docs now show examples on how to see how to integrate any Overture data into your workflows using Fused.

[Image: Alt]

Overture Maps aims to provide foundational building blocks of data across various themes designed to be broadly applicable across industries. Our goal at Fused is to make it easy to work with Overture data and adopt standards (such as GERS). To this end, we are creating easy abstractions to access data, tools to perform foundational operations such as conflation and enrichment, and example workflows to inspire and help you understand how to leverage this data.

One of the key usecases for Overture + Fused is enriching datasets with Overture Maps data. This tutorial showcases 2 simple Python workflows that do this by performing a spatial join with Overture Buildings. This example of a simple enrichment operation will help you understand how to work with Overture data in your own workflows.

To follow along, check out the:
- Overture Maps Docs "Getting Data" Page
- Overture Maps Docs "Examples" Page
- Overture Maps Example UDF
- Overture + NSI UDF

## Overview

The Overture Buildings dataset is dividen into themes. Two key themes are:
- Buildings is composed of building footprints represented as polygons
- Places is composed of business establishment locations and associated metadata, represented with point coordinates.

We'll first show how you can load Overture data by reusing an existing Fused UDF, then write a User Defined Function (UDF) with custom logic to perform enrichment with a spatial join. You'll be able to run the resulting UDF for any custom area of interest (AOI).

## Step 1: Load data with the Overture Maps UDF

Fused has a catalog of pre-made UDFs you can easily copy and repurpose for your own data analysis workflows. In the catalog, you'll find the Fused Overture UDF which enables you to quickly load Overture data from any of the themes for an area of interest (AOI). You can run the UDF with `fused.run` and specify an AOI to load data for using the bbox parameter. You may also pass optional parameters to select between Overture releases, themes, and columns - that way you can fetch only the data you need. In this example, we can specify the 'building' theme by setting the `overture_type` parameter.

```python showLineNumbers

bounds = [-73.9847, 40.7666, -73.9810, 40.7694]

fused.run('UDF_Overture_Maps_Example', bounds=bounds, overture_type='building')
```

The output should look like this:

```python showLineNumbers

        id	                                geometry	                                        class   ...
24134	08b2a100d65a6fff0200b45ce7e2b99b	POLYGON ((-73.98552 40.76736, -73.98557 40.767...	apartments  ...
24135	08b2a1008b259fff02007917db1c32d3	POLYGON ((-73.98441 40.76703, -73.98431 40.767...	apartments  ...
24178	08b2a100d6516fff0200ded2bf849c8a	POLYGON ((-73.98375 40.76693, -73.98381 40.766...	apartments  ...
24179	08b2a100d6516fff02006dc174022a7e	POLYGON ((-73.98346 40.76623, -73.98327 40.766...	commercial  ...
24180	08b2a1008b248fff0200315983940aa8	POLYGON ((-73.98407 40.76749, -73.98402 40.767...	None    ...

```

By browsing the UDF's catalog page, you can see its code and even copy it to run it interactively on the Fused Workbench. You'll notice that the UDF uses the `get_overture` helper function to read from spatially partitioned parquets of the overture data releases, hosted in a Source Cooperative S3 bucket. The source code of the helper function is fully open and hosted on GitHub here.

Here's a simplified version to show the core of what's going on in `get_overture`. It constructs the table path on S3 and then uses the table_to_tile helper function from Fused to load data that falls within the specified bounding box. This approach allows you to efficiently perform spatial queries on a large dataset and load only the records within the given area.

```python showLineNumbers
# Structure the table path with input parameters
table_path = f"s3://us-west-2.opendata.source.coop/fused/overture//theme=/type="

# Load the data within the bounding box
df = utils.table_to_tile(bbox, table=part_path)
```

## Step 2: Write a Custom UDF to join Places with Buildings
The example above shows how to run an existing UDF to load Overture data, but it's likely you want to write your own data transformations. You can borrow `get_overture` to load data into your own UDFs. As an example, here is a UDF to load Overture Buildings polygons and Overture Places points. The UDF perform a spatial join between them to determine which points fall within each building.

```python showLineNumbers
@fused.udf
def udf(bbox: fused.types.TileGDF = None):

    utils = fused.load("https://github.com/fusedio/udfs/tree/e1fefb7/public/Overture_Maps_Example/").utils

    # 1. Load Buildings
    gdf_buildings = utils.get_overture(bbox=bbox, theme='buildings')

    # 2. Load Places
    gdf_places = utils.get_overture(bbox=bbox, theme='places')

    # 3. Create a column with the Buliding Name
    gdf_buildings['primary_name'] = gdf_buildings['names'].apply(lambda x: x.get('primary') if isinstance(x, dict) else None)

    # 4. Spatial join between Places and Buildings
    gdf_joined = gdf_places.sjoin(gdf_buildings[['geometry', 'primary_name']])[['id', 'names', 'primary_name', 'geometry']]

    return gdf_joined
```

To run this UDF, you simply call it with your AOI. Fused will execute the code with the given parameter then return the UDF's output.

```python showLineNumbers

bbox = gpd.GeoDataFrame(geometry=[shapely.box(-73.9847, 40.7666, -73.9810, 40.7694)], crs=4326)

fused.run(udf, bbox=bbox)
````

This will return a GeoDataFrame with the geometry of the Place, the `primary_name` of the building it falls within, and other attributes as defined in the UDF's return statement.

The output should look like this:

```python showLineNumbers
        id	                                names                                                   primary_name	    geometry
3883	08f2a100d65160860308e7269804dcb7	 className="video__player" playing= muted= controls height="100%" url="https://fused-magic.s3.us-west-2.amazonaws.com/blog-assets/join_places.mp4" width="100%" />

## Step 3: Write a Custom UDF to join Buildings with the NSI dataset

As a second example, you can also enrich the Overture Buildings dataset with metadata data from the National Structure Inventory (NSI) API. The NSI API offers point data on buildings in the U.S. that is relevant to hazard analyses.

This UDF loads the Overture and NSI datasets, performs a spatial join to enrich the building polygons with hazard metadata, and returns the enriched GeoDataFrame. It can be used within a larger analysis workflow to enrich building polygons to calculate risk indices. You can read more about performing spatial operations to enrich Overture Buildings with NSI in our geospatial processing guide.

```python showLineNumbers
@fused.udf
def udf(bbox: fused.types.TileGDF = None):

    utils = fused.load("https://github.com/fusedio/udfs/tree/e1fefb7/public/Overture_Maps_Example/").utils

    # 1. Load Overture Buildings
    gdf_overture = utils.get_overture(bbox=bbox)

    # 2. Load NSI from API
    response = requests.post(
        url="https://nsi.sec.usace.army.mil/nsiapi/structures?fmt=fc",
        json=bbox.__geo_interface__,
    )

    # 3. Create NSI gdf
    gdf = gpd.GeoDataFrame.from_features(response.json()["features"])

    # 4. Join Overture and NSI
    cols = ["id","geometry","metric","ground_elv_m","height","num_floors","num_story"]
    join = gdf_overture.sjoin(gdf, how='left')
    join["metric"] = join.apply(lambda row: row.height if pd.notnull(row.height) else row.num_story*3, axis=1)
    return join[cols]

```

The output should look like this:

```python showLineNumbers

	    id	                                geometry	                                        val_struct      med_yr_blt  ...
24178	08b2a100d6516fff0200ded2bf849c8a	POLYGON ((-73.98375 40.76693, -73.98381 40.766...	378633.733	1939	...
24178	08b2a100d6516fff0200ded2bf849c8a	POLYGON ((-73.98375 40.76693, -73.98381 40.766...	348190.820	1939	...
24178	08b2a100d6516fff0200ded2bf849c8a	POLYGON ((-73.98375 40.76693, -73.98381 40.766...	378633.733	1939	...
```

<LazyReactPlayer playsinline= className="video__player" playing= muted= controls height="100%" url="https://fused-magic.s3.us-west-2.amazonaws.com/blog-assets/overture_nsi_2025.mp4" width="100%" />

## Conclusion

In this short tutorial, we outlined how you can integrate Overture data into your workflows using Fused. We saw how you can use Fused to load the data, write a custom Python workflow, and run it for a custom AOI. We hope the these foundational pieces help you see how you can unlock the full potential of Overture Maps and start creating your own workflows to enrich your own datasets.

================================================================================

## How Pilot Fiber creates internal tools to support telecom operations
Path: blog/2025-01-23-kyle/index.mdx
URL: https://docs.fused.io/blog/2025-01-23-kyle

**TL;DR Pilot Fiber creates apps with Fused to quickly identify and resolve service interruptions for its New York City customers.**

Pilot Fiber is a commercial Internet Service Provider primarily in New York City. Our primary value proposition in competing with national-scale ISPs is our commitment to customer experience‚Äìwe are fast and flexible in responding to customer needs in all aspects of the business:

- During the sales process, we aim to answer customer questions quickly and accurately, including technical details and routing.
- When designing our deployment into new buildings, we equip our engineers with as much detail as possible before they arrive on-site to maximize the efficiency of time spent with building engineers.
- When an incident interrupts a service we will immediately jump into action to address the cause and restore connectivity.

We use Fused to support all of these areas, and this post focuses on the last one: incident management.
- What happens when a service interruption occurs?
- How do we identify the likely location of an issue and get to a solution as quickly as possible?

### The Problem: Why Speed Matters

One of the most common ways a customer's service can be impacted is through damage to the physical fiber cables connecting them back to a data center and the internet. Almost all fiber optic cables in Manhattan run through a shared manhole-and-duct system beneath the streets. As such, road construction or work by other providers in a manhole has the potential to damage the equipment of multiple providers. When that damage occurs, it is first come, first served to get your network repaired and customers back online. Field teams from multiple providers can't work in the same manhole simultaneously, so being onsite first and ready to repair can mean a difference of hours in customer downtime.

Because of this, Pilot uses an active fiber monitoring system across our network. Sophisticated devices in our data centers are constantly shooting light down the fibers in our network looking for potential damage. Those devices return a reflectance signature from the fiber and compare it with a reference "snapshot" created when that fiber was initially installed in a building.

When an anomaly is registered, it immediately fires an alert giving a fiber route and distance to the potential problem (i.e. "There is unexpected light loss on the fiber serving 1234 5th Avenue at a distance of 2.351 kilometers from the data center."). When this happens, our engineering and support teams analyze the data within minutes to determine the issue's exact location and, if necessary, get crews headed to the site to begin repairs.

## The Process: Fused As The Glue-Layer

Historically, this analysis has required the attention of an Outside Plant engineer with access to specialized software and network knowledge, regardless of the time of day or day of the week. This bottleneck is not ideal when time is of the essence, even at 3 a.m. So today, we are creating a more sophisticated future using Fused to make this information accessible to more support team members and make our response times even faster.

Using Fused as a back-end glue layer, we built a web app allowing users to select a route and distance and calculate where the system has registered the fault. We also created a simple user interface that provides the user a view of nearby network infrastructure and automatically generates the reports field crews would need to complete repairs based on that nearby infrastructure.

The workflow requires a series of calls to UDFs that act as intermediaries to a Postgres/PostGIS database, which in turn is sourcing data from other internal sources. This structure allows us to easily keep the business logic organized at the UDF layer while limiting the scope of data access and security via Postgres and internal processes maintaining the sync.

The basic process is seen below:

_Workflow diagram._

Two separate flows are initiated when the user inputs a route and a distance to process. One retrieves the selected route to load onto the Mapbox-based map within the app, while the second kicks off a processing chain to analyze the fault information. This chain utilizes UDFs that assist in isolating the location of the fault and relevant nearby infrastructure and adding elements to the map display to assist the user in visualizing what may be occurring.

_UDF to find fault location._

If you consider the cables you see strung along utility poles, they are not perfectly straight: they can sag, bend, go up and down, and have coils of extra cable along the way. The same is true of our cables under the streets. All of those variations add distance to the run, which needs to be considered when determining where a fault is likely to be located.

Taking those variables into account, we use Fused to apply GeoPandas and PostGIS spatial functionality to assess where the fault is most likely to be located. After calculating that location, the tool loads splice cases along that route that point to where problems are most likely to have occurred, and slack loops built into the route to make the user aware of nearby capacity that could enable faster repair of more significant damage. We next determine which splice cases are closest to the likely damage point and if any of those are within 150m of the automated distance calculation. These manholes would be the first locations our field teams would be sent to investigate.

Once we have determined the relevant nearby splice cases, we use another UDF to build a CSV that reproduces what a splice report ## The Impact of Fused

The impact of Fused across this process is many-fold:
- The ability to easily work with data across several systems.
- Centralizing business logic to the UDFs involved eliminates the tendency for this logic to be spread across client-side processes, server-side processes, and possibly the database itself.
- Modularization of operations into UDFs. For example, the UDF that generates the splice reports for this process can easily be reused in any other method that requires the same functionality.
- The effortless ability for the same UDF to simultaneously serve as a modular processing unit where needed in one workflow and a map service for display in another.
- Using Python and standard libraries enables developers who may not be spatial data experts to read, understand, and modify UDFs as necessary.

## Conclusion

Pilot's success in the market is largely based on our flexibility and responsiveness to customer needs, which is never more important than when physical damage to the network is impacting their service. Within this scenario, Fused is providing a critical layer enabling us to offer more non-technical users access to data in multiple systems through a simple UI that will result in repair teams moving to restore service to our customers as quickly as possible.

Fused is an ideal product for Pilot Fiber in that we can increasingly make highly technical information available in a usable format to additional teams throughout the company in support of our drive to be fast, flexible, and accurate in delivering service to our customers in all aspects of the business.

================================================================================

## How Fused Powers BlackPrint's Acquisition Intelligence Platform
Path: blog/2025-01-22-blackprint/index.mdx
URL: https://docs.fused.io/blog/2025-01-22-blackprint

**TL;DR BlackPrint streamlines and transforms fragmented real estate data into actionable insights across Latin America.**

BlackPrint Technologies began its journey as a satellite mapping service designed to help municipalities modernize their property registries. Recognizing a greater opportunity, we transitioned into the private sector to address a significant gap in the commercial real estate market: the need for accessible, actionable data. Today, our platform empowers professionals with precise acquisition intelligence, transforming how decisions are made across Mexico and, soon, all of Latin America.

In this blog post, we will explore how BlackPrint built the backend of its intelligence platform with Fused to provide a comprehensive view of the commercial real estate market in Mexico.

## The Problem: Challenges in Real Estate Data
Real estate professionals face fragmented data sources and manual processes. This complexity limits access to critical metrics such as zoning regulations, demographic patterns, and traffic trends, making site selection decisions both high-stakes and prone to errors. BlackPrint recognized this challenge and set out to create an all-in-one platform, transforming disjointed data into actionable intelligence to empower professionals across the commercial real estate landscape in Latin America.
Our Solution: The BlackPrint Approach

BlackPrint's platform offers a comprehensive suite of tools and insights, including property and zoning data, demographic and socioeconomic analytics, and detailed foot and vehicle traffic analysis. Underpinning this solution is a staggering volume of geospatial data sourced from diverse datasets such as cadastral records, demographic studies, and traffic sensors. This vast amount of information is meticulously analyzed to deliver actionable insights, all while being presented through an intuitive and user-friendly interface. By simplifying complex data into accessible formats, BlackPrint empowers users‚Äîregardless of their technical expertise‚Äîto navigate and leverage insights with ease. Building such a robust platform required not only expertise but also the right tools. That's where Fused came in.

## Leveraging Fused: A Partnership for Efficiency

Fused became an indispensable partner in turning our vision for BlackPrint into reality. Its end-to-end cloud platform allowed us to move from concept to MVP significantly faster by simplifying our data processing and data delivery workflows. Before using Fused, we faced daunting challenges, such as processing and visually inspecting terabytes of traffic data and massive datasets from the Overture Maps Foundation for points of interest.

These tasks, which previously required extensive time and resources, became streamlined and efficient with Fused. Its ability to process geospatial datasets via https-accessible Python functions made the development process seamless, enabling us to focus on creating an intuitive, high-performance platform. With Fused, we could deliver real-time insights and user-friendly visualizations at a scale that was unimaginable only a few years ago.

## Empowering Professionals with Unprecedented Insights

BlackPrint's platform is transforming real estate decision-making by delivering unprecedented insights to professionals. For example, a retailer in Mexico City utilized our tools to identify a high-traffic site with optimal customer reach, saving weeks of manual analysis and significantly improving accuracy.

Our platform's effectiveness is measured through key metrics like time saved, improved precision, and enhanced ROI for our clients. Users have reported up to a 30% increase in efficiency when planning site expansions or evaluating investments.

Looking ahead, BlackPrint's vision extends beyond Mexico, aiming to revolutionize acquisition intelligence across Latin America. With partners like Fused, we continue to innovate, making geospatial analytics scalable, intuitive, and accessible to professionals at every level.

## Conclusion

BlackPrint Technologies is on a mission to redefine real estate intelligence by delivering actionable insights that drive smarter, faster decisions. This journey has been significantly accelerated thanks to Fused, whose serverless data delivery empowered us to process and serve complex geospatial data at an unprecedented scale. Together, we are shaping a future where real estate professionals can access intuitive, data-driven tools that simplify their workflows and enhance their outcomes. Join us in transforming the industry‚Äîvisit blackprint.ai to see how we are revolutionizing real estate decision-making.

================================================================================

## Hot-spot analysis for invasive species using Overture Maps
Path: blog/2025-01-21-elizabeth/index.mdx
URL: https://docs.fused.io/blog/2025-01-21-elizabeth

**TL;DR Elizabeth Rosenbloom creates hotspot maps to identify key areas where Arundo donax is likely to spread, streamlining analysis to improve invasive species mitigation.**

In 2020 while working in Silicon Valley for the county of Santa Clara Valley, I became obsessed with improving monitoring and prevention efforts surrounding Arundo donax. The search and mitigation process this invasive plant species, Arundo donax, was a Sisophisian struggle that had been subject to the same procedures year in and year out, with no progress on beating the spread. To improve the efficacy and efficiency in battling against this notorious weed, I decided to build a tool that would identify the key areas for mitigation - both for the frequency of propagation (occurrence) and for spread potential.

In this blog post I show how I used Fused to create a map of key hotspots where Arundo donax is likely to spread based on built-environment factors derived from Overture Maps data.

To follow along, you check out the UDF associated with the blog post:
- Invasive_Species_Hotspot UDF

## Introduction

In 2020, the problem with managing Arundo was that many agency employees considered this to be a hopeless pursuit, given the exorbitant amount of time cleaning, layering, and calculating the weighted analysis would take. Despite our vast ArcGIS library of tools, engineers, hydrologists, and GIS managers all warned me that I was going to drive myself crazy trying to get the enterprise software to successfully run my analysis. My only regret in building the tool back then was that I didn't have a tool like Fused to expedite the data pulling, processing, and calculating - as it would have saved me from the very lunacy I was warned about.

The obsession with the grass species, Arundo donax, began with an insight to the positive feedback loops created by increased flooding and the spread of invasive species due to climate change. Arundo donax is one of the most invasive plant species worldwide. In addition to destroying biodiversity and disrupting habitats for native species, this large grass also contributes to significant flooding patterns. As weather events become more severe and biodiversity declines, these changes create compounded consequences in our changing climate.

## Challenges with Hot-spot Analysis

Hot-spot analysis tools using weighted sums can significantly increase accuracy in targeting key areas for prevention. To build a hot-spot analysis for Arundo donax, the following variables need to be scored according to their degree of influence: distance to nutrient loading sources (such as a golf course), distance to a riparian buffer (creek or river), distance to a water-flow disruptor (such as a bridge), and size of the stream.

The key pain points of running a weighted sum on traditional GIS software include:
- Slow calculations: "State-of-the-art" software like ArcGIS can take several hours to calculate weighted sums. Furthermore, running weighted sums on large datasets/geographic areas can be nearly impossible given exhaustive RAM and GPU demands, so analyses over 1000 sq miles often require a user to split analyses into different geographic regions.
- Program crashes: beyond the significant wait time required for typical weighted sum calculations, users of prominent GIS software often experience output delays as a result of runtime errors and other issues spurring a program crash.
- Data transformations, cleaning, and standardization: most users of traditional GIS software will find they need to start from scratch when compiling data for a hot-spot analysis or weighted sum. Sometimes, standard base layers like slope and aspect will be searchable on the local software basis. Still, often, lengthy transformations are required to make the layers compatible with the final overlay calculation.

## How Fused Changed My Workflow

Using cloud-based systems like Fused can significantly increase calculation speeds, program resilience, and access to public Cloud Native datasets.

After encountering the Fused and learning about how I could improve the speed and geographic spread of site suitability analyses, I wanted to put it to the test by expanding on a previous analysis I did in 2021 using ArcGIS. The original 2021 analysis took several months of data collection, interviews with other local agencies, and extensive data cleaning, standardization, and transformations. I experienced all the aforementioned pain points of hot-spot analysis/weighted sum calculations and more.

Flash forward to today, where I am compiling global data sets, layering them, and deriving statistical insights within 1% of the time that it took me using ArcGIS. Running buffer analyses, weighting variables, and procuring data has taken a fraction of the time for GLOBAL data - and if you remember from before, the previous analysis from 2021 took months for a county-wide calculation and final product.

The most satisfying aspect of my new hot-spot analysis application wasn't just the expansive end product; the process was more seamless and engaging than I had imagined.

## Workflow Design

I created a UDF with a simple model to identify hotspots susceptible to arundo. The model uses a weighted sum of several base Overture data classes:

- Golf Courses
- Bridges
- Water bodies (rivers, streams, etc.)

The UDF performs the following steps:
1. Create GeoDataFrames from the Overture maps dataset using get_overture
2. Generate an H3 score based on buffers around each feature
3. Aggregate the H3 scores to create a weighted sum

## Key Takeaways
Given the complexity of procuring, layering, and interweaving data along with significant wait times and resource consumption, many governmental agencies, non-profits, and even private corporations struggle to run spatial analyses such as site-suitability and hot-spot tools. Insights and tools can be created by improving the speed and efficacy of operations such as weighted sums and fuzzy analysis across spatial layers with UDFs.

Site-suitability and hot-spot analysis go beyond species detection. By simplifying the approach to these types of tools, we can more quickly and accurately detect climate-vulnerable zones, prioritize habitat restoration, and create models to build resilient communities. Industries such as real estate development, retail, and logistics can more quickly understand the variables that affect their businesses by using cloud-based systems like Fused, which can easily manage large datasets.

================================================================================

## Calculating Fire Ratings with Overture Buildings and Places
Path: blog/2025-01-20-amico/index.mdx
URL: https://docs.fused.io/blog/2025-01-20-amico

**TL;DR Chris Amico shows how to combine Overture Maps data with fire perimeters to analyze wildfire impact on buildings and businesses.**

As communities continue to rebuild and recover from the devastation caused by natural disasters such as wildfires, the question remains: How can we quantify what was lost, especially in the built environment? With the ability to analyze detailed building footprints and overlay fire boundaries, we can begin to answer this by providing a rough estimate of the damage and identifying which structures were impacted by the flames.

In this blog post, Chris Amico shows how by leveraging data such as Overture Building footprints and fire progression maps, we can gain insight into the extent of fire risk. This enables news agencies to derive insights such as count of shops or homes exposed or even assess the capacity of highway routes for residents to evacuate before a prospect fire reaches them.

To follow along, you check out the UDFs and app associated with the blog post:

- Fire Proximity GERS_Lookup UDF
- Fire Proximity Building_Score UDF
- Fire Proximity Buffer UDF
- Google Sheet that enriches the "Fire Risk" column for any given Building GERS
- App: H3 rollups within water buffer

### Introduction

Fused simplifies the process of spatially joining datasets with Overture Maps data, such as integrating with fire-related datasets.

For this example, we use the Inter Agency Fire Perimeter Historical dataset (published by the National Interagency Fire Center (NIFC)) which includes historical fire perimeters up to 2024. Joining fire perimeters with Overture Buildings and Places data enables us to highlight service gaps or identify regions that may require immediate response.

This demo will first select buildings within a buffer zone to determine which fire perimeter they fall within. Then, it will perform an H3 stats roll-up of business categories from Overture Places, counting the number and types of businesses that fall within each distance range. This will involve rolling up Overture Places business categories into H3 hexagons.

## The Workflow

These UDFs return Overture Buildings and Places within a buffer distance from a fire. They offers a simple way to determine the scope of possible fire damage and quickly assess the number of businesses, homes, and other significant structures within the affected area. By adjusting the buffer or selecting fire extent based on dates, users can fine-tune their analysis to gain deeper insights into how far the fire's reach extends and what establishments were most at risk.

### b. Fire Proximity Building Score

Next, we load the Overture Buildings dataset and spatially join it with the fire buffer zones. This workflow categorizes buildings based on their proximity to the fire, helping us assess which structures are most at risk.

1. Load the NIFC fire perimeter data
2. Create buffer zones around the fire perimeters
3. Load Overture Buildings
4. Spatially join buildings within the buffer zones to categorize them by proximity to the fire

### c. Overture Places Rollup by H3

Finally, we perform a spatial aggregation by calculating the H3 index for the centroids of Overture Places within the fire buffer. This allows us to roll up business categories into H3 hexagons, enabling a holistic overview of business distribution in relation to the fire perimeter.

1. Load the NIFC fire perimeter data
2. Load Overture Places
3. Determine the H3 for the centroid of each building
4. Normalize the 'categories' column into individual columns
5. Roll-up categories by H3, create categories primary set

## Conclusion and Next Steps

This kind of analysis helps understand not only the immediate impact but also in planning for future fire preparedness and recovery efforts. In this post, we saw how Overture and Fire-extent data can help us estimate the extent of the damage, from individual buildings to entire neighborhoods.

Organizations looking to integrate these types of perspectives into their workflows could create apps or API services that deliver derivative products, such as GERS lookups to categorize "fire risk" based on buffer proximity.

They could also use Fused HTTPS endpoints from the UDF to return a CSV with the GERS and "Fire Risk" score for buildings within a defined bounding box, as specified by a query parameter. Additionally, they could also use the HTTPS endpoints to automatically enrich the "Fire Risk" column of an arbitrary dataset for any given Building GERS. Users could apply it to any row of their table, with the functionality powered by a "GERS lookup" endpoint using a GERS ID query parameter.

================================================================================

## Characterize cities with embeddings of Overture Place categories
Path: blog/2025-01-16-maribel/index.mdx
URL: https://docs.fused.io/blog/2025-01-16-maribel

**TL;DR Maribel Hernandez shows how to create clusters of business categories using Overture Places data.**

Maribel Hernandez is a computer scientist and researcher at CINVESTAV, a multidisciplinary academic institution in Mexico. She specializes in graph theory in the field of computational genomics and complex networks. In this blog post, Maribel shows how she characterizes cities based on the distribution of businesses by rolling-up business categories by H3.

As someone who works with urban networks, Maribel's focus is on exploring how cities function and how their design impacts inclusivity. The core question driving this analysis is: Does the city have an even distribution of business services? Or are there shortages such as food deserts or unequal access to health facilities?

To follow along, you can clone and run the associated:
- Colab Notebook
- Overture Places Embedding Clusters UDF

## Introduction

Consider these scenarios:
- How connected are areas dominated by upper-class establishments to the broader city fabric?
- Are health services distributed with equal access from low-income neighborhoods?
- Do certain metropolis have better accessibility and service availability compared to others?

Take, for example, a comparison between 3 key cities in Mexico: Mexico City, Le√≥n, and M√©rida. Are neighborhoods in these cities equally served by essential services such as healthcare, food, and transportation? Could some areas be considered food deserts, while others enjoy easy access to all services?

_Preview of UDF on Workbench._

## Descriptive analysis

When analyzing the urban fabric of cities like Mexico City, Leon, and Merida, we can obsere distinct patterns of service distribution that manifest as rings around the city center.

_Mexico City._

### a. The heart of the city
Especially in Leon and Merida, the central area tends to form a cohesive, dense cluster of services. The core zone houses a variety of businesses including health services, retail, and food outlets, which are generally well-connected and easily accessible. Intuitively, the central cluster can be thought of as the "heart" of the city, serving as the primary hub for commerce, social interaction, and access to essential services.

_Leon._

### b. Islands of Services
Beyond the center, we notice smaller clusters of services scattered across the city, often in the form of "islands." These islands represent pockets of neighborhoods that, while not part of the dense city center, offer an array of unique services. These can serve to highlight the phenomenon of emergent neighborhoods within a greater whole.

_Merida._

### c. Peripheral ring
The periphery of these cities forms another distinct pattern. These outer regions also tend to cluster together in similar service categories, forming a ring that surrounds the central core. It's possible services in these peripheral areas are often more limited in scope and may reflect a focus on residential and less commercial needs, or reflect lower-income neighborhoods with scarcer access to key services.

## Conclusion
This ring-like pattern of service distribution suggests a common trend where the core of the city is highly accessible, while the periphery often lacks the same diversity and depth of business services. The islands of services in between can be seen as attempts to bridge this gap, but they are not always as effective in meeting the needs of the population on the periphery.

These spatial patterns offer valuable insights into the inclusivity of urban networks, highlighting areas that may need attention to ensure strategic business placement and guarantee equitable access to essential services.

## Future work
- Create Network: Create a bipartite network between place categories and H3 indices, using weights as counts for each category.
- Tie in Demographic Data: Integrate INEGI sociodemographic data at the census block group level to understand how services align with population needs.
- Access by Neighborhood: Use origin-destination (OD) movement networks to evaluate service accessibility by neighborhood of residence.
- Segregation Analysis: Identify zones with low visit rates or difficult accessibility. These zones may represent areas of segregation or neglect in the urban network.

================================================================================

## Streamlining the design of parcel delivery routes with H3
Path: blog/2025-01-09-antonius/index.mdx
URL: https://docs.fused.io/blog/2025-01-09-antonius

**TL;DR GLS uses Fused to create internal tooling to optimize routing for parcel delivery operations.**

In the parcel delivery business, geospatial analyses are crucial to answer questions about daily operations. Do delivery drivers visit the same regions each day, letting them know their areas intimately? Or is there a high volatility of the regions? And of course, how do we optimize the routes of multiple drivers servicing the same region?

Those are the questions Antonius is working on at GLS Studio, an innovation lab by GLS (General Logistics Systems) which is an international parcel delivery service provider.

In this blog post, Antonius highlights how he uses Fused to create stable delivery areas for single-day and multi-day aggregates.

## The Challenge Designing Delivery Areas

While the planned areas of driver tours to delivery packages can be rather well-defined, an evaluation of the areas actually served by drivers is equally important and might not be as easy. It can be used for guiding delivery drivers to become more efficient while also enabling managers to identify planned areas that are suboptimal due to built environment features like rivers or big highways.

Creating delivery areas out of single geospatial data points is challenging. A na√Øve approach would be to use convex polygons, but this causes multiple issues:
- A single data point can have a high influence on the shape and area of the polygon
- A tour consisting of multiple not connected sub-areas is hard to detect and correctly display
- This limits the area to what is covered by historic data which leaves a gap in new target regions
- Calculations using polygons are computationally expensive, hindering ad-hoc changes to the selected time span or the calculation parameters

Building new and sometimes experimental features means that the database is often not optimized for the use case. Data needs to be joined between multiple tables and even between multiple data sources. Therefore, fetching all data can be slow, highly limiting the usefulness of having an experimental feature to play around with.

## Solving the Challenge with H3 and Fused UDFs

### Dynamic Delivery Areas with H3

The solution to the first problem came by using H3 cells instead of polygons. By assigning cells to the drivers based on their historic deliveries to the cell, driver areas result automatically. Using H3 cells across different resolutions also allows us to represent the differences between urban and rural areas which see different parcel volumes. While there exists one "base resolution" to ensure non-overlapping and complete areas, the logical hierarchy among H3 cells can be used to calculate on lower resolutions for rural areas that see fewer deliveries, speeding up the computation and ensuring a broader coverage of those areas beyond the historical data points.

On the other hand, disputed H3 cells can be broken down to a higher resolution and assigned to different drivers or, when the "base resolution" has been reached, assigned to the driver delivering most parcels to the cell. As H3 cells have clearly defined neighborhoods, areas can easily be extended beyond their historical limits when desired, covering the empty space around to include a new parcel that falls outside of historically served area boundaries.

_Fused app to show dynamic delivery areas at different H3 resolutions._

### Streamlining workflows with Fused UDFs and Caching

Fused UDFs helped us solve problems around the latency of querying and calculations. When a user looks at an area for a day, they are probably interested in the same area on some of the previous and following days as well, right? So why not pre-calculate that already?

Using Fused, it is simply a matter of fire-and-forget to trigger the UDF with parameters for some previous and following days which are then already running to cache. So when the user views an adjacent day, the data will already be there. And more broadly, when it is possible to limit the number of parameter combinations in an experimental feature to a manageable amount, this fire-and-have-it-cached approach is not limited to caching data from previous and following days, but can also be used for a range of other cases.

_Sample workflow with Fused UDFs._

## Conclusion

When developing new features that are not yet supported by the current data infrastructure, Fused UDFs enabled us to easily test things without having to change the underlying infrastructure in advance. The UDFs are easily shareable and adjustable, allowing testing by multiple people without having to run code locally while automatically making sure everyone is using the same code that is hosted in the UDF. And because we can easily call UDFs with HTTPS endpoints, when we have verified the feasibility of a feature, it's easy to integrate into our product.

================================================================================

## The Strength in Weak Data Part 3: Prepping the Model Dataset
Path: blog/2024-12-12-kristin/index.mdx
URL: https://docs.fused.io/blog/2024-12-12-kristin

**TL;DR Kristin shares a UDF to create training data for a corn yield prediction model using Zonal Statistics.**

Now, suppose we want to do this where corn is grown in the midwest US. Here is what the states that grew corn in 2018:

Within these states, we have **1,333 counties**. Assuming each is similar in size to my home county of Lyon County, we can calculate:

1,333 counties √ó 20,000 data points = **26 million data points**

That's **20,000 times** the statistical power! üéâ

Let me say that louder for the people in the back: **26,000,000 vs. 1,333 data points**

And that's just for one time period. If we run a model on 2‚Äì4 time periods, we're looking at nearly **100 million data points**. Now, building a model on 100 million data points isn't trivial, but at Fused, this process becomes a breeze.

## Building the Training Dataset

I'm aiming to predict corn yield based on my SIF readings from early May, late May, early June, and late June. So, we need to build out a table with this structure:

| County  | Year | Yield (bushels per acre) | Area of Corn (acres) | Area of County (acres) | SIF Value-201605a (early May) | SIF Value-201605a (late May) |
| --- | --- | --- | --- | --- | --- | --- |
| 17015 | 2016 | 205 | 124,145 | 3,032,0383 | .15 | .65 |
|  |  |  |  |  |  |  |

To quickly validate this table against a map, I'll build out my workflow in Fused using Python and query the table with SQL. In the past, working with these two languages would have required complex tooling, storing data in a warehouse, and roughly **five hours** to run. With Fused, I can simply reference the a GeoDataFrame object and query in SQL with DuckDB all within the same UDF‚Äîtaking just **five seconds**!

Here's what it looks like:

## Splitting the Data

But we're not stopping there! To ensure our model is both robust and unbiased, we need to carefully split our data. Enter Walk-Forward Cross-Validation ‚Äî a game-changer for time series data. Think of it like planting seeds each season and harvesting them before the next planting. By always training on past data and testing on future data, we respect the natural flow of time. This method is perfect for corn yields because, just like how last year's harvest influences this year's, our model benefits from understanding those temporal dependencies. Plus, it prevents any sneaky data leakage, ensuring our predictions are based solely on what's known up to that point.

<LazyReactPlayer playsinline= className="video__player" playing= muted= controls height="100%" url="https://fused-magic.s3.us-west-2.amazonaws.com/blog-assets/krv3.mp4" width="100%" />

## Conclusion and Next Steps

Keep going or end here?

By progressively expanding our training set, each fold builds on the last, capturing more nuanced patterns and trends. To bring this to life, I'm leveraging TimeSeriesSplit from **sklearn**, seamlessly integrating it into our workflow. This tool simplifies the process, allowing us to focus on what truly matters‚Äîunlocking the full potential of our 100 million data points for actionable predictions.

And there you have it! We've taken weak, infrequent data and transformed it into a powerhouse dataset ready to drive smarter decisions in the $21 billion corn commodities market. Stay tuned for the next part of our journey, where we'll dive into building and fine-tuning our predictive models. Until then, keep cultivating those insights! üåΩ

================================================================================

## Streamlining Infrastructure Risk Analysis with Fused
Path: blog/2024-12-11-jacob/index.mdx
URL: https://docs.fused.io/blog/2024-12-11-jacob

**TL;DR Jacob at VIDA uses Fused to streamline processing and rendering of CMIP6 climate risk models, improving data sharing and sanity checks.**

================================================================================

## Map Overture Buildings and Foursquare Places with Leafmap
Path: blog/2024-12-10-qiusheng/index.mdx
URL: https://docs.fused.io/blog/2024-12-10-qiusheng

**TL;DR Dr. Qiusheng walks through how you can call Fused UDFs to load data into leafmap maps using Jupyter Notebooks.**

- Google Colab Notebook Walkthrough
- Leafmap Docs

## Calling Fused UDFs to load data

You first use leafmap to create a bounding box over an area of interest (AOI) `user_aoi` and create a GeoDataFrame `gdf_aoi` with it. Then, you can run the Overture Maps UDF, passing the AOI as a parameter to define the area to fetch data for.

================================================================================

## From query to map: Exploring GeoParquet Overture Maps with Ibis, DuckDB, and Fused
Path: blog/2024-12-06-naty/index.mdx
URL: https://docs.fused.io/blog/2024-12-06-naty

**TL;DR Naty shares a UDF to use Ibis with DuckDB's spatial extension to query and explore Overture Maps data.**

Naty is a Senior Software Engineer and a contributor to Ibis, the portable Python dataframe library. One of her main contributions was enabling the DuckDB spatial extension for Ibis in 2023.

In this blog post, she shows us how to leverage the spatial extension in DuckDB with Ibis to query Overture data. Ibis works by compiling Python expressions into SQL, you write Python dataframe-like code, and Ibis takes care of the SQL. Thanks to Ibis integration with Pandas and GeoPandas, you only need to do `to_pandas()` to get your expression as a GeoDataFrame.

}
  title="Overture H3 Skyline"
/> */}

We first establish a connection to a DuckDB database, in this particular case we have an in-memory connection. Then, we do `read_parquet` and we receive a table expression. Since our result, `t`, is a table expression, we can now run queries against the file using Ibis expressions. In this example, to start, we filter by some infrastructure subtypes (pedestrian, and water), select only a few columns, and limit our "search" to a bounding box `bbox`. Notice that this `bbox` is the Fused bounding box, not the overture maps one.

We then rename the column `class` to avoid conflicts with the deferred operator, and finally filter the expression by specific infrastructure classes like toilets, ATMs, drinking water, and other useful information. Up to this point, we only have a table expression, Ibis has a deferred execution model. It builds up expressions based on what you ask it to do and then executes those expressions on request.

To show an example of an aggregate, we executed and printed the `value_counts()` as a Pandas DataFrame. Ibis can execute the table against the DuckDB backend, and return it as a Pandas DataFrame or a GeoPandas GeoDataFrame (if `geometry` column is present), by only doing `to_pandas()`.

### Conclusion

The synergy between Ibis, DuckDB, and Fused has redefined the ease of querying and visualizing geospatial data. These frameworks provide an intuitive and powerful toolkit, enabling users to express geospatial queries, perform efficient transformations, and access high-performance analytics with minimal setup.

By leveraging this stack, interacting with vast geospatial datasets like Overture Maps becomes straightforward, efficient, and accessible.

### Resources

If you want to learn more about Ibis geospatial capabilities, check some of the geospatial blog posts here.

You might also find these resources useful as you dive into Ibis, DuckDB, and Overture:

- Overture Maps Data Repo
- Ibis Docs
- DuckDB spatial extension
- DuckDB spatial functions docs
- Ibis Zulip Chat

================================================================================

## Creating an app to model road mobility networks in Lima, Peru
Path: blog/2024-12-05-claudio/index.mdx
URL: https://docs.fused.io/blog/2024-12-05-claudio

**TL;DR Claudio used Fused to create an app to model road mobility networks in Lima, Peru, using GeoPandas, and OSMnx.**

On December 2023, I visited the Institute for Metropolitan Planning (IMP) in Lima. The director had invited me to share some of my geospatial analysis projects from my master's studies and explore potential collaborations. Around that time, Lima's mayor had announced a bold infrastructure initiative: building 60 flyover bridges to ease traffic congestion in one of the most gridlocked cities in Latin America.

1. Extracting the Road Network: Using OSMnx, I extracted road networks within a defined Area of Interest (AOI).
2. Enriching Data: Each road segment was assigned speed and travel time values.
3. Defining Population Data: A 1km¬≤ grid with population density and zoning data was loaded into a GeoPandas GeoDataFrame.
4. Setting Simulation Parameters:
    - Population size: Derived from density data.
    - Trips per person: Assumed at 2 trips/day (commute to and from work).
    - Origins and Destinations: Residential zones were assigned as homes and commercial zones as workplaces.
    - Trip Schedules: Normal probability distributions were used for departure (6-8 AM) and return times (5-7 PM).

With these parameters, the simulation sampled "home" and "work" nodes, calculated start times, and determined the shortest paths between origins and destinations. Async UDF calls made the process parallelized and efficient. The final output was a GeoDataFrame with:

- Start Time (Unix timestamp)
- Trip Type ("home" or "work")
- Path (list of coordinates)
- Timestamps (for each coordinate)

## Future Plans

This project is far from over. Here are the features I aim to add to make it a valuable tool for urban planners, especially in resource-constrained settings like Lima:

1. Larger AOI Support: Handle bigger datasets and simulate more trips.
2. Multimodal Routing: Incorporate walking, biking, driving, and public transit options, akin to OSRM profiles.
3. Custom Infrastructure: Allow users to model new transit infrastructure within the OSM road network.
4. Mobility Metrics: Provide detailed metrics (e.g., travel times, congestion levels) for each simulation.

With these enhancements, this tool could empower city stakeholders to make data-driven decisions on critical urban interventions‚Äîwhether it's building flyovers or optimizing public transit routes. The ultimate goal? Improving mobility for over 11 million residents in Lima and beyond.

You can try out the public UDF here
}>
<Iframe
  id="claudio"
  code=
  height="600px"
  useResizer=
/>
</div> */}

================================================================================

## Beyond RGB: Interactive Exploration of NEON's Hyperspectral Data
Path: blog/2024-12-03-guillermo/index.mdx
URL: https://docs.fused.io/blog/2024-12-03-guillermo

**TL;DR Guillermo used Fused to build an interactive tool for exploring NEON hyperspectral data, making large-scale geospatial analysis more accessible and actionable for researchers.**

As a research specialist focused on remote sensing applications in semi-arid rangelands, I'm constantly seeking tools that can enhance our ability to process and analyze large-scale geospatial data. The excitement of discovering new platforms that streamline complex workflows never gets old, especially when dealing with the massive datasets typical in remote sensing research.

My journey with Fused began unexpectedly through the "Minds Behind Maps" podcast, where host Maxime Lenormand interviewed Sina Kashuk, Co-Founder and CEO of Fused (see episode). The conversation sparked my curiosity, leading me to explore Fused's community examples and documentation. After signing up for Fused, I knew exactly how I wanted to test it: an interactive tool for exploring NEON's Airborne Observation Platform (AOP) data.

Find Guillermo's UDF code and App associated with the blog post here:
- NEON Hyperspectral GEE UDF
- NEON Dataset Explorer App

## Making Hyperspectral Data Accessible

For those unfamiliar with NEON AOP, it's an NSF-funded initiative revolutionizing ecological observation. Using advanced imaging spectrometers, NEON collects hyperspectral data across 426 distinct wavelength bands at 1-meter resolution. Imagine having 426 different perspectives of the same landscape, each revealing unique insights about vegetation, soil composition, and ecosystem health.

_Source: NEON Imaging Spectrometer._

The real challenge, however, isn't collecting this rich data - it's making it accessible and actionable for researchers. This is where Fused enters the picture. Diving into their documentation and gallery of click-and-run examples, I found myself inspired by the platform's potential. By combining elements from various examples, I began building my first User Defined Function (UDF), eventually discovering the App Builder - a feature that would prove crucial in creating an interactive interface for hyperspectral data exploration. Having worked extensively with Google Earth Engine (GEE) and NEON data, the recent announcement of NEON AOP's availability through GEE presented the perfect opportunity to test Fused's capabilities. My goal was simple yet powerful: create a user-friendly application that could tap into this wealth of hyperspectral data and make it instantly accessible to researchers.

## Looking Ahead

Looking ahead, I'm already planning the next phase of this app. I just want to add functionality that tracks sampling locations and allows users to The experience of building this demo app has reinforced my belief in the importance of platforms like Fused in the geospatial community. They serve as crucial bridges between massive datasets and practical applications, eliminating infrastructure headaches and letting researchers focus on what matters most - the science.

For those interested in exploring NEON's hyperspectral data or learning more about this application, feel free to connect with me or try the app for yourself here.

The future of remote sensing analysis lies in making powerful data more accessible, and I'm excited to be working in this field.

================================================================================

## How DigitalTwinSim Models Wireless Networks with DuckDB, Ibis, and Fused
Path: blog/2024-11-26-sameer/index.mdx
URL: https://docs.fused.io/blog/2024-11-26-sameer

**TL;DR DigitalTwinSim uses Fused with Ibis and DuckDB to model high-resolution wireless networks.**

Sameer, co-founder of DigitalTwinSim, leads the development of advanced geospatial analysis tools to support the telecom industry in strategic network planning. DigitalTwinSim specializes in using high-resolution data to optimize the placement of network towers ensuring reliable, high-speed connectivity.

In this blog post, Sameer shares how he leverages Ibis with a DuckDB backend, and Fused to model wireless networks at high resolution. This approach enables him to quickly generate network coverage models for his clients. He explains and shares a Fused UDF that processes data in an H3 grid to evaluate optimal locations for network towers.

# Fused for Interactive Processing With Instant Visualization

Here, tools like Fused have become essential. Fused allows us to filter and visualize raw output data in a more interactive way, which we can also share with clients to illustrate network design and coverage areas.

To set up the UDF in Fused, we uploaded our data as a Hive-partitioned Parquet folder and created a UDF in Ibis to generate visualizations on demand based on zoom level and area of interest. At higher zoom levels, we compute the parent H3 index and aggregate data to show broader coverage areas; at lower zoom levels, we display individual H3 indices. The H3 polygons are generated and colored dynamically based on the data in the Parquet folder, allowing us to interactively filter data and share visualizations with clients.

Click here to launch the UDF in Fused Workbench.

# Conclusion

As network demands grow and requirements for high-speed internet access become more stringent, accurate, high-resolution modeling is essential for effective planning and deployment.

DigitalTwinSim's integration of tools like DuckDB and Fused, alongside Ibis and H3 grids, enables us to tackle the challenges of processing, analyzing, and visualizing massive datasets. By leveraging DuckDB's powerful data aggregation capabilities, we can manage and analyze high-resolution data efficiently, irrespective of memory constraints. Meanwhile, Fused empowers us to deliver interactive, client-ready visualizations, allowing stakeholders to better understand network coverage and performance.

================================================================================

## The Fastest Way to Download Foursquare's new POI Dataset
Path: blog/2024-11-21-foursquare-poi/index.mdx
URL: https://docs.fused.io/blog/2024-11-21-foursquare-poi

**TL;DR The Fused Team made Foursquare's open dataset of 100M global places accessible via GeoParquet files which you can access via a UDF.**

Foursquare just released an open dataset of over 100M global places of interest.

We at Fused have partitioned these points into easily accessible GeoParquet files, and hosted them on Source Cooperative

On top of that, we've build a publicly available User Defined Function (UDF) that anyone can use to easily look at & download to GeoJSON, all from the browser

**Try it out for yourself!**

You don't need to login or create an account to easily access the Foursquare POI points

- Try out Fused for yourself for free!
- Get familiar with Fused by checkout out our Quickstart docs
- Follow us on LinkedIn to keep up with updates
- Read this more in-depth look at the whole dataset from our community member Mark Litwintschik

================================================================================

## How I Got Started Making Maps with Python and SQL
Path: blog/2024-11-04-kent/index.mdx
URL: https://docs.fused.io/blog/2024-11-04-kent

**TL;DR Stephen Kent shares his journey making maps with Fused using Python and SQL.**

I am a self taught developer and data enthusiast. I first came across the spatial data community when I saw a Matt Forrest video on LinkedIn where he demonstrated how to visualize buildings from the Vida Combined Building Footprints dataset with DuckDB. Immediately I thought, what if you could see all the buildings in a country, say, Egypt? I set out to do just that and made this map with DuckDB and Datashader.

_Buildings in Egypt._

Find Stephen's UDF code here:
- Five Minutes Away in Bushwick Brooklyn UDF

## Starting with Fused

The day after I posted that image on LinkedIn, in April, 2024, I had a call with Plinio Guzman of Fused. I told him what I had been up to, and he was enthusiastic and confident that Fused would fit my needs. One key feature he mentioned was the live development. While I was developing that Egypt map, I had to start the ETL to the final product over and over until I got it looking the way I wanted.

So I got started right away. I found Fused User Defined Functions (UDFs) like Overture Maps and the S2 Explorer and traveled all over the world looking for stunning images. It was thrilling to fly from New York to Tokyo and see the results render instantly.

_Exploring the world with Sentinel 2._

I then began to change the components of these UDFs to see different Overture types, but at this point I was hesitant to build my own UDF from scratch.

## Instant UDFs

That was until Fused launched its File Explorer. With one click, it was now possible for me to create a UDF from providers like Source Cooperative and visualize with numerous presets like DuckDB or GeoPandas. With this new feature, I recreated my Egypt map with the same Vida dataset, this time using DuckDB with the H3 extension. It was liberating, I came to realize the components were simpler than I thought.

## Local Tests

I used DuckDB with the H3 extension without Fused to query Overture Maps for countries and continents all locally in a Jupyter notebook. The benefit with the H3 extension is that if you set up the query right you can aggregate larger than in memory datasets at ease from your notebook.

_Road Density in Africa._

And made this Egypt building map with H3, how does it compare with the Datashader version up top?

_Egypt Building Density with H3._

## Fused and Overture Maps

In August, Fused announced a tighter partnership with Overture Maps Foundation and that came with even more Overture features. Like with Source Cooperative I could now instantly generate UDF of buildings, places, land use, or roads, etc by joining parquet files (and more). I proceeded to use the framework of that UDF to join all kinds of data.

_Proximity analysis between Road Networks and Hospitals in Paris._

## Joining H3 with GeoJSON

One day I was looking at the DuckDB_H3_Example, and I was struck ‚Äî what if I joined those cells with Overture Buildings? I learned how to use the DuckDB H3 extension from all of the example UDFs on Fused. So I called that UDF in an Overture UDF and used GeoPandas to join the two. The result is the map below. The color of the buildings comes from the count of corresponding Yellow Cab pickups. There are millions of points in this TLC parquet file, and H3 helped me to aggregate to thousands for an easier spatial join.

_Overture Buildings joined with H3 Yellow Cab pickups in New York City._

I made this particular map with Kepler.gl, with two clicks from the Workbench. I could have also exported the data to tools like Felt and Mapbox. You can find the code I used to recreate this map here.

## App Builder

I just started working on the Fused App Builder, and made a dashboard to view and interact with NYC‚Äôs 311 call data as a 3D H3 heatmap. Anyone using it can set the date range and resolution to change the display. Very fast and easy to use.

## Community

There's so much exciting data science happening on Fused. Check out Kevin Lacaille's post on ML-less global vegetation segmentation at scale. And Christopher Kyed's Analyzing traffic speeds from 100 billion drive records, that is the kind of project I would love to work on.

I continuously find inspiration as I browse community UDFs. Here's a join of H3 heatmaps with Overture types. This is a heatmap of connectors (intersections) joined with segments (roads) in London. The darker colors have more intersections. I am looking to incorporate traffic counts.

_Road density in London._

## Conclusion

I have been using Fused for several months but it feels like I am just getting started. It seems like the only real limit here is what I can dream up.

_This is a cross-post of Stephen Kent's Medium Article published October 14, 2024._

================================================================================

## Discovering NYC Chronotypes with Fused
Path: blog/2024-10-30-elizabeth/index.mdx
URL: https://docs.fused.io/blog/2024-10-30-elizabeth

**TL;DR Elizabeth Cultrone analyzed NYC Taxi pickup data to identify neighborhood boundaries based on activity patterns. She created a UDF to implement H3 binning and similarity metrics.**

Neighborhoods within a city have consistent characteristics but often have ill-defined boundaries. Some neighborhoods are more similar than others even though they're not nearby. Understanding these local boundaries and the demographics, dynamics and behaviors of different areas affects a wide range of business applications, including advertising, site selection, business analytics, and many more.

_Highlighting natural catchment area boundaries around Koreatown._

## Statistical Analysis

In the App Builder, we created graphs to summarize the similarity values shown in the map. Histograms of the pickups across the most and least similar hexes to each location confirm that the distributions are different for each. We can also explore the cumulative count of hexes to help determine an optimal threshold for similarity values, depending on the application.

_Comparison between most and least similar hexes of two AOIs._

## Conclusion

The Fused UDF Builder makes developing and iterating on these analyses swift and convenient, with no need to jump between different environments for developing vs viewing the results. And although the taxi dataset is small, the Fused Tiling functionality offer the possibility of developing similar analyses with larger datasets. With more data and richer features this proof-of-concept could be expanded to discover more robust, fully-defined neighborhoods, allowing us to develop data-driven approaches to local geography.

================================================================================

## Earth-scale AI pipelines for Earth Observation (Part 1: Data Curation)
Path: blog/2024-10-29-durkin/index.mdx
URL: https://docs.fused.io/blog/2024-10-29-durkin

**TL;DR Fused simplifies how Earth Observation data is processed to curate training data for AI models. Gabriel Durkin shows a Streamlit app he created to train and run land use and crop detection models.**

The rate of prototyping the Fused App Builder unlocks is unrivaled. Recently I used it to create a sophisticated prototype app to accelerate my ML workflow. You can follow along by using the "Cube Factory" app I built.

## Introduction

The field of AI stands to revolutionize Earth Observation (EO), unlocking unprecedented insights from satellite imagery. This article shows how you can leverage multiple layered Fused components:

- Serverless compute
- Highly customizable Fused UDFs
- The Fused App builder

We will harness these resources to curate training datasets that can streamline deep learning workflows. As a working example, we will demonstrate land use inference and crop detection with multispectral satellite imagery.

EO data offer valuable insights for predicting the impact of severe weather events, quantify environmental changes, and tracking natural disasters. Various sectors stand to benefit, from urban planners to finance gurus in commodities and futures trading. AI techniques combined with geospatial data offer insights into short and long term dynamics on Earth, such as deforestation, wildfire management, and agricultural land use.

However, one of the biggest bottlenecks of processing EO data is the time spent on data engineering, holding back researchers from harnessing the full potential of their data.

In this article, we'll demonstrate the Fused platform in effortlessly curating training data for machine learning model development. The derived model can differentiate between developed areas, forests, open lands, vineyards, and fields of corn and soybean.

Here is a screenshot of the simple Python app built to make the data curation and visualization process relatively effortless for the geospatial data scientist. Every control and widget setting in this front end you see here modifies how the data is transformed in the back end by Fused UDFs, one for each data asset available, and produces the map visualizations you see in the viewport, with spot analytics in the sidebar.

Later, as part of the workflow, I will demonstrate spatial querying that will allow us to choose custom regions on which to train a model - simply by outlining polygons on a map.

## Article structure
This is the first of a 3 part series that will show how Fused can be used in querying, processing/ETL, visualization, and inference tasks across stages of the model development lifecycle:
1. **Data curation:** Prepare and generate training images and masks.
2. **Model training:** Feed curated data into a state-of-the-art multiclass segmentation model.
3. **Model Inference:** Establish generalization limits by evaluating model performance on user-selected holdout regions from different locations and timeframes.

## The role of Fused

Fused is a platform that simplifies the engineering challenges involved in building data workflows for Earth Observation (EO) analysis. Its key features for curating training data include:
- **Python User Defined Functions (UDFs):** UDFs define transformations on data and can easily be called with parameters and across different areas of interest.
- **Remote Accessibility:** UDFs can be called from anywhere via HTTPS requests, delivering data exactly where it's needed without the need to store or transfer large datasets.
- **Parallel Execution:** UDFs can run in parallel, processing thousands of data chips per minute for efficient scaling.
- **UDF Workbench:** The UDF Builder provides instant feedback during algorithm development, allowing users to visually inspect the resulting data chips on a dynamic map. Any changes are immediately deployed upon saving.

The synergy of these Fused components enables researchers to dedicate more time to experimentation and analysis rather than data engineering.

> "Ultimately we want Data Scientists to be able to deliver autonomously ‚Äî without operational reliance on a dedicated engineering team, especially given the unwieldy scale and volume of earth observation data."

## Problem overview

An example workflow addresses the challenge of developing a model to categorize and quantify agricultural land use across the continental U.S. with multispectral satellite imagery. This task involves complex multi-class segmentation with several key challenges:

- **Image variability:** Satellite images can vary in resolution, quality, brightness, and cloud cover. Crop reflectivity fluctuates across regions and growing seasons, impacting data selection and algorithm design.
- **Engineering limitations:** Traditional approaches restrict the number of iterations researchers can perform to design and tune a model.
- **Increasing data complexity:** The growing number of spectral bands and satellite sources available requires a systematic approach to selecting an index combination.

By automating engineering processes such as image chipping and source harmonization (time, space, and projection) to prepare training data, researchers can have more iteration cycles as they define spectral indices and band combinations that generalize images.

## Input datasets

Our example model will use 3 bands of Sentinel 2 satellite imagery as input to our ML model to predict a CDL crop mask value - the target layer. We will leverage a Fused "Cube Factory" app we built to generate the chips or "datacubes" that contains both inputs and target. Thinking bigger, there are multiple fused assets which can take the role of input or target. A strength of the fused Cube Factory app is the implicit matching of data in both spatial and temporal dimensions. A further goal of this blog is to demonstrate how easily custom apps like this one can be created and shared on the Fused App Builder.

- Sentinel 2 offers 13-bands of 10 meter resolution imagery with broad temporal and spatial coverage. We chose the Glacier index as the Pseudo Red Channel and Channels 8 (NIR) and 11 as Green and Blue, respectively (image above).
- Land Use Land Cover (LULC) dataset provides a global land cover classification
- Digital Elevation Model (DEM) dataset provides terrain elevation
- Sentinel 1 offers HV and VV polarization bands of 10 meter resolution - active imaging data derived from SAR with broad temporal and spatial coverage and a 6 day cadence.
- The USDA Cropland Data Layer (CDL) dataset maps individual pixels of 30m resolution to hundreds of crops and land types like 'soybean' and 'corn', or even 'pumpkins' and 'cherries'. Below you can see a hyperspectral image of central california, and the dominant crop and land classes in the associated CDL image below.

An additional flexibility offered by the app is the variety of Fused assets that can be called as either inputs or targets. For the viewport visualization we set the left side of the split map as the input layers and the right side as the targets.

Returning to our chosen target, the CDL dataset, it contains up to 256 named crop classes (see: CDL_names_codes_colors), we grouped these together into 10 superclasses to simplify our task.

1. Background/Missing BG
2. Wheat WH
3. Corn CO
4. Soybeans SB
5. Grass/shrub/open lands OL
6. Forest and wetlands FW
7. Open water OW
8. Developed DV
9. Other agricultural (catch-all) OA
10. Other/barren OT

```json

```

## Data curation workflows

The Mask2Former model we will employ for this exercise is optimized for 3 channel RGB images, so we'll use Fused UDFs to create a 4 layer datacube, three inputs from Sentinel 2 and one CDL layer as target. Then, we'll call them across a set of tiles to create the training dataset.

For this example, I selected 3 bands to predict with: glacier index (red-green normalized difference index) is on top, and bands 8 and 11 from Sentinel palette in the middle. The CDL mask at the base of the datacube has pixel values that correspond to major crop classes.

## Create datacube

The first 3 channels of the datacube encode Sentinel 2 bands as RGB false color channels, and the fourth channel encodes the CDL mask are associated with the following 3 UDFs:

1. Choose Right and Left map layers from the Fused asset collection.

2. Choose a Survey Period and location using the left side pop-out menu.

3. If using Sentinel 2 - select 3 of the available 13 bands or one of 6 normalized difference indices.

4. If using digital elevation model as input or target (left or right map side), choose whether terrain, or gradient modes, choose scale parameters, and choose a colormap for visualization.
5. Draw polygons on the map.

## Model training

To train a model on our datacube we downloaded the Mask2Former model from Hugging Face and fine-tuned it on the 10,000 datacubes of 240x240 pixels (resulted in ~1GB of training data). This can be done locally on a GPU machine, or in the cloud on colab or paperspace gradient (now digital ocean). In our next post we will demonstrate how to train ML models natively on the Fused platform.

### Model Hosting

The final model is available on a dedicated Inference endpoint hosted by Hugging Face, and accessed via a API call through a custom Fused UDF. It is available in the Cube Factory app for inspection as the Mask2Former ML layer. This allows a qualitative side by side comparison with the CDL layer. The model was trained on July imaged crops in the midwest among other areas, here is how it performs vs ground truth near Jacksonville Illinois. The left side shows the target layer and the right side shows the model prediction.

<LazyReactPlayer playsinline= className="video__player" playing= muted= controls height="100%" url="https://fused-magic.s3.us-west-2.amazonaws.com/blog-assets/gabe_slider_HD.mp4" width="100%" />

## Conclusion

This post showed how Fused makes it easy to generate training datasets. It gave a practical example of how with Fused UDFs the data loading, data preprocessing, and data loading happen behind an HTTPS endpoint, enabling easy data retrieval from anywhere. There's no need to pre-compute, store preprocessed data, or manually generate tiles, as Fused dynamically generates data for the specified tiles using simple HTTPS calls.

This approach offers several advantages to build customized training datasets. Since data generation is on demand and gets cached, a data scientist can quickly iterate, adjusting spatial or temporal parameters without worrying about managing storage or running jobs to generate datasets. The flexibility to load data that is needed, when it's needed, accelerates experimentation and refinement of models.

To replicate this work for your own AOIs, you can try out the Cube Factory app yourself or run the underlying UDFs on your own Fused Workbench environment. Please feel free to contact me on LinkedIn.

## References
- [1] L. L. Zhang, S. Dhaka, et al., Building a Crop Segmentation Machine Learning Model with Planet Data and Amazon SageMaker Geospatial Capabilities (2023)
- [2] S. Hamdani, Supervised Wheat Classification Using PyTorch's TorchGeo ‚Äî Combining Satellite Imagery and Python (2023)
- [3] Sentinel-2 Mission Overview (2023)
- [4] Digital Elevation Model (DEM) Data (2023)
- [5] ESA WorldCover 10m 2020 V100 (2023)

## Additional Resources
- USDA Cropland Data Layer Methodology
- Sentinel 2 Spectral Band Indices
- Fused Documentation

================================================================================

## DuckDB, Fused, and your data warehouse
Path: blog/2024-10-24-stefano/index.mdx
URL: https://docs.fused.io/blog/2024-10-24-stefano

**TL;DR GLS Studio uses Fused to optimize Snowflake queries. This enables route planning in their ParcelPlanner app with H3-partitioned geospatial data served to a Honeycomb Maps frontend.**

We then created two key UDFs within Fused. These work in tandem to handle authentication, caching, and efficient data retrieval for our DuckDB-powered map:

- **The "Public" UDF (Hammer):** This UDF isn't cached and serves as the entry point. It handles authentication and collects the full date range requested by the customer.
- **The "Private" UDF (Nail):** This cached UDF takes a single date and returns the necessary data for that specific day.

The "Hammer" UDF spawns up to 1,000 asynchronous Fused workers, each running an instance of the "Nail" UDF to fetch data for an individual date, as specified with a parameter. Once the data is retrieved, it is stitched together into a single GeoPandas DataFrame, ready for use.

With this approach, historical data only needs to be read once from Snowflake. For the present date, which is subject to updates, we handle caching differently and apply a one-hour cache to optimise performance.

## Conclusion

In the end, Fused allowed us to integrate our Honeycomb maps directly with Snowflake, handling caching and security concerns. This approach saved us significant backend development and data engineering work‚Äîall with just a few dozen lines of Python.

================================================================================

## The Strength in Weak Data Part 2: Zonal Statistics
Path: blog/2024-10-22-kristin/index.mdx
URL: https://docs.fused.io/blog/2024-10-22-kristin

**TL;DR Kristin created a UDF to mask cropland areas using USDA data and run a Zonal Statistics workflow for corn yield predictions.**

Farming isn't static‚Äîcorn fields rotate with soybeans or cover crops yearly, adding noise to our data. Here's a 25 km¬≤ area:

This block includes not only farmland but also trees, towns, and water bodies. Our challenge is to isolate the specific areas where corn is grown to enhance the precision of our analysis. Enter Fused, which has a Public CDLs UDF that reads the USDA Cropland Data Layer, letting me specify the year and crop type to pinpoint corn accurately.

## Masking crop areas with a UDF

To tackle this, I created a Fused UDF that loads the USDA Cropland Data Layer for a specified year and crop type to identify corn-growing regions. I then used corn-growing regions to mask a Solar Induced Fluorescence raster. Finally, I calculate its mean values for each county.

Now for the fun part:

1. **SIF Data:** Display SIF for a specific month from a NetCDF file.
2. **Corn Areas:** Map corn cultivation that year from a GeoTIFF file of the Cropland Data Layer (CDL) data product.
3. **Precision Clipping:** Clip layers to show SIF values only where corn grows.
4. **Zonal Statistics:** Aggregate the SIF that incides on corn crops for each county.

You can see the UDF code here and even clone it to your Fused workspace.

**Voila!** From one county's weak data to creating summary statistics for the county. This provides the ingredients to boost the prediction strength and reduce noise in the prediction model I want to build.

## Scaling Up

Applying this to **400 Midwest counties** transforms our dataset from 400 points to **60 million**. The results?

- **Enhanced statistical power:** More data = stronger, more reliable predictions.
- **Improved accuracy:** Predictions are more closely aligned with actual outcomes.

Here is how the data compares on a map.

## Why It's simple with Fused

With Fused, working with rasters and vectors is straightforward. This blog post showed how I'm turning weak, unreliable data into a powerhouse of insights effortlessly.

## Ready to transform?

Curious to see the magic? Interact with the UDF in the Fused UDF Builder and elevate your data from weak to strong. Harness your data's full potential and make impactful decisions!

Feel free to reach out if you have any questions at `info@fused.io`.

================================================================================

## Blazing Fast Geospatial SQL in DuckDB
Path: blog/2024-10-17-isaac/index.mdx
URL: https://docs.fused.io/blog/2024-10-17-isaac

In this video from the FOSS4G 2024 conference, Isaac Brodsky, CTO and co-founder of Fused, shows the power of combining H3 with DuckDB to enhance geospatial data analysis.

As an example, Isaac shows a Fused User Defined Function (UDF) that joins the Overture Places dataset and the Natura 2000 biodiversity areas dataset, achieving significant reductions in file size and query execution times. He showcases how the integration allows for efficient data exploration, filtering, and real-time queries, emphasizing the power of DuckDB's H3 extension and spatial extension.

Isaac explains how H3 simplifies geospatial analytics by offering common spatial index to join datasets and enables efficient storage & processing by converting spatial features into 64-bit integers. Additionally, DuckDB enables developers to conveniently transition between Python and SQL. He also highlights how DuckDB can simplify data processing architectures by querying data in real-time from object storage systems such as S3.

================================================================================

## Analyzing traffic speeds from 100 billion drive records
Path: blog/2024-09-25-pacific/index.mdx
URL: https://docs.fused.io/blog/2024-09-25-pacific

**TL;DR Pacific Spatial Solutions uses Fused to streamline data workflows and feature engineering to predict national traffic risk in Japan.**

Over the last few decades, it has become increasingly evident that passenger vehicles are by far the most dangerous way to travel. As a result, it has become more and more important to find an efficient and effective method to predict traffic risk. However, predicting traffic accidents and where they are likely to occur is a very complex problem, with large amounts of data being needed for most meaningful predictions.

At Pacific Spatial Solutions, we are currently trying to tackle this problem by training a machine learning model to predict road and intersection risk in Japan nationwide. As we are trying to predict traffic risk on a national level it is only natural that the data we use cover the same area.

_Drive recorder data points from a single day in a specific part of downtown Tokyo._

## Moving to Fused
Specifically, what we are trying to achieve is to map the speed values from the drive recorder data points to their nearest road. Using a traditional "nearest neighbor" approach would not be feasible, as we would need to measure the distance between billions of points and thousands of roads.
With our current cloud service provider we therefore had to rely on "clustering", so that data points that are close location wise would be close in memory too. This definitely increases performance, but adds some randomness to the processing time and cost because depending on where the area of interest lies in memory, you might have to search through all of your data to find it. As a result, to keep cost and processing time reasonable, we had to limit the nearest neighbor search area using a very small buffer. This was the only way to make our analysis with a dataset of this magnitude feasible.

_Nationwide drive recorder data points and their Fused spatial partitions._

### UDF Design
1. Use `bbox` to load GPS points and roads in the viewport.
2. Structure `DataFrame`s with the GPS points, road krings and road geometry.
3. For each point identify the road with the closest kring cell within a certain k distance, and map the speed to it.
4. Aggregate all of the speed values.

```python showLineNumbers
@fused.udf
def udf(
    bbox: fused.types.TileGDF=None,
    base_path: str = '...'
):
    from utils import df_to_gdf, list_s3, run_pool, get_GPS_road_data

    # Load ingested GPS and road data
    L = list_s3(f'/GPS_hex/')
    df_GPS, df_road_hex, df_road_geom = get_GPS_road_data(bbox, L)

    # Nearest neighbor calculation
    df_final = df_GPS.merge(df_road_hex, on='hexk')
    df_final['distance'] = (df_final['k']+0.5)*k
    df_final['cnt'] = 1
    dfg = df_final.groupby('segment_id')[['cnt', 'speed', 'distance']].sum().reset_index()
    dfg['speed'] = dfg['speed']/dfg['cnt']
    dfg['distance'] = dfg['distance']/dfg['cnt']

    # Introduce geometry to roads
    df = df_road_geom.merge(dfg)
    df['width_metric'] = df['cnt']**0.5/5
    return df.sjoin(bbox[['geometry']])
```

We now have our result which is a DataFrame representing the road network within our bbox. All the roads have their respective aggregated speed, distance and metric values as well as how many points were used for the aggregation. This result can easily be enriched by bringing in more columns from the base data such as the timestamp. This would make it possible to create hourly speed pattern analysis or maybe even a time series visualization.

For demonstration purposes, the video above shows this UDF running on a fraction of the ingested dataset.

_UDF result of Osaka Japan. Line width shows point density. Brighter yellow colors indicate high speed and darker purple colors low speed._

## Conclusion

By leveraging the spatial partitioning that Fused does during ingestion and the flexibility of the h3 library, we have created a method to reliably map our drive recorder points to their nearest segment.

The natural next step will be to scale our analysis using multiple machines and run on all of our data. To achieve this, we would iterate over each of the chunks that fused produced when ingesting our road data, instead of the bbox. This will ensure that our calculations are only run once for each of our roads. The modification can be achieved fairly easily in Fused and we are very excited to see how well Fused will be able to perform in this case.

================================================================================

## Creating cloud-free composite HLS imagery with Fused
Path: blog/2024-09-24-marie/index.mdx
URL: https://docs.fused.io/blog/2024-09-24-marie

**TL;DR Pachama partnered with Fused to generate cloud-free HLS image composites, improving tropical forest monitoring and canopy height mapping for carbon conservation projects.**

_Example composites highlight how the HLS-L30 product alone can have gaps when attempting to make a seasonal composite, as fewer cloud-free observations._

This blog post explores how Pachama's engineering team partnered with Fused to generate cloud-free seasonal composites using Harmonized Landsat Sentinel-2 (HLS) data, enabling higher quality optical imagery and better canopy height map creating ML model performance.

## Obstacles to create a cloud-free HLS image composite

The HLS dataset is an exciting development put forward by NASA's Satellite Needs Working Group. It provides consistent surface reflectance data with global observations every 2-3 days at a 30-meter resolution. The dataset harmonizes data from Landsats 8 & 9 with the European Space Agency's Sentinel-2A & 2B satellites such that the results are high quality, standardized, and able to be combined [2].

The HLS dataset consists of scene-level harmonized data, and does not create any cloud-free composite images by default. A significant amount of compute power is needed to process and combine this data, which contains multiple petabytes of data. Iteration on the compositing algorithm is also essential to quickly experiment and refine the process.

_Example of HLS image for a region in Brazil with clouds._

One common solution to this problem is to use Google Earth Engine (GEE). However, only the Landsat portion of this dataset (HLS-L30) is available on GEE. Without the Sentinel-2 portion of this dataset (HLS-S30), we do not get a 2-3 day temporal resolution that is required for cloud-free imagery in frequently cloudy areas.

## With Fused

Pachama turned to Fused to create scalable workflows for quickly iterating on a compositing algorithm. Fused's UDF model allowed Pachama to design algorithms that parallelize image processing, generate cloud-free composites, and run these workflows at scale.

### Pachama's UDF workflow

Here's the workflow we created with a Fused User Defined Function (UDF) to generate cloud-free composite HLS imagery.

### 1. Write a UDF to load imagery

This sample UDF loads data for the Landsat and Sentinel2 data products. It queries for a specific date range and does a first pass at filtering out images with too many clouds.

```python showLineNumber
# To Get your username and password, Please visit https://urs.earthdata.nasa.gov
@fused.udf
def udf(
    bbox: fused.types.TileGDF,
    mask_url: str,
    band_url: str,
    username="<INSERT USERNAME>",
    password="<INSERT PASSWORD>",
    env="earthdata",
):

    utils = fused.load("https://github.com/fusedio/udfs/tree/f928ee1/public/common/").utils
    # Authenticate
    aws_session = utils.earth_session(cred=)
    cred = 
    overview_level = max(0, 12 - bbox.z[0])

    # Read band data
    band_arr = utils.read_tiff(
        bbox,
        band_url,
        overview_level=overview_level,
        cred=cred,
    )

    # Read and apply cloud mask
    mask_arr = utils.read_tiff(
        bbox,
        mask_url,
        overview_level=overview_level,
        cred=cred,
    )
    cloud_mask = (mask_arr & 0b00000010) >> 1
    band_arr = np.where(cloud_mask == 1, np.nan, band_arr)

    # Filter nan's and convert to RGB values
    band_arr = np.where(band_arr == -9999, np.nan, band_arr)
    band_arr = band_arr / 10
    band_arr += 1 # workaround for uint8 and nan values
    band_arr = band_arr.astype("uint8")

    return np.array(band_arr)
```

### 2. Call the UDF asynchronously

This UDF queries the LP DAAC STAC catalog for data that matches the time and location of interest. This UDF then calls the previous one in parallel asynchronously to fetch each cloud-free image in parallel. It then combines the outputs, taking the median of each band to create a cloud-free composite.

```python showLineNumber

@fused.udf
async def udf(
    bbox: fused.types.TileGDF,
    date_range="2023-05/2023-06"
):

    from collections import defaultdict

    RGB_BANDS = ["B04", "B03", "B02"]
    F_MASK_BAND = "Fmask"

    # Query STAC catalog
    band_urls = get_band_urls(bbox, date_range)

    # Call the image loading/masking UDF in parallel
    tasks = defaultdict(list)
    for band in RGB_BANDS:
        for mask_url, band_url in zip(band_urls[F_MASK_BAND], band_urls[band]):
            arr_task = fused.run(
                "<INSERT UDF TOKEN>",
                bbox=bbox,
                sync=False,
                parameters=)
            tasks[band].append(arr_task)

    # Combine each band
    rgb = []
    for band in RGB_BANDS:
        task_results = await asyncio.gather(*tasks[band])
        composite_values = []

        # Convert back to format with nan's
        for arr in task_results:
            arr = arr.image.values.astype("uint8")
            arr = np.where(arr == 0, np.nan, arr)
            arr += 1
            composite_values.append(arr)

        # Take median of the composite values
        band_composite = np.nanmedian(composite_values, axis=0)
        band_composite = band_composite.astype("uint8")
        rgb.append(band_composite)

    return np.array(rgb)
```

The UDF above generates a cloud-free composite image and gives Pachama control and transparency over the image inputs.

_Example of cloud-free HLS image composite for the same region in Brazil._

## Benefits of using Fused

The best part is that Pachama's Data Science team can design UDF while looking at a specific area, and to run it for a different region by simply changing the input bounding box (bbox). This flexibility allows Pachama to create individual image tiles for any location worldwide. They can easily experiment and generate composites for different date ranges by adjusting the input parameters.

- Easy parallelization with simple Python function calls, no need to manage clusters
- Iterate on both UDFs in the same code editor with the UDF Builder
- Instant feedback during algorithm development, no need to wait for pipelines to run
- Invoke UDF and load its data into a Jupyter Notebook with `fused.run` for downstream analysis

## Conclusion

Thanks to Fused, Pachama's scientists and engineers can quickly iterate and experiment with different algorithms to optimize their image composites. Scaling the algorithm to apply to a larger area also becomes trivial by using Fused. Pachama can more efficiently improve transparency into forest carbon projects through better data and better insights, faster.

## References

- [1] On the Advantages of Using Harmonized Landsat Sentinel-2 Data for Monitoring Environmental Change
- [2] An Update on NASA's Harmonized Landsat and Sentinel-2 Project
- [3] An initial evaluation of carbon proxies for dynamic reforestation baselines

================================================================================

## The Strength in Weak Data Part 1: Navigating the NetCDF
Path: blog/2024-09-23-kristin/index.mdx
URL: https://docs.fused.io/blog/2024-09-23-kristin

**TL;DR Fused streamlined Kristin's workflow to integrate CSV and NetCDF data directly from S3.**

Ever tried to make sense of the myriad file types in spatial data science and felt like you've wandered into a linguistic labyrinth? Trust me, you're not alone. As a data scientist who's spent more time wrangling datasets than I care to admit, I thought I'd take a casual stroll down memory lane with an old high school friend: regression models. Just a simple plot of actual vs. predicted, right? But when spatial data's involved, you can't just sit back and relax‚Äîyou've got to keep one eye on the geometries.

I'm currently working on an agricultural project, and growing up on a farm gives me a personal stake in this. This blog illustrates my solution to the geometry debacle. I'll first take you to the area where I grew up: Lyon County.

The resolution differences are huge‚Äîgoing from 30 square meters up to 5 billion! Traditional tools would have you pulling your hair out, but Fused lets you turn this "weak" data into something powerful.

## Actual Variable: Handling the Data Mismatch

When dealing with data that doesn't quite match up‚Äîlike trying to combine different resolutions‚Äîyou need to align everything to the coarsest resolution. In this case, that's the county level.

Here's how I tackled it: I grabbed a CSV file of county ANSI codes along with my actual variable data. Using Fused's Fused's File Explorer, I plotted the data easily. Just a quick visit to the File Explorer S3 bucket, a double-click on the file, and the entire map rendered instantly.

Remember the days of wrestling with shapefile resolutions? No more. I edited the UDF to pull my actual data CSV straight from my S3 bucket in under 30 seconds. Boom.

## Predictor Variable: Navigating the NetCDF

Now, let's get into the predictor variable‚Äîa NetCDF file from 5 degrees off the equator, covering around 25 square kilometers. NetCDF files can be a bit tricky to work with due to their complex formats, but Fused's utility modules make it easier. I imported some key functions directly into my UDF to clip the array, convert it into an image, and add a colormap.

```python showLineNumber
@fused.udf
def udf(bbox: fused.types.TileGDF=None, path: str='s3://fused-asset/misc/kristin/sif_ann_201508b.nc'):
    xy_cols=['lon','lat']
    utils = fused.load("https://github.com/fusedio/udfs/tree/057a273/public/common/").utils
    # Get the data array using the constructed path
    da = utils.get_da(path, coarsen_factor=3, variable_index=0, xy_cols=xy_cols)
    # Clip the array based on the bounding box
    arr_aoi = utils.clip_arr(da.values,
                       bounds_aoi=bbox.total_bounds,
                       bounds_total=utils.get_da_bounds(da, xy_cols=xy_cols))
    # Convert the array to an image with the specified colormap
    img = (arr_aoi*255).astype('uint8')
    return utils.arr_to_plasma(arr_aoi, min_max=(0, 1), colormap="rainbow", include_opacity=False, reverse=True)
```
Once I saved the UDF and created an HTTPS endpoint, I visualized the data interactively in the App Builder.

## The Variable That is Going to Make this Weak Data Strong

Okay, I have prepped my actual and predictor variables. Now, I will focus on how to fuse the geometries together using the variable that is going to make this Weak Data Strong (30 square meters). For that, stay tuned for Part 2, where I'll dive into the techniques for aligning and merging these spatial layers into a cohesive analysis. See you in the next installment!

================================================================================

## Enrich your dataset with GERS and create a Tile server
Path: blog/2024-09-19-overture/index.mdx
URL: https://docs.fused.io/blog/2024-09-19-overture

**TL;DR Fused enables on-the-fly enrichment of Overture datasets using simple spatial joins.**

Overture is an open data project that publishes interoperable map datasets. It aims to foster an ecosystem of developers creating downstream map services around its data products. Fused emerged as a solution to enrich Overture datasets on the fly and serve them with XYZ Tile endpoints.

### Why this matters

Datasets often lack the structure required to support the creation of reliable map services and products. A dataset may reference real-world entities using its own conventions, making it challenging to integrate with other datasets. Overture promotes interoperability with GERS (Global Entity Reference System) IDs, which link dataset entities to the same real-world features. This simplifies the process of conflating multiple datasets, ensuring consistency.

The Overture Buildings theme provides a comprehensive collection of global building footprints, but different use cases might call for additional building information. This could include attributes related to risk assessment, census information, zoning regulations, property management details, and more. By enriching datasets with GERS IDs, users can easily link external data sources to power analytical applications.

However, enriching a dataset can be computationally and memory-intensive due to the size of the data. Fused addresses this by enabling live queries and rendering data directly from the source GeoParquet files, eliminating the need to create new tiles each time the underlying data is updated.

## Step-by-step guide

In this post, we show how to enrich your dataset by matching it with the Overture Buildings theme using GERS IDs. This makes your dataset easier to visually inspect and more accessible for others to integrate with their data.

For this example, we created a Fused User Defined Function (UDF) to load the NSI Structures dataset and overlay it on the Overture Buildings dataset. This will let us visualize buildings based on attributes from NSI such as structure value or height. We'll then turn the UDF into an XYZ Tile server to create an app.

================================================================================

## The App That Finds Your City's Rainfall Twin Globally
Path: blog/2024-09-17-milindsoni/index.mdx
URL: https://docs.fused.io/blog/2024-09-17-milindsoni

**TL;DR Milind analyzes global precipitation patterns using H3 indexing, cosine similarity, and Earth Engine data to create an interactive rainfall comparison app.**

## How It Works

Our UDF utilizes the following key components:

1. Earth Engine API: To fetch global precipitation data
2. H3 Index: For efficient spatial indexing
3. DuckDB: For fast query execution on geospatial data
4. Cosine Similarity: To compare rainfall vectors

## The Workflow

1. **Data Aggregation with DuckDB**: The data retrieval process is streamlined using Fused and Xarray:
   - **Fused and Earth Engine**: Fused simplifies access to Google Earth Engine's vast catalog. It provides a more intuitive and faster interface with a much better file manager for working with spatial data compared to the Earth Engine platform itself.

   - **Xarray Integration**: We use Xarray to work with our multi-dimensional rainfall data. It allows for easy handling of labeled arrays and datasets, particularly useful for time-series climate data.

2. **Data Aggregation with DuckDB**: After retrieving the raw data, we use DuckDB to efficiently aggregate it. This involves:
   - Grouping the data by H3 hexagon and month
   - Calculating the average monthly rainfall for each hexagon
   - Creating 12-element vectors representing annual rainfall patterns for each location

3. **Cosine Similarity Calculation**: Finally, we use cosine similarity to compare these rainfall vectors. This allows us to quantify how similar the rainfall pattern of one location is to another, or a reference pattern.

4. **Converting UDF to an app with Fused App Builder**: To make the rainfall similarity comparison UDF accessible and interactive, I used the Fused App Builder to help quickly build an app from the UDF that I just created. Every data scientists favourite prototyping tool is Streamlit which helps to build frontends in Python quickly and that's what the app builder brings to you! Convenience of Streamlit with the Power of Fused.

## The App Builder

If you are familiar with Streamlit, it is super convenient to build UI from just Python code. Folium maps helped me build interactive maps where I can draw areas to compare with and I could also write a custom HTML-based iframe to integrate Mapbox GL within the app itself, the snippets of which again are available in the Fused documentation.

1. **Interactive Folium Map**

I implemented a Streamlit Folium based map that allows users to select a location of interest.

2. **Plotly Charts**

A bar chart displays monthly rainfall data for the selected location in the folium map after querying the UDF and passing the GeoJSON shape as a parameter in the UDF,

3. **Iframe Integration**

- The hex-similarity map shows global rainfall pattern similarities.

### Calling the UDF within the App

Just one line of code to call my UDFs within the app to

- Fetch the historical rainfall data from Google Earth Engine for the marked area.
- Aggregate rainfall vectors
- Calculate the similarities of the location with the vectors in the bounding box in the iframe

It was as easy as `fused_app.run("fsh_****")`

### Performance and Optimization

Fused and Streamlit already have excellent caching mechanisms which helped me cache large amounts of data and information prior to the usage so that the next time the app loads, the computations are much faster! I can compare the rainfall patterns of any two locations on the Earth in seconds with a few lines of code. How cool is that!

> Building scalable Geospatial Applications have never been so quick and easy!

================================================================================

## Six ways to use Fused
Path: blog/2024-09-12-danieljahn/index.mdx
URL: https://docs.fused.io/blog/2024-09-12-danieljahn

**TL;DR: Fused is a versatile platform that serves as a code catalog, a parallel data processing engine, an app creation tool, a serverless HTTPS endpoint generator, and an IDE.**

*Example from How Pachama creates maps on-the-fly with Fused*

## 5. Geospatial Streamlit

Streamlit is a Python library that helps you create and
deploy web apps
with a few lines of code.

Streamlit is also the best first-time-user experience I've had with a library.
Without prior experience, I could immediately go from a Python script straight to an interactive web app.

With Fused's App Builder, any UDF can be turned into an interactive Streamlit app.
Fused also automatically serves the app for you.
While the app itself runs in the browser using Pyodide, it can call any Fused UDF, processing the data using the Fused engine.

  height="800px"
  useResizer=
  requirements=
/> */}

## 6. Geospatial-first IDE

Of the six, this is the most aspirational use case.
It's also potentially the most impactful.

Fused provides the Workbench, a great web-based IDE.
Working with it started changing how I think of developing geospatial applications.

[Image: ]

Today, there are two worlds.

- On one side, the software engineer uses test-driven-development to develop well-designed code in quick iterations.

- On the other side, the data scientist develops code directly against real data using notebooks and visualizations.

Fused can bring these worlds together. Simply annotating your function as `@fused.udf` gives you the ability to immediately visualize the results with real data, over any geographic region.
Fused Workbench does this, but you could equally develop in VSCode and switch to QGIS to immediately inspect the results.

By developing your code as a web of stateless UDFs and utilizing `@fused.cache`, you gain the ability to develop automatically cached pipelines whose results can be inspected in tools like Felt or served with an HTTPS endpoint without any added work.

Often the greatest cost of data pipelines is developer time.
Fused has the potential to tighten the development feedback loop and catch errors early, reducing the time needed to develop robust data pipelines.

## Conclusion

This article gave six concrete examples of how you can use Fused today.

However, the possibilities of Fused are not limited to these examples. With its powerful execution engine, visual IDE, growing host of integrations, and just-copy-the-link app deployment, Fused is generic enough to enable use cases not even the team behind it has thought of.

I'm excited about the future of Fused. I wouldn't be surprised to see it become a ubiquitous tool in the geospatial world.

================================================================================

## AI for object detection on 50cm imagery
Path: blog/2024-09-05-dl4eo/index.mdx
URL: https://docs.fused.io/blog/2024-09-05-dl4eo

**TL;DR Jeff Faudi used Fused for real-time object detection on 50cm satellite imagery, displaying results as an interactive web map.**

In this article I show how to create an object detection layer on 50cm imagery in realtime. It explains how to create a Fused User Defined Function (UDF) to load satellite image tiles to call an inference model, then publish it as an interactive map app.

To display this image on the web, you typically need to project it in Web Mercator projection with gdal and cut it into 256x256 pixels tiles that will be displayed nicely by web-mapping applications such as GoogleMaps, OpenLayers, Mapbox, MapLibre, Leaftlet or Deck.gl.

Until recently, I would have done this physically and generated thousands of tiles. Now, we will do this almost magically with Fused.

## Creating a UDF

Basically, I just have to write the piece of code that generate the content of a tile and Fused takes care of running the code and providing the urls to share the layer in any application. The Python function that I have to write is called a UDF and it has at least one parameter which contains the bounding box (bounds) on which I need to generate the tile.

```python showLineNumbers
@fused.udf
def udf(
    bbox: fused.types.TileGDF = None,
    chip_len: int = 256):

    from utils import read_geotiff_rgb_3857

    geotiff_file = 's3://fused-users/dl4eo/my_image.tif'
    return read_geotiff_rgb_3857(bbox, geotiff_file, output_shape=(chip_len, chip_len))
```

First, it is worth noting that we extract all content from a GeoTIFF image (ideally a COG i.e. Cloud Optimized GeoTIFF) which contains the bands and geometric information about the satellite image. This GeoTIFF is stored anywhere on the cloud. Here, it is stored in the AWS S3 bucket provided by Fused. Also, note that the function returns an array for raster tiles but could return a GeoJSON for vector tiles.

We use the bounding box of the tile provided as a parameter, convert it from lat/long to Web Mercator (EPSG:3857), get the corresponding bounding box in the original image, and project it in Web Mercator projection in the destination array with the correct desired tile size (typically 256x256 pixels).

The Fused UDF Builder enables one to view the result and logs while coding.

## Implementing aircraft detection

Now, if we want to display a real-time aircraft detection layer, we could replicate the previous step: send the resulting image extract to the API and display a vector layer. However, we must avoid applying deep learning algorithms to images that might have been zoomed. These algorithms are typically trained at a specific resolution, and the Web Mercator projection does not preserve size.

_https://en.wikipedia.org/wiki/Mercator_projection_

We read the content of the Pleiades image in its original projection (either the raw geometry or a transverse mercator projection in which the central meridian would pass through the center of the image). In this case, the resolution is guaranteed to be the correct native resolution of the image.

The UDF gets the Pleiades image in the correct projection, then calls the prediction API, and finally returns the predictions in a GeoDataFrame which will be dynamically rendered on the map. For performance, we have added the @fused.cache decorators which make the function automatically cache results for identical parameters. The predictions are returned in pixels in the source image and then converted into lat/long so they render on a map. Then, when we look at the result in the workbench, we get some issues at the border of the tiles.

The reason is that if an aircraft is on the tile border, it will be detected partially on the lower tile and potentially on the upper tile. The two bounding boxes might not align perfectly so we cannot merge them. The solution here is to extract a image larger than the tile: if the center of the predicted box is inside the tile we keep it, if it is outside we discard it. We usually use a margin that is the upper size of the objects we are trying to detect i.e. 100 meters for aircrafts. After these little improvements, the result is much nicer

## Building a web app

Now that everything is running fine in the workbench, it is time to extract the layers and include them in a webpage. Fused provides an easy way to integrate layers in external applications via HTTPS requests. You just need to go to Settings, click Share and copy the provided URL.

Then, you can integrate this URL as the tile source in any mapping application. I am not diving into that here, but you can read how to do this in the DeckGL Fused docs. You can check the code source of the demonstration below. Here is the extract of the JavaScript Deck.gl code where the URL is integrated.

And here it is: the final working demonstration!

## Conclusion

Huge thanks to the amazing team at Fused for their incredible support, and to my former colleagues at Airbus for providing the stunning Pleiades image. I think that this application turned out to be very sleek and powerful. If the underlying satellite image changes, the AI layer gets automatically recomputed on the fly.

I'd love to hear your thoughts!

_This article was originally published in LinkedIn on June 20th 2024._

================================================================================

## Summarizing building energy ratings
Path: blog/2024-09-03-isaac/index.mdx
URL: https://docs.fused.io/blog/2024-09-03-isaac

In this video tutorial, I show a complete data app workflow in Fused. Starting with exploring the data in Fused, the tutorial walks through developing a UDF to serve the data, and then a Fused App to share results.

With Fused, this whole workflow takes just minutes from beginning to end. Fused helps me visualize the data at every step, iterate on my analytical logic, and finally publish a dashboard.

================================================================================

## ML-less global vegetation segmentation at scale
Path: blog/2024-08-29-kevin/index.mdx
URL: https://docs.fused.io/blog/2024-08-29-kevin

**TL;DR Kevin used Fused to create a global vegetation segmentation layer without machine learning, displaying results as an interactive web map.**

================================================================================

## How Pachama creates maps on-the-fly with Fused
Path: blog/2024-08-27-pachama/index.mdx
URL: https://docs.fused.io/blog/2024-08-27-pachama

**TL;DR Pachama uses Fused to create maps on-the-fly for their sustainability platform.**

Pachama is a technology company that harnesses satellite data and AI to empower companies to confidently invest in nature. The engineering team at Pachama created a Land Suitability Tool to help landowners and project developers qualify parcels of land to implement carbon projects. They turned to Fused to simplify their data workflows.

## The Challenge: Quickly Assess Potential Restoration Projects

Pachama harnesses earth observation data and AI to bring unprecedented insight into how forests sequester carbon, protect wildlife, and benefit local communities. By harnessing the latest advancements in technology, they bring transparency and integrity to forest restoration projects, catalyzing funding in natural climate solutions.

Pachama recently built the Land Suitability Tool within their Reforestation Partner Portal to revolutionize how project developers assess the restoration potential of prospective project sites. In this portal, organizations and landowners looking to start a reforestation project define an Area Of Interest (AOI) by drawing or uploading a polygon, then estimate the land's eligibility based on data layers derived from environment models that take into account country-level data about land cover, vegetation history, and natural risks. For example, a project may look to derive credits from carbon sequestration through native reforestation and ally with local communities that earn an income as stewards of the land.

One of Pachama's challenges was making preprocessed data available for user-defined AOIs that aren't known ahead of time. This would require generating and storing data for entire countries, which is expensive given that a preprocessing step is billed for each square kilometer.

Furthermore, the process involved transferring data between backend and frontend teams, each with different requirements. This resulted in converting datasets between formats, workflows with complex infrastructure, long-running jobs, and slow turn-around times.

## The Solution: Serverless Tile Generation with Fused

To overcome these challenges, Pachama turned to Fused to generate maps on the fly with serverless API endpoints. Fused now provides them an elegant way to write custom workflows to crunch data with Python and serve it behind tile endpoints that natively integrate with map tile layers. This makes it possible to process and visualize any dataset with manageable operation costs.

> **"Fused has been critical in our product lifecycle. The speed at which we were able to iterate based on new requirements is unrivaled."**
>
> **Andrew Campbell, Senior Software Engineer @ Pachama**

The ability to trigger a UDF that generates a vector directly from a Zarr file was a game-changer for Pachama's ability to close the gap between their analytics and their end-users. This innovation has made the team more productive and enabled them to streamline complex tasks that were previously cumbersome and impractical.

> **"Fused takes DevOps out of our hands to focus on our core mission, building technology to restore nature."**
>
> **Marie Hoeger, Staff Software Engineer @ Pachama**

The Land Suitability tool covers the contiguous USA, Brazil, Mexico, Argentina, Guatemala, Panama, Paraguay, Colombian Amazon, and the Peruvian Amazon. Pachama plans to expand to more regions around the world. It processes a variety of datasets including Pachama's proprietary canopy height map. Pachama generates regional maps of average top-of-canopy height using a combination of lidar from GEDI and a suite of satellite observations at varying spatial scales, including optical and radar imagery, topography, and climate data. Fused's on-the-fly tiling simplifies the workflows to generate and load the data into the user-facing app.

By combining analytical and visualization capabilities, Fused enables powerful and productive workflows. Instead of pre-computing tiles for entire datasets, Pachama now generates tiles dynamically only for user-defined AOIs, reducing system complexity and cost.

Here's a minimalist example of how Pachama uses a Fused User Defined Function (UDF) to generate a vector from a raster file in COG format:

```python
@fused.udf
def udf(bbox: fused.types.TileGDF=None):

    from utils import raster_to_vector

    table_path = "s3://pachama-fused-data/dataset.tiff"
    gdf = raster_to_vector(table_path, bbox)
    return gdf
```

This UDF can be called via HTTPS request with the following URL structure:

```
https://www.fused.io/server/v1/realtime-shared/fsh_1gcTv/run/tiles///?dtype_out_vector=mvt
```

## Key Features

The Fused automatically provisions an endpoint for each of Pachama's UDFs. The prospecting application then loads the endpoint into a Mapbox application, which consumes the output in MVT format as defined by the `dtype_out_vector` parameter.

- HTTPS Endpoints work with slippy maps, which is standard across map tiling applications.
- Map clients call the endpoint for each tile in the viewport, passing values for z, x, and y. Fused then runs the UDF, passing a GeoDataframe with the Tile coordinates.
- The UDF code spatially filters the referenced dataset, processes the fraction of data, and returns it to the client app as the response of the HTTPS call in the format specified via a query parameter. This avoids the need to pre-compute data or manage files.

## The Result: Simplify Data Workflows By 50%
Fused and its UDF environment revolutionize how Pachama renders tile-based maps by leveraging analytical tools: cloud-optimized data formats, the flexibility of Python for spatial operations, and the scalability of serverless. Engineers at Pachama used to see a gap between the analytical data formats (e.g. COGs & GeoParquets) and visualization data formats (MVT, PMTiles, XYZ Tiles). Fused closed the gap and let them retire a major piece of the pipeline.

> **"Fused replaced 4 steps of the pipeline with a single Fused UDF."**
>
> **Andrew Campbell, Senior Software Engineer @ Pachama**

## Future innovation for Pachama
Looking ahead, Pachama aims to expand this powerful tool worldwide, catalyzing high-integrity reforestation projects in the regions that need it the most. With Fused's infrastructure underpinning its platform, Pachama can stay focused on making powerful science and analytics accessible to everyone through intuitive visual interfaces.

Read about Pachama's mission and learn how they use technology to evaluate forest carbon projects to assess carbon projects.

================================================================================

## Geospatial workflows of any size
Path: blog/2024-04-22-webinar/index.mdx
URL: https://docs.fused.io/blog/2024-04-22-webinar

Isaac Brodsky, the CTO of Fused, delved into the power of Fused during a LinkedIn live session with Matt Forrest. They discussed the contrast of Python vs. SQL for data analytics, the advantages of serverless geospatial processing, and showcased a live demo of the UDF Builder. During the demo, Isaac created a User Defined Function visualize Overture building footprints that are within a certain proximity of water.

You can re-watch the webinar on LinkedIn, YouTube, or below.

================================================================================

## DuckDB + Fused: Fly beyond the serverless horizon
Path: blog/2024-04-09-duckdb/index.mdx
URL: https://docs.fused.io/blog/2024-04-09-duckdb

**TL;DR Fused extends DuckDB to bring quick serverless operations on any scale dataset. The result is a lightweight, portable, and flexible system that is simultaneously scalable, cost-efficient, and simple to integrate across the stack.**

The combination of Fused serverless operations and DuckDB offers blazing fast data processing. Fused embraced Python to create serverless User Defined Functions (UDFs). Now, with the help of DuckDB, Fused enables developers to leverage the ease and familiarity of SQL in these functions ‚Ää- ‚Ääwithout compromising performance and parallelism.

This blog explains how Fused User-Defined Functions (UDFs) can extend DuckDB to bring quick serverless operations on any scale dataset. The result is a lightweight, portable, and flexible system that is simultaneously scalable, cost-efficient, and simple to integrate across the stack.

The blog post illustrates three complimentary implementations:
1. Run DuckDB in a Fused UDF
2. Call Fused UDFs from DuckDB
3. Integrate DuckDB in applications using Fused

## The evolution of the data processing landscape
For companies with bottom lines that depend on time to insight, the data landscape is driven by the need to process increasing data volumes and make operations easier to express. This section discusses how Fused and DuckDB can address these needs within the context of the latest wave of the data processing ecosystem.

### Increasing data¬†volumes
When the size of data required for an operation is larger than memory, it becomes a bottleneck. In the early 2010's, the effort to process increasing volumes of data created MapReduce, Hadoop, and Spark to help companies scale out clusters. The complexity of managing clusters gave way to managed services like Databricks and Snowflake, but their high cost and inefficient data transfer with Python (by now a staple of data science) still left parts of the market unaddressed.

Many technologies emerged to attempt to address latent gaps, but it was DuckDB that surged around 2020 as a fast, easy to use, and cost effective solution to process large volumes of data with SQL while reducing the switching cost of having to learn new frameworks. At around the same time, serverless solutions to address the scale out problem started to gain traction.

Now, as AI training and inference require ever more data, the speed of processing and the speed of development become critical bottlenecks. DuckDB and serverless processing together enable new applications. DuckDB gives workflows an in-process performant SQL engine with:

- Fast processing of large datasets through larger than memory processing with a vectorized query engine.
- Zero-copy interoperability with Python, thanks to formats like Apache Arrow.
- Portability and unprecedented developer experience with easy set-up and without the need to maintain a database server.
- Extensibility thanks to an ecosystem of plugins and extensions (C++), scalar Python UDFs, and WebAssembly compatibility.

DuckDB's modularity in data interchange and query execution makes it an ideal choice for serverless architectures. The combination of DuckDB and serverless has unique advantages:

- Fast and cheap data access thanks to cloud optimized data formats that enable retrieving part of the file (e.g. Parquet for tabular data, Cloud Optimized GeoTIFF for imagery.)
- Scalability, distributed compute without managing infrastructure and without expense when code is not running.
- Easy to share results and create integrations by triggering jobs and loading data via simple HTTPS calls.

## Python + SQL¬†synergy
Python is the lingua franca of data science and AI. It's an imperative language‚Ää-‚Ääwhich means it's easy to write complex logic without sacrificing readability, and interface a broader range of data formats‚Ää-‚Ääenabling operations inaccessible to SQL like calling API clients, fine-grained analytic calculations, and processing arrays and rasters. The Python ecosystem recently adopted Rust to write high performance, memory safe modules. However, Python historically struggled with concurrency and managing the memory of distributed clusters, which hindered its ability to process large datasets.

Declarative languages like SQL offer simple syntax to define data manipulations for performant query engines, but they lack explicit control flow and are limited to select data structures.

Two approaches to intertwine SQL and Python emerged, each with particular tradeoffs in portability and efficiency:
- **SQL queries in Python.** These tend to sacrifice data transfer efficiency between runtimes or require specialized, complicated data warehousing.
- **Python UDFs within SQL.** These tend to incur performance costs and require maintaining a Python runtime within the DBMS.

These are offered, to different extents, by tools like Databricks, BigQuery, and Postgres.
- **Databricks** offers a notebook environment, familiar to the data scientist, that enables workflows to transition between Python and SQL‚Ää-‚Ääbut requires specialized data warehousing, complicated cluster management, and lacks debuggability.
- **BigQuery** UDFs bring an imperative language to SQL engine‚Ää-‚Ääbut it's constrained to Javascript which lacks Python's powerful data operations and libraries.
- **Postgres** and other databases can bring SQL to a Python runtime with connector libraries such as Psycopg2 and SQLAlchemy‚Ää-‚Ääbut this pattern has the infrastructure overhead of needing to run a separate database server.

However versatile, DuckDB is founded on SQL and still needs to rely on Python and plugins for expressibility. But its support for Python UDFs and plugins is yet to mature.
- DuckDB only supports scalar Python UDFs.
- Constrained to the capabilities of the local runtime process.
- There's no seamless way to share Python UDFs across databases or runtimes.
- Plugins are difficult to write and deploy.

## Fused + DuckDB¬†synergy
Fused is a framework to author and run serverless operations. Every Fused UDF is an HTTPS API that can be called to run and load data from any application that can make HTTPS requests. Integrating UDFs into workflows is as easy as passing the endpoint as a string. Spreadsheets, web maps, ETL pipelines, and DuckDB can all load data from HTTPS API endpoints, and dynamically parametrize calls with query parameters.

- Eliminates the need to provision, manage, and scale instances‚Ää-‚Ääwhich is what caused the initial break away from the Map Reduce, Hadoop, and Spark era. Its just-in-time backend scales from zero to cluster as quickly as needed.
- UDFs can call UDFs‚Ää-‚Ääwhich results in blazing fast execution by running thousands of parallel jobs -without worrying about orchestration.
- Pay only when code runs, and run from anywhere‚Ää-‚Ääwhich speaks to market segments unaddressed by managed platforms like Databricks and Snowflake.
- Natively runs on a standard Python interpreter‚Ää-‚Ääso it seamlessly runs DuckDB while keeping Python's expressibility and ecosystem of libraries.
- Dovetails with cloud-native data formats. Their atomic data loading and compressed formats make for reduced data transfer between local processes and third party cloud warehouses.

Fused and DuckDB together reduce architectural complexity and make it easy to have cutting-edge analytic processing in any application. Together, they eliminate the need for cumbersome distributed query engines which are slow to start-up and are overkill for smaller datasets.

Fused UDFs are easy to share and can run from anywhere. The examples in this post are available as community UDFs you can find on the open source Github repo and run them in any Python environment with the Fused SDK.

## Example patterns

This section shows and discusses three powerful patterns at the intersection of Fused and DuckDB.
### 1. Run DuckDB in a Fused¬†UDF

DuckDB parallelizes its own operations under the hood thanks to its columnar vectorized query engine that provides compelling performance for querying using SQL. However, there can still be bottlenecks in operations upstream or downstream of DuckDB. To resolve this, Fused UDFs easily run DuckDB and create a seamless experience between Python and SQL.

See the full example in our documentation.

### 2. Call Fused UDFs from¬†DuckDB

Any database that supports querying data via HTTPS can call and load data from Fused UDF endpoints using common formats like Parquet or CSV. This means that DuckDB can dispatch operations to Fused that otherwise would be too complex or impossible to express with SQL, or would be unsupported in the local runtime.

In this example, a Fused UDF returns a table where each record is a polygon generated from the contour of a raster provided by the Copernicus Digital Elevation Model as a Cloud Optimized GeoTIFF. DuckDB can easily trigger a UDF and load its output with this simple query, which specifies that the UDF endpoint returns a Parquet file.

<img src="https://fused-magic.s3.us-west-2.amazonaws.com/docs_assets/gifs/sql.gif" alt="overture" width="600"/>

This pattern enables DuckDB to address use cases and data formats that it doesn't natively support or would otherwise see high data transfer cost, such as raster operations, API calls, and control flow logic.

See the full example in our documentation or open it in this [DuckDB shell%0ALIMIT-10~).

### 3. Integrate DuckDB in applications using¬†Fused

Fused is the glue layer between DuckDB and apps. This enables seamless integrations that trigger Fused UDFs and load their results with simple parameterized HTTPS calls.

DuckDB is an embedded database engine and doesn't have built-in capability to share results other than writing out files. As a corollary of the preceding example, it's possible to query and transform data with DuckDB and seamlessly integrate the results of queries into any workflow or app.

<img src="https://fused-magic.s3.us-west-2.amazonaws.com/docs_assets/gifs/sheets.gif" alt="overture" width="600"/>

To try this example simply make a copy of this Google Sheets spreadsheet (File > Make a copy) and click, and modify the parameters in B2:4 to trigger the Fused UDF endpoint and load data.

See the full example in our documentation.

## Conclusion

While the pendulum of the data landscape swung from distributed compute to single-node, Fused's serverless operations swing the conversation back with a simple and cost-efficient scale-out.

This blog post discussed how gaps in the modern data stack can be addressed by integrating Fused and DuckDB, two emerging data processing tools. The intersection between DuckDB's portable SQL and Fused's scalable python operations creates a stack that is:
Flexible due to the seamless interaction of Python and SQL.
Scalable, simple, and cost efficient.

Easy for data scientists to create, and easy for non-coders to consume.

DuckDB is an early example of how Fused integrates with the modern data stack. We're eager to share the growing list of compelling integrations over the following months.

We would like to extend our thanks to Wes McKinney and Michael Driscoll for reviewing drafts of this post before it went out.

## Get started with¬†Fused

Want to get involved?

- Try out Fused for yourself for free!
Give back to the community by contributing a UDF.
- You can also join the conversation by becoming a member of the Fused Discord community. We are always happy to hear your thoughts.
- Does taking serverless operations to the next level sound exciting to you? Fused is hiring! Shoot us a note at `sina@fused.io`.

================================================================================

## Fused redefines geospatial with instant maps
Path: blog/2024-03-06-pressrelease/index.mdx
URL: https://docs.fused.io/blog/2024-03-06-pressrelease

Fused is a modern geospatial toolkit for companies to code, scale, and ship geospatial workflows of any size.

This week we are unveiling Fused, a toolkit to enable interoperability between all geospatial datasets and tools in the modern data stack. Fused is the glue layer that integrates data platforms with data tools via a managed serverless API.

## Overview

Co-founders Sina Kashuk and Isaac Brodsky met while working at Uber. They co-founded Unfolded to commercialize the popular open source geospatial visualization projects Kepler.gl, Deck.gl, and H3. Unfolded was acquired by Foursquare in June, 2021.

Fused has raised $1 million in pre-seed funding from Fontinalis Partners, Wes McKinney, Michael Driscoll, Jason Richman, and angels from Uber, Airbnb, DoorDash, and others.

Fused delivers serverless geospatial operations at any point of the stack ‚Äî with a simple HTTPS call. This is like when users pull-up information from map apps, but with custom and transparent logic. This shields developers from hours of burdensome engineering, enabling businesses to serve their customers with timely insights, faster.

Teams supercharge their favorite IDEs, tools, and frameworks with Fused. They build with the Python SDK, preview on the browser with Fused Workbench, and run in their stack via the Hosted API.

_Fused ecosystem and product line._

## The problem

We're now in a moment where large-scale geospatial datasets are migrating to open cloud-enabled formats. However, we have personally seen how it can be challenging to utilize this data at scale. At the same time, there has been a rise in Earth observation imagery, which will only accelerate as we monitor climate change and as satellites continue scaling, enabling. However, the sheer volume of data, complexity of operations, and fragmentation of tooling holds back how we process and present that data that is critical for making informed decisions about critical company operations.

Today, data scientists and analysts manually conduct multistep processes fragmented across tools and data standards with the help of an army of data engineers and infra (if they are lucky) just to render data on a map. The size of data limits the possible depth of insight of last-mile analytics and the speed at which they can be delivered ‚Äî leaving problems unaddressed. Moreover, data scientists handoff algorithms to data engineers who then translate code to work with orchestrators that run on distributed compute systems maintained by an entire devops team. An analyst needs to navigate a sea of buzzwords like CRS, GDAL, Spark clusters, geo-partitions, raster and vector joins, zonal stats, and census blocks ‚Äî just to prepare for the analysis they actually want to do.

## The solution

Today, a leading global media company animates atmospheric rivers to report weather news ‚Äî 36x speed improvement, from hours to minutes. An EV company uses Fused to optimize its EV charging station network planning capabilities ‚Äî blending data at an unprecedented coverage and detail. A carbon offset company creates custom deforestation basemaps with better operational efficiency ‚Äî closing the analysis loop for stakeholder reports.

Fused empowers teams in these companies to seamlessly layer weather, infrastructure, road, and deforestation data; while transforming it with custom Python code to create apps for real-time decision making. Fused simplifies workflows so small teams can deliver novel business-critical insights where it wasn't possible before.

Read more: Founder's Blog Post

## Vibrant community

As a founding tenet, Fused promotes open source, transparency, and collaboration. To this end, data scientists and app builders engage the Fused community on GitHub and Discord to find, reuse, and share verified code snippets that they can bring into their workflows.

Community UDF of hydrology model by Taher Chegini
In sum, Fused allows people for the first time to easily work with geospatial data and integrate it with modern data tools. This is a radical departure from times when for any geospatial analysis you would have to send it to your GIS person to analyze it and get it back in 3 weeks, if you get lucky (and forget about integrating that with any other tools). Fused is built to be the interoperable glue between geospatial data systems, and we're excited to bring best-in-class cloud infrastructure and distributed computing to this industry.

Join the journey to break away from old geospatial infrastructure. Let's revolutionize geospatial technology together! fused.io. üåéüöÄ

Join the journey

- Read the announcement on Tech Crunch
- Follow us on Twitter/X
- Follow us on LinkedIn
- Star our GitHub repo
- Join the conversation on Discord
- Read Fused's founding principles

================================================================================

## Founder's blog post: why Fused?
Path: blog/2024-03-01-welcome/index.mdx
URL: https://docs.fused.io/blog/2024-03-01-welcome

Fused enables interoperability between datasets and tools in the modern data stack. It's a glue layer to integrate data platforms with data tools via a managed serverless API.

## Current limitations with data processing

Today, there is a fragmented ecosystem around scalable geospatial data processing. Python geospatial libraries like GeoPandas, Shapely, and Rasterio make it easy to do small jobs but are single-threaded and operate entirely in-memory. For bigger jobs, there are Python parallel processing tools like Dask that require complex installations and are liable to memory pressure errors. Spark-based tools like Apache Sedona and RasterFrames have a steep learning curve and are hard to debug and orchestrate. Postgres and its geospatial extension PostGIS operate on larger-than-memory datasets but are hard to scale larger than the disk of one machine, aren‚Äôt designed for OLAP workloads, and can be hard to administer. Cloud data warehouses like Databricks and Snowflake are monolithic systems that tend to bring lock-in and pricing that is hard to anticipate.

Spatial SQL is a great way to run scalable operations on tables with vector data - but falls short on raster data and does not have native access to libraries for the finesse operations of data science. Geospatial data science teams largely use Python and would prefer to use it both in development and in production - but tooling fragmentation forces them to juggle languages and frameworks. The present paradigm accepts the inefficiencies of complexity as a necessary evil because there hasn‚Äôt been a better way to work with both raster and vector data at scale. Data teams have an unaddressed need for a friendly Python API that scales. To increase development velocity it‚Äôs convenient for most code to run in Python, moving only computationally heavy code into specialized frameworks - as efficiently as possible. Additionally, scaling Python from local development to massive cloud workloads calls for efficient parallelization.

## Seizing the moment

The last several years have seen a commoditization of modular building blocks of OLAP systems and increased adoption of geospatial cloud-native data formats. With the convergence and popularity of columnar memory formats like Apache Arrow and Apache Parquet, easy-to-use columnar OLAP databases like DuckDB, and broader adoption of geospatial cloud-native data formats like Cloud-Optimized GeoTIFF and GeoParquet, we believe there‚Äôs a window for a serverless geospatial OLAP engine. Moreover, serverless computing has emerged as a prominent trend, delegating infrastructure management and dynamically scaling resources in response to demand, leading to heightened flexibility and cost efficiency. Leveraging serverless cloud infrastructure like AWS Lambda, Azure Functions, Google Cloud Functions, or Cloudflare Workers enables event-driven processing closer to the data source.

Parquet files have become the standard file format for columnar data and have helped to commoditize the decoupling of storage and compute by enabling queries directly on object storage like AWS S3. GeoParquet ‚Äì a specification for storing point, line, and polygon geometries in Parquet ‚Äì has seen recent momentum as a fast storage format for geospatial vector data and has started to be integrated into industry-standard tools like GDAL. Moreover, with spatial partitioning, operations can be broken down into small independent parts that execute simultaneously in multiple processes. For geospatial array data like satellite imagery, Cloud-Optimized GeoTIFF ‚Äì an extension to GeoTIFF that enables chunked access via HTTPS range requests ‚Äì has taken hold as the standard way to store geospatial image data, with petabytes publicly available from AWS‚Äô open data program and buy-in from major vendors like USGS and Planet.

Apache Arrow has become the universal in-memory columnar data format for columnar, analytic data because its language-independent specification enables easier movement of data between languages and frameworks. Moreover, GeoArrow ‚Äì an incubating specification for storing geospatial data in Arrow ‚Äì gives us a way to move geospatial data from Python to compiled code for free, and will likely serve as the foundation for an ecosystem of large-data geospatial tools. Already in the frontend, deck.gl can use GeoArrow-style data buffers to visualize millions of coordinates with no serialization costs.

As a result of all these trends, smaller data can be transferred to and processed on serverless cloud services in ways that are not possible ever before. Public clouds enable event-driven compute services that automatically scale, which makes for simple infrastructure and dependency management. Managed offerings reduce the complexities of data pipelines enabling geospatial workloads of any size to run on demand ‚Äì to empower users with the ability to go from code to map, instantly.

## Why Fused?

Fused instantly converts user‚Äôs Python code to workflows and maps in Jupyter notebooks, low-code web apps, the Fused Workbench web-app, ETL pipelines, or any tool that consumes HTTPS API endpoints. Fused lets developers run real-time serverless operations at any scale and build responsive maps, dashboards, and reports. Developers develop in production and run on any scale data without infrastructure friction using serverless parallel computing powered by advanced caching of geo-partitioned data. This enables bringing interoperable workflows, apps, and maps to the user's preferred stack and avoiding vendor lock-in.

With Fused, users find, reuse, and share User Defined Functions (UDFs) in the Fused vibrant community. Fused UDFs are building blocks of serverless geospatial operations that integrate across the stack - with Planetary Computer, Google Earth Engine, Big Query, Snowflake, DuckDB, and more. They load datasets from the cloud ecosystem such as NASA, NOAA, US Census, and Overture. Fused serverless API turns these UDFs into live HTTPS endpoints that load their output into any tools.

Fused allows people for the first time to easily work with geospatial data and integrate it with modern data tools. This is a radical departure from times when you manually conduct multistep processes fragmented across tools and data standards with the help of an army of data engineers and infra (if they are lucky) just to render data on a map. Fused is built to be the interoperable glue between geospatial data systems, and we‚Äôre excited to bring best-in-class cloud infrastructure and distributed computing to this industry.

Join us in our journey to break from old geospatial infrastructure. Let's revolutionize geospatial technology together! üåéüöÄ

- The Fused Founding Team

================================================================================


---

Generated automatically from Fused documentation. Last updated: 2026-01-08
Total sections: 3
